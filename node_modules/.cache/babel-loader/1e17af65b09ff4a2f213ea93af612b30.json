{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/ui.scheduler.appointment_model.js)\r\n * Version: 19.1.6 (build 19263-1729)\r\n * Build date: Fri Sep 20 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n\n      if (\"value\" in descriptor) {\n        descriptor.writable = true;\n      }\n\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) {\n      defineProperties(Constructor.prototype, protoProps);\n    }\n\n    if (staticProps) {\n      defineProperties(Constructor, staticProps);\n    }\n\n    return Constructor;\n  };\n}();\n\nvar _config = require(\"../../core/config\");\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _date_serialization = require(\"../../core/utils/date_serialization\");\n\nvar _date_serialization2 = _interopRequireDefault(_date_serialization);\n\nvar _utils = require(\"./utils.recurrence\");\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _date = require(\"../../core/utils/date\");\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _common2 = _interopRequireDefault(_common);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _array = require(\"../../core/utils/array\");\n\nvar _array2 = _interopRequireDefault(_array);\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _query = require(\"../../data/query\");\n\nvar _query2 = _interopRequireDefault(_query);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar toMs = _date2.default.dateToMilliseconds;\nvar DATE_FILTER_POSITION = 0,\n    USER_FILTER_POSITION = 1;\n\nvar FilterMaker = function () {\n  function FilterMaker(dataAccessors) {\n    _classCallCheck(this, FilterMaker);\n\n    this._filterRegistry = null;\n    this._dataAccessors = dataAccessors;\n  }\n\n  _createClass(FilterMaker, [{\n    key: \"isRegistered\",\n    value: function value() {\n      return !!this._filterRegistry;\n    }\n  }, {\n    key: \"clearRegistry\",\n    value: function value() {\n      delete this._filterRegistry;\n    }\n  }, {\n    key: \"make\",\n    value: function value(type, args) {\n      if (!this._filterRegistry) {\n        this._filterRegistry = {};\n      }\n\n      this._make(type).apply(this, args);\n    }\n  }, {\n    key: \"_make\",\n    value: function value(type) {\n      var _this = this;\n\n      switch (type) {\n        case \"date\":\n          return function (min, max, useAccessors) {\n            var startDate = useAccessors ? _this._dataAccessors.getter.startDate : _this._dataAccessors.expr.startDateExpr,\n                endDate = useAccessors ? _this._dataAccessors.getter.endDate : _this._dataAccessors.expr.endDateExpr,\n                recurrenceRule = _this._dataAccessors.expr.recurrenceRuleExpr;\n            _this._filterRegistry.date = [[[endDate, \">\", min], [startDate, \"<\", max]], \"or\", [recurrenceRule, \"startswith\", \"freq\"], \"or\", [[endDate, min], [startDate, min]]];\n\n            if (!recurrenceRule) {\n              _this._filterRegistry.date.splice(1, 2);\n            }\n          };\n\n        case \"user\":\n          return function (userFilter) {\n            _this._filterRegistry.user = userFilter;\n          };\n      }\n    }\n  }, {\n    key: \"combine\",\n    value: function value() {\n      var filter = [];\n      this._filterRegistry.date && filter.push(this._filterRegistry.date);\n      this._filterRegistry.user && filter.push(this._filterRegistry.user);\n      return filter;\n    }\n  }, {\n    key: \"dateFilter\",\n    value: function value() {\n      return this._filterRegistry.date;\n    }\n  }]);\n\n  return FilterMaker;\n}();\n\nvar compareDateWithStartDayHour = function compareDateWithStartDayHour(startDate, endDate, startDayHour, allDay, severalDays) {\n  var startTime = _date2.default.dateTimeFromDecimal(startDayHour);\n\n  var result = startDate.getHours() >= startTime.hours && startDate.getMinutes() >= startTime.minutes || endDate.getHours() === startTime.hours && endDate.getMinutes() > startTime.minutes || endDate.getHours() > startTime.hours || severalDays || allDay;\n  return result;\n};\n\nvar compareDateWithEndDayHour = function compareDateWithEndDayHour(startDate, endDate, startDayHour, endDayHour, allDay, max) {\n  var result,\n      hiddenInterval = (24 - endDayHour + startDayHour) * toMs(\"hour\"),\n      apptDuration = endDate.getTime() - startDate.getTime(),\n      delta = (hiddenInterval - apptDuration) / toMs(\"hour\"),\n      apptStartHour = startDate.getHours(),\n      apptStartMinutes = startDate.getMinutes();\n\n  var endTime = _date2.default.dateTimeFromDecimal(endDayHour);\n\n  result = apptStartHour < endTime.hours || apptStartHour === endTime.hours && apptStartMinutes < endTime.minutes || allDay && startDate <= max;\n\n  if (apptDuration < hiddenInterval) {\n    if (apptStartHour > endTime.hours && apptStartMinutes > endTime.minutes && delta <= apptStartHour - endDayHour) {\n      result = false;\n    }\n  }\n\n  return result;\n};\n\nvar AppointmentModel = function () {\n  function AppointmentModel(dataSource, dataAccessors, baseAppointmentDuration) {\n    _classCallCheck(this, AppointmentModel);\n\n    this.setDataAccessors(dataAccessors);\n    this.setDataSource(dataSource);\n    this._updatedAppointmentKeys = [];\n    this._filterMaker = new FilterMaker(dataAccessors);\n    this._baseAppointmentDuration = baseAppointmentDuration;\n  }\n\n  _createClass(AppointmentModel, [{\n    key: \"_createFilter\",\n    value: function value(min, max, remoteFiltering, dateSerializationFormat) {\n      this._filterMaker.make(\"date\", [min, max]);\n\n      var userFilterPosition = this._excessFiltering() ? this._dataSource.filter()[USER_FILTER_POSITION] : this._dataSource.filter();\n\n      this._filterMaker.make(\"user\", [userFilterPosition]);\n\n      if (remoteFiltering) {\n        this._dataSource.filter(this._combineRemoteFilter(dateSerializationFormat));\n      }\n    }\n  }, {\n    key: \"_excessFiltering\",\n    value: function value() {\n      var dateFilter = this._filterMaker.dateFilter(),\n          dataSourceFilter = this._dataSource.filter();\n\n      return dataSourceFilter && (_common2.default.equalByValue(dataSourceFilter, dateFilter) || dataSourceFilter.length && _common2.default.equalByValue(dataSourceFilter[DATE_FILTER_POSITION], dateFilter));\n    }\n  }, {\n    key: \"_combineFilter\",\n    value: function value() {\n      return this._filterMaker.combine();\n    }\n  }, {\n    key: \"_getStoreKey\",\n    value: function value(target) {\n      var store = this._dataSource.store();\n\n      return store.keyOf(target);\n    }\n  }, {\n    key: \"_filterAppointmentByResources\",\n    value: function value(appointment, resources) {\n      var _this2 = this;\n\n      var result = false;\n\n      var checkAppointmentResourceValues = function checkAppointmentResourceValues() {\n        var resource,\n            resourceGetter = _this2._dataAccessors.getter.resources[resourceName];\n\n        if (_type2.default.isFunction(resourceGetter)) {\n          resource = resourceGetter(appointment);\n        }\n\n        var appointmentResourceValues = _array2.default.wrapToArray(resource),\n            resourceData = _iterator2.default.map(resources[i].items, function (item) {\n          return item.id;\n        });\n\n        for (var j = 0, itemDataCount = appointmentResourceValues.length; j < itemDataCount; j++) {\n          if ((0, _array.inArray)(appointmentResourceValues[j], resourceData) > -1) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      for (var i = 0, len = resources.length; i < len; i++) {\n        var resourceName = resources[i].name;\n        result = checkAppointmentResourceValues.call(this);\n\n        if (!result) {\n          return false;\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_filterAppointmentByRRule\",\n    value: function value(appointment, min, max, startDayHour, endDayHour, firstDayOfWeek) {\n      var recurrenceRule = appointment.recurrenceRule,\n          recurrenceException = appointment.recurrenceException,\n          allDay = appointment.allDay,\n          result = true,\n          appointmentStartDate = appointment.startDate,\n          appointmentEndDate = appointment.endDate;\n\n      if (allDay || this._appointmentPartInInterval(appointmentStartDate, appointmentEndDate, startDayHour, endDayHour)) {\n        var trimmedDates = this._trimDates(min, max);\n\n        min = trimmedDates.min;\n        max = new Date(trimmedDates.max.getTime() - toMs(\"minute\"));\n      }\n\n      if (recurrenceRule && !_utils2.default.getRecurrenceRule(recurrenceRule).isValid) {\n        result = appointmentEndDate > min && appointmentStartDate <= max;\n      }\n\n      if (result && _utils2.default.getRecurrenceRule(recurrenceRule).isValid) {\n        result = _utils2.default.dateInRecurrenceRange({\n          rule: recurrenceRule,\n          exception: recurrenceException,\n          start: appointmentStartDate,\n          end: appointmentEndDate,\n          min: min,\n          max: max,\n          firstDayOfWeek: firstDayOfWeek\n        });\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_appointmentPartInInterval\",\n    value: function value(startDate, endDate, startDayHour, endDayHour) {\n      var apptStartDayHour = startDate.getHours(),\n          apptEndDayHour = endDate.getHours();\n      return apptStartDayHour <= startDayHour && apptEndDayHour <= endDayHour && apptEndDayHour >= startDayHour || apptEndDayHour >= endDayHour && apptStartDayHour <= endDayHour && apptStartDayHour >= startDayHour;\n    }\n  }, {\n    key: \"_createCombinedFilter\",\n    value: function value(filterOptions, timeZoneProcessor) {\n      var dataAccessors = this._dataAccessors,\n          startDayHour = filterOptions.startDayHour,\n          endDayHour = filterOptions.endDayHour,\n          min = new Date(filterOptions.min),\n          max = new Date(filterOptions.max),\n          resources = filterOptions.resources,\n          firstDayOfWeek = filterOptions.firstDayOfWeek,\n          getRecurrenceException = filterOptions.recurrenceException,\n          that = this;\n      return [[function (appointment) {\n        var recurrenceRule,\n            result = true,\n            startDate = new Date(dataAccessors.getter.startDate(appointment)),\n            endDate = new Date(dataAccessors.getter.endDate(appointment)),\n            appointmentTakesAllDay = that.appointmentTakesAllDay(appointment, startDayHour, endDayHour),\n            appointmentTakesSeveralDays = that.appointmentTakesSeveralDays(appointment),\n            isAllDay = dataAccessors.getter.allDay(appointment),\n            appointmentIsLong = appointmentTakesSeveralDays || appointmentTakesAllDay,\n            useRecurrence = _type2.default.isDefined(dataAccessors.getter.recurrenceRule);\n\n        if (useRecurrence) {\n          recurrenceRule = dataAccessors.getter.recurrenceRule(appointment);\n        }\n\n        if (resources && resources.length) {\n          result = that._filterAppointmentByResources(appointment, resources);\n        }\n\n        if (appointmentTakesAllDay && false === filterOptions.allDay) {\n          result = false;\n        }\n\n        var startDateTimeZone = dataAccessors.getter.startDateTimeZone(appointment),\n            endDateTimeZone = dataAccessors.getter.endDateTimeZone(appointment),\n            comparableStartDate = timeZoneProcessor(startDate, startDateTimeZone),\n            comparableEndDate = timeZoneProcessor(endDate, endDateTimeZone);\n\n        if (result && useRecurrence) {\n          var recurrenceException = getRecurrenceException ? getRecurrenceException(appointment) : dataAccessors.getter.recurrenceException(appointment);\n          result = that._filterAppointmentByRRule({\n            startDate: comparableStartDate,\n            endDate: comparableEndDate,\n            recurrenceRule: recurrenceRule,\n            recurrenceException: recurrenceException,\n            allDay: appointmentTakesAllDay\n          }, min, max, startDayHour, endDayHour, firstDayOfWeek);\n        }\n\n        if (result && comparableEndDate < min && appointmentIsLong && !isAllDay && (!useRecurrence || useRecurrence && !recurrenceRule)) {\n          result = false;\n        }\n\n        if (result && void 0 !== startDayHour) {\n          result = compareDateWithStartDayHour(comparableStartDate, comparableEndDate, startDayHour, appointmentTakesAllDay, appointmentTakesSeveralDays);\n        }\n\n        if (result && void 0 !== endDayHour) {\n          result = compareDateWithEndDayHour(comparableStartDate, comparableEndDate, startDayHour, endDayHour, appointmentTakesAllDay, max);\n        }\n\n        if (result && useRecurrence && !recurrenceRule) {\n          if (comparableEndDate < min && !isAllDay) {\n            result = false;\n          }\n        }\n\n        return result;\n      }]];\n    }\n  }, {\n    key: \"setDataSource\",\n    value: function value(dataSource) {\n      this._dataSource = dataSource;\n      this.cleanModelState();\n\n      this._initStoreChangeHandlers();\n\n      this._filterMaker && this._filterMaker.clearRegistry();\n    }\n  }, {\n    key: \"_initStoreChangeHandlers\",\n    value: function value() {\n      var _this3 = this;\n\n      this._dataSource && this._dataSource.store().on(\"updating\", function (newItem) {\n        _this3._updatedAppointment = newItem;\n      }.bind(this));\n      this._dataSource && this._dataSource.store().on(\"push\", function (items) {\n        items.forEach(function (item) {\n          _this3._updatedAppointmentKeys.push({\n            key: _this3._dataSource.store().key(),\n            value: item.key\n          });\n        }.bind(_this3));\n      }.bind(this));\n    }\n  }, {\n    key: \"getUpdatedAppointment\",\n    value: function value() {\n      return this._updatedAppointment;\n    }\n  }, {\n    key: \"getUpdatedAppointmentKeys\",\n    value: function value() {\n      return this._updatedAppointmentKeys;\n    }\n  }, {\n    key: \"cleanModelState\",\n    value: function value() {\n      this._updatedAppointment = null;\n      this._updatedAppointmentKeys = [];\n    }\n  }, {\n    key: \"setDataAccessors\",\n    value: function value(dataAccessors) {\n      this._dataAccessors = dataAccessors;\n      this._filterMaker = new FilterMaker(dataAccessors);\n    }\n  }, {\n    key: \"filterByDate\",\n    value: function value(min, max, remoteFiltering, dateSerializationFormat) {\n      if (!this._dataSource) {\n        return;\n      }\n\n      var trimmedDates = this._trimDates(min, max);\n\n      if (!this._filterMaker.isRegistered()) {\n        this._createFilter(trimmedDates.min, trimmedDates.max, remoteFiltering, dateSerializationFormat);\n      } else {\n        this._filterMaker.make(\"date\", [trimmedDates.min, trimmedDates.max]);\n\n        if (this._dataSource.filter() && this._dataSource.filter().length > 1) {\n          this._filterMaker.make(\"user\", [this._dataSource.filter()[1]]);\n        }\n\n        if (remoteFiltering) {\n          this._dataSource.filter(this._combineRemoteFilter(dateSerializationFormat));\n        }\n      }\n    }\n  }, {\n    key: \"_combineRemoteFilter\",\n    value: function value(dateSerializationFormat) {\n      var combinedFilter = this._filterMaker.combine();\n\n      return this._serializeRemoteFilter(combinedFilter, dateSerializationFormat);\n    }\n  }, {\n    key: \"_serializeRemoteFilter\",\n    value: function value(filter, dateSerializationFormat) {\n      var that = this;\n\n      if (!Array.isArray(filter)) {\n        return filter;\n      }\n\n      filter = (0, _extend.extend)([], filter);\n      var startDate = that._dataAccessors.expr.startDateExpr,\n          endDate = that._dataAccessors.expr.endDateExpr;\n\n      if (_type2.default.isString(filter[0])) {\n        if ((0, _config2.default)().forceIsoDateParsing && filter.length > 1) {\n          if (filter[0] === startDate || filter[0] === endDate) {\n            filter[filter.length - 1] = _date_serialization2.default.serializeDate(filter[filter.length - 1], dateSerializationFormat);\n          }\n        }\n      }\n\n      for (var i = 0; i < filter.length; i++) {\n        filter[i] = that._serializeRemoteFilter(filter[i], dateSerializationFormat);\n      }\n\n      return filter;\n    }\n  }, {\n    key: \"filterLoadedAppointments\",\n    value: function value(filterOptions, timeZoneProcessor) {\n      if (!_type2.default.isFunction(timeZoneProcessor)) {\n        timeZoneProcessor = function timeZoneProcessor(date) {\n          return date;\n        };\n      }\n\n      var combinedFilter = this._createCombinedFilter(filterOptions, timeZoneProcessor);\n\n      if (this._filterMaker.isRegistered()) {\n        var trimmedDates = this._trimDates(filterOptions.min, filterOptions.max);\n\n        this._filterMaker.make(\"date\", [trimmedDates.min, trimmedDates.max, true]);\n\n        var dateFilter = this.customizeDateFilter(this._filterMaker.combine(), timeZoneProcessor);\n        combinedFilter.push([dateFilter]);\n      }\n\n      return (0, _query2.default)(this._dataSource.items()).filter(combinedFilter).toArray();\n    }\n  }, {\n    key: \"_trimDates\",\n    value: function value(min, max) {\n      var minCopy = _date2.default.trimTime(new Date(min)),\n          maxCopy = _date2.default.trimTime(new Date(max));\n\n      maxCopy.setDate(maxCopy.getDate() + 1);\n      return {\n        min: minCopy,\n        max: maxCopy\n      };\n    }\n  }, {\n    key: \"hasAllDayAppointments\",\n    value: function value(items, startDayHour, endDayHour) {\n      if (!items) {\n        return false;\n      }\n\n      var that = this;\n      var result = false;\n\n      _iterator2.default.each(items, function (index, item) {\n        if (that.appointmentTakesAllDay(item, startDayHour, endDayHour)) {\n          result = true;\n          return false;\n        }\n      });\n\n      return result;\n    }\n  }, {\n    key: \"appointmentTakesAllDay\",\n    value: function value(appointment, startDayHour, endDayHour) {\n      var dataAccessors = this._dataAccessors,\n          startDate = dataAccessors.getter.startDate(appointment),\n          endDate = dataAccessors.getter.endDate(appointment),\n          allDay = dataAccessors.getter.allDay(appointment);\n      return allDay || this._appointmentHasAllDayDuration(startDate, endDate, startDayHour, endDayHour);\n    }\n  }, {\n    key: \"_appointmentHasAllDayDuration\",\n    value: function value(startDate, endDate, startDayHour, endDayHour) {\n      startDate = new Date(startDate);\n      endDate = new Date(endDate);\n\n      var dayDuration = 24,\n          appointmentDurationInHours = this._getAppointmentDurationInHours(startDate, endDate);\n\n      return appointmentDurationInHours >= dayDuration || this._appointmentHasShortDayDuration(startDate, endDate, startDayHour, endDayHour);\n    }\n  }, {\n    key: \"_appointmentHasShortDayDuration\",\n    value: function value(startDate, endDate, startDayHour, endDayHour) {\n      var appointmentDurationInHours = this._getAppointmentDurationInHours(startDate, endDate),\n          shortDayDurationInHours = endDayHour - startDayHour;\n\n      return appointmentDurationInHours >= shortDayDurationInHours && startDate.getHours() === startDayHour && endDate.getHours() === endDayHour;\n    }\n  }, {\n    key: \"_getAppointmentDurationInHours\",\n    value: function value(startDate, endDate) {\n      return (endDate.getTime() - startDate.getTime()) / toMs(\"hour\");\n    }\n  }, {\n    key: \"appointmentTakesSeveralDays\",\n    value: function value(appointment) {\n      var dataAccessors = this._dataAccessors,\n          startDate = dataAccessors.getter.startDate(appointment),\n          endDate = dataAccessors.getter.endDate(appointment);\n\n      var startDateCopy = _date2.default.trimTime(new Date(startDate)),\n          endDateCopy = _date2.default.trimTime(new Date(endDate));\n\n      return startDateCopy.getTime() !== endDateCopy.getTime();\n    }\n  }, {\n    key: \"customizeDateFilter\",\n    value: function value(dateFilter, timeZoneProcessor) {\n      var _this4 = this;\n\n      var currentFilter = (0, _extend.extend)(true, [], dateFilter);\n      return function (appointment) {\n        var startDate = new Date(_this4._dataAccessors.getter.startDate(appointment)),\n            endDate = new Date(_this4._dataAccessors.getter.endDate(appointment));\n        endDate = _this4.fixWrongEndDate(appointment, startDate, endDate);\n        appointment = (0, _extend.extend)(true, {}, appointment);\n\n        var startDateTimeZone = _this4._dataAccessors.getter.startDateTimeZone(appointment),\n            endDateTimeZone = _this4._dataAccessors.getter.endDateTimeZone(appointment);\n\n        var comparableStartDate = timeZoneProcessor(startDate, startDateTimeZone),\n            comparableEndDate = timeZoneProcessor(endDate, endDateTimeZone);\n\n        _this4._dataAccessors.setter.startDate(appointment, comparableStartDate);\n\n        _this4._dataAccessors.setter.endDate(appointment, comparableEndDate);\n\n        return (0, _query2.default)([appointment]).filter(currentFilter).toArray().length > 0;\n      }.bind(this);\n    }\n  }, {\n    key: \"fixWrongEndDate\",\n    value: function value(appointment, startDate, endDate) {\n      if (this._isEndDateWrong(appointment, startDate, endDate)) {\n        if (this._dataAccessors.getter.allDay(appointment)) {\n          endDate = _date2.default.setToDayEnd(new Date(startDate));\n        } else {\n          endDate = new Date(startDate.getTime() + this._baseAppointmentDuration * toMs(\"minute\"));\n        }\n\n        this._dataAccessors.setter.endDate(appointment, endDate);\n      }\n\n      return endDate;\n    }\n  }, {\n    key: \"_isEndDateWrong\",\n    value: function value(appointment, startDate, endDate) {\n      return !endDate || isNaN(endDate.getTime()) || startDate.getTime() >= endDate.getTime();\n    }\n  }, {\n    key: \"add\",\n    value: function value(data, tz) {\n      var _this5 = this;\n\n      return this._dataSource.store().insert(data).done(function () {\n        _this5._dataSource.load();\n      }.bind(this));\n    }\n  }, {\n    key: \"update\",\n    value: function value(target, data) {\n      var _this6 = this;\n\n      var key = this._getStoreKey(target);\n\n      return this._dataSource.store().update(key, data).done(function () {\n        _this6._dataSource.load();\n      }.bind(this));\n    }\n  }, {\n    key: \"remove\",\n    value: function value(target) {\n      var _this7 = this;\n\n      var key = this._getStoreKey(target);\n\n      return this._dataSource.store().remove(key).done(function () {\n        _this7._dataSource.load();\n      }.bind(this));\n    }\n  }]);\n\n  return AppointmentModel;\n}();\n\nmodule.exports = AppointmentModel;","map":null,"metadata":{},"sourceType":"script"}