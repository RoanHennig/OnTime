{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/workspaces/ui.scheduler.timeline.js)\r\n * Version: 19.1.6 (build 19263-1729)\r\n * Build date: Fri Sep 20 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../../../core/renderer\"),\n    noop = require(\"../../../core/utils/common\").noop,\n    extend = require(\"../../../core/utils/extend\").extend,\n    registerComponent = require(\"../../../core/component_registrator\"),\n    SchedulerWorkSpace = require(\"./ui.scheduler.work_space.indicator\"),\n    dateUtils = require(\"../../../core/utils/date\"),\n    tableCreator = require(\"../ui.scheduler.table_creator\"),\n    HorizontalShader = require(\"../shaders/ui.scheduler.current_time_shader.horizontal\");\n\nvar TIMELINE_CLASS = \"dx-scheduler-timeline\",\n    GROUP_TABLE_CLASS = \"dx-scheduler-group-table\",\n    HORIZONTAL_GROUPED_WORKSPACE_CLASS = \"dx-scheduler-work-space-horizontal-grouped\",\n    HEADER_PANEL_CELL_CLASS = \"dx-scheduler-header-panel-cell\",\n    HEADER_PANEL_WEEK_CELL_CLASS = \"dx-scheduler-header-panel-week-cell\",\n    HEADER_ROW_CLASS = \"dx-scheduler-header-row\";\nvar HORIZONTAL = \"horizontal\",\n    DATE_TABLE_CELL_BORDER = 1,\n    DATE_TABLE_HEADER_MARGIN = 10,\n    toMs = dateUtils.dateToMilliseconds;\nvar SchedulerTimeline = SchedulerWorkSpace.inherit({\n  _init: function _init() {\n    this.callBase();\n    this.$element().addClass(TIMELINE_CLASS);\n    this._$sidebarTable = $(\"<table>\").addClass(GROUP_TABLE_CLASS);\n  },\n  _getCellFromNextRow: function _getCellFromNextRow(direction, isMultiSelection) {\n    if (!isMultiSelection) {\n      return this.callBase(direction, isMultiSelection);\n    }\n\n    return this._$focusedCell;\n  },\n  _getDefaultGroupStrategy: function _getDefaultGroupStrategy() {\n    return \"vertical\";\n  },\n  _toggleGroupingDirectionClass: function _toggleGroupingDirectionClass() {\n    this.$element().toggleClass(HORIZONTAL_GROUPED_WORKSPACE_CLASS, this._isHorizontalGroupedWorkSpace());\n  },\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      groupOrientation: \"vertical\"\n    });\n  },\n  _getRightCell: function _getRightCell() {\n    var $rightCell,\n        $focusedCell = this._$focusedCell,\n        rowCellCount = this._getCellCount(),\n        edgeCellIndex = this._isRTL() ? 0 : rowCellCount - 1,\n        direction = this._isRTL() ? \"prev\" : \"next\";\n\n    if ($focusedCell.index() === edgeCellIndex) {\n      $rightCell = $focusedCell;\n    } else {\n      $rightCell = $focusedCell[direction]();\n      $rightCell = this._checkForViewBounds($rightCell);\n    }\n\n    return $rightCell;\n  },\n  _getLeftCell: function _getLeftCell() {\n    var $leftCell,\n        $focusedCell = this._$focusedCell,\n        rowCellCount = this._getCellCount(),\n        edgeCellIndex = this._isRTL() ? rowCellCount - 1 : 0,\n        direction = this._isRTL() ? \"next\" : \"prev\";\n\n    if ($focusedCell.index() === edgeCellIndex) {\n      $leftCell = $focusedCell;\n    } else {\n      $leftCell = $focusedCell[direction]();\n      $leftCell = this._checkForViewBounds($leftCell);\n    }\n\n    return $leftCell;\n  },\n  _getRowCount: function _getRowCount() {\n    return 1;\n  },\n  _getCellCount: function _getCellCount() {\n    return this._getCellCountInDay() * this.option(\"intervalCount\");\n  },\n  getGroupTableWidth: function getGroupTableWidth() {\n    return this._$sidebarTable ? this._$sidebarTable.outerWidth() : 0;\n  },\n  _getTotalRowCount: function _getTotalRowCount(groupCount) {\n    if (this._isHorizontalGroupedWorkSpace()) {\n      return this._getRowCount();\n    } else {\n      groupCount = groupCount || 1;\n      return this._getRowCount() * groupCount;\n    }\n  },\n  _getDateByIndex: function _getDateByIndex(index) {\n    var resultDate = new Date(this._firstViewDate),\n        dayIndex = Math.floor(index / this._getCellCountInDay());\n    resultDate.setTime(this._firstViewDate.getTime() + this._calculateCellIndex(0, index) * this._getInterval() + dayIndex * this._getHiddenInterval());\n    return resultDate;\n  },\n  _getFormat: function _getFormat() {\n    return \"shorttime\";\n  },\n  _needApplyLastGroupCellClass: function _needApplyLastGroupCellClass() {\n    return true;\n  },\n  _calculateHiddenInterval: function _calculateHiddenInterval(rowIndex, cellIndex) {\n    var dayIndex = Math.floor(cellIndex / this._getCellCountInDay());\n    return dayIndex * this._getHiddenInterval();\n  },\n  _getMillisecondsOffset: function _getMillisecondsOffset(rowIndex, cellIndex) {\n    cellIndex = this._calculateCellIndex(rowIndex, cellIndex);\n    return this._getInterval() * cellIndex + this._calculateHiddenInterval(rowIndex, cellIndex);\n  },\n  _createWorkSpaceElements: function _createWorkSpaceElements() {\n    this._createWorkSpaceScrollableElements();\n  },\n  _getWorkSpaceHeight: function _getWorkSpaceHeight() {\n    if (this.option(\"crossScrollingEnabled\")) {\n      return this._$dateTable.get(0).getBoundingClientRect().height;\n    }\n\n    return this.$element().get(0).getBoundingClientRect().height;\n  },\n  _dateTableScrollableConfig: function _dateTableScrollableConfig() {\n    var headerScrollableOnScroll;\n    var config = this.callBase(),\n        timelineConfig = {\n      direction: HORIZONTAL,\n      onStart: function () {\n        if (this._headerScrollable) {\n          headerScrollableOnScroll = this._headerScrollable.option(\"onScroll\");\n\n          this._headerScrollable.option(\"onScroll\", void 0);\n        }\n      }.bind(this),\n      onScroll: function (e) {\n        this._headerScrollable && this._headerScrollable.scrollTo({\n          left: e.scrollOffset.left\n        });\n      }.bind(this),\n      onEnd: function (e) {\n        this._headerScrollable && this._headerScrollable.option(\"onScroll\", headerScrollableOnScroll);\n      }.bind(this)\n    };\n    return this.option(\"crossScrollingEnabled\") ? config : extend(config, timelineConfig);\n  },\n  _headerScrollableConfig: function _headerScrollableConfig() {\n    var config = this.callBase();\n    return extend(config, {\n      scrollByContent: true\n    });\n  },\n  _renderTimePanel: noop,\n  _renderAllDayPanel: noop,\n  _getTableAllDay: function _getTableAllDay() {\n    return false;\n  },\n  _getDateHeaderTemplate: function _getDateHeaderTemplate() {\n    return this.option(\"timeCellTemplate\");\n  },\n  _toggleAllDayVisibility: noop,\n  _changeAllDayVisibility: noop,\n  supportAllDayRow: function supportAllDayRow() {\n    return false;\n  },\n  _getGroupHeaderContainer: function _getGroupHeaderContainer() {\n    if (this._isHorizontalGroupedWorkSpace()) {\n      return this._$thead;\n    }\n\n    return this._$sidebarTable;\n  },\n  _insertAllDayRowsIntoDateTable: function _insertAllDayRowsIntoDateTable() {\n    return false;\n  },\n  _createAllDayPanelElements: noop,\n  _renderDateHeader: function _renderDateHeader() {\n    var $headerRow = this.callBase();\n\n    if (this._needRenderWeekHeader()) {\n      var firstViewDate = new Date(this._firstViewDate),\n          $cells = [],\n          colspan = this._getCellCountInDay(),\n          cellTemplate = this.option(\"dateCellTemplate\");\n\n      for (var i = 0; i < this._getWeekDuration() * this.option(\"intervalCount\"); i++) {\n        var $th = $(\"<th>\"),\n            text = this._formatWeekdayAndDay(firstViewDate);\n\n        if (cellTemplate) {\n          var templateOptions = {\n            model: {\n              text: text,\n              date: new Date(firstViewDate)\n            },\n            container: $th,\n            index: i\n          };\n          cellTemplate.render(templateOptions);\n        } else {\n          $th.text(text);\n        }\n\n        $th.addClass(HEADER_PANEL_CELL_CLASS).addClass(HEADER_PANEL_WEEK_CELL_CLASS).attr(\"colSpan\", colspan);\n        $cells.push($th);\n\n        this._incrementDate(firstViewDate);\n      }\n\n      var $row = $(\"<tr>\").addClass(HEADER_ROW_CLASS).append($cells);\n      $headerRow.before($row);\n    }\n  },\n  _needRenderWeekHeader: function _needRenderWeekHeader() {\n    return false;\n  },\n  _incrementDate: function _incrementDate(date) {\n    date.setDate(date.getDate() + 1);\n  },\n  _getWeekDuration: function _getWeekDuration() {\n    return 1;\n  },\n  _renderView: function _renderView() {\n    this._setFirstViewDate();\n\n    var groupCellTemplates = this._renderGroupHeader();\n\n    this._renderDateHeader();\n\n    this._renderAllDayPanel();\n\n    this._renderTimePanel();\n\n    this._renderDateTable();\n\n    this._shader = new HorizontalShader();\n\n    this._updateGroupTableHeight();\n\n    this._$sidebarTable.appendTo(this._sidebarScrollable.$content());\n\n    this._applyCellTemplates(groupCellTemplates);\n  },\n  _setHorizontalGroupHeaderCellsHeight: noop,\n  getIndicationWidth: function getIndicationWidth() {\n    var today = this._getToday(),\n        cellWidth = this.getCellWidth(),\n        date = this._getIndicationFirstViewDate(),\n        hiddenInterval = this._getHiddenInterval(),\n        timeDiff = today.getTime() - date.getTime();\n\n    var differenceInDays = Math.ceil(timeDiff / toMs(\"day\")) - 1,\n        duration = timeDiff - differenceInDays * hiddenInterval,\n        cellCount = duration / this.getCellDuration();\n    return cellCount * cellWidth;\n  },\n  _renderIndicator: function _renderIndicator(height, rtlOffset, $container, groupCount) {\n    var $indicator,\n        width = this.getIndicationWidth();\n\n    if (\"vertical\" === this.option(\"groupOrientation\")) {\n      $indicator = this._createIndicator($container);\n      $indicator.height($container.get(0).getBoundingClientRect().height);\n      $indicator.css(\"left\", rtlOffset ? rtlOffset - width : width);\n    } else {\n      for (var i = 0; i < groupCount; i++) {\n        var offset = this._getCellCount() * this.getCellWidth() * i;\n        $indicator = this._createIndicator($container);\n        $indicator.height($container.get(0).getBoundingClientRect().height);\n        $indicator.css(\"left\", rtlOffset ? rtlOffset - width - offset : width + offset);\n      }\n    }\n  },\n  _isVerticalShader: function _isVerticalShader() {\n    return false;\n  },\n  _isCurrentTimeHeaderCell: function _isCurrentTimeHeaderCell(headerIndex) {\n    var result = false;\n\n    if (this.option(\"showCurrentTimeIndicator\") && this._needRenderDateTimeIndicator()) {\n      var date = this._getDateByIndex(headerIndex);\n\n      var now = this._getToday();\n\n      date = new Date(date);\n\n      if (dateUtils.sameDate(now, date)) {\n        var startCellDate = new Date(date),\n            endCellDate = new Date(date);\n        endCellDate = endCellDate.setMilliseconds(date.getMilliseconds() + this.getCellDuration());\n        result = dateUtils.dateInRange(now, startCellDate, endCellDate);\n      }\n    }\n\n    return result;\n  },\n  _cleanView: function _cleanView() {\n    this.callBase();\n\n    this._$sidebarTable.empty();\n  },\n  _visibilityChanged: function _visibilityChanged(visible) {\n    this.callBase(visible);\n  },\n  _setTableSizes: function _setTableSizes() {\n    var cellHeight = this.getCellHeight(),\n        minHeight = this._getWorkSpaceMinHeight(),\n        $groupCells = this._$sidebarTable.find(\"tr\");\n\n    var height = cellHeight * $groupCells.length;\n\n    if (height < minHeight) {\n      height = minHeight;\n    }\n\n    this._$sidebarTable.height(height);\n\n    this._$dateTable.height(height);\n\n    this.callBase();\n  },\n  _getWorkSpaceMinHeight: function _getWorkSpaceMinHeight() {\n    var minHeight = this._getWorkSpaceHeight(),\n        workspaceContainerHeight = this.$element().outerHeight(true) - this.getHeaderPanelHeight() - 2 * DATE_TABLE_CELL_BORDER - DATE_TABLE_HEADER_MARGIN;\n\n    if (minHeight < workspaceContainerHeight) {\n      minHeight = workspaceContainerHeight;\n    }\n\n    return minHeight;\n  },\n  _makeGroupRows: function _makeGroupRows(groups, groupByDate) {\n    var tableCreatorStrategy = \"vertical\" === this.option(\"groupOrientation\") ? tableCreator.VERTICAL : tableCreator.HORIZONTAL;\n    return tableCreator.makeGroupedTable(tableCreatorStrategy, groups, {\n      groupRowClass: this._getGroupRowClass(),\n      groupHeaderRowClass: this._getGroupRowClass(),\n      groupHeaderClass: this._getGroupHeaderClass.bind(this),\n      groupHeaderContentClass: this._getGroupHeaderContentClass()\n    }, this._getCellCount() || 1, this.option(\"resourceCellTemplate\"), this._getTotalRowCount(this._getGroupCount()), groupByDate);\n  },\n  _ensureGroupHeaderCellsHeight: function _ensureGroupHeaderCellsHeight(cellHeight) {\n    var minCellHeight = this._calculateMinCellHeight();\n\n    if (cellHeight < minCellHeight) {\n      return minCellHeight;\n    }\n\n    return cellHeight;\n  },\n  _calculateMinCellHeight: function _calculateMinCellHeight() {\n    var dateTable = this._getDateTable(),\n        dateTableRowSelector = \".\" + this._getDateTableRowClass();\n\n    return dateTable.get(0).getBoundingClientRect().height / dateTable.find(dateTableRowSelector).length - 2 * DATE_TABLE_CELL_BORDER;\n  },\n  _getCellCoordinatesByIndex: function _getCellCoordinatesByIndex(index) {\n    return {\n      cellIndex: index % this._getCellCount(),\n      rowIndex: 0\n    };\n  },\n  _getCellByCoordinates: function _getCellByCoordinates(cellCoordinates, groupIndex) {\n    var indexes = this._groupedStrategy.prepareCellIndexes(cellCoordinates, groupIndex);\n\n    return this._$dateTable.find(\"tr\").eq(indexes.rowIndex).find(\"td\").eq(indexes.cellIndex);\n  },\n  _getWorkSpaceWidth: function _getWorkSpaceWidth() {\n    return this._$dateTable.outerWidth(true);\n  },\n  _getGroupIndexByCell: function _getGroupIndexByCell($cell) {\n    return $cell.parent().index();\n  },\n  _getIndicationFirstViewDate: function _getIndicationFirstViewDate() {\n    return new Date(this._firstViewDate);\n  },\n  _getIntervalBetween: function _getIntervalBetween(currentDate, allDay) {\n    var startDayHour = this.option(\"startDayHour\"),\n        endDayHour = this.option(\"endDayHour\"),\n        firstViewDate = this.getStartViewDate(),\n        firstViewDateTime = firstViewDate.getTime(),\n        hiddenInterval = (24 - endDayHour + startDayHour) * toMs(\"hour\"),\n        timeZoneOffset = dateUtils.getTimezonesDifference(firstViewDate, currentDate),\n        apptStart = currentDate.getTime(),\n        fullInterval = apptStart - firstViewDateTime - timeZoneOffset,\n        fullDays = Math.floor(fullInterval / toMs(\"day\")),\n        tailDuration = fullInterval - fullDays * toMs(\"day\"),\n        tailDelta = 0,\n        cellCount = this._getCellCountInDay() * (fullDays - this._getWeekendsCount(fullDays)),\n        gapBeforeAppt = apptStart - dateUtils.trimTime(new Date(currentDate)).getTime(),\n        result = cellCount * this.option(\"hoursInterval\") * toMs(\"hour\");\n\n    if (!allDay) {\n      if (currentDate.getHours() < startDayHour) {\n        tailDelta = tailDuration - hiddenInterval + gapBeforeAppt;\n      } else {\n        if (currentDate.getHours() >= startDayHour && currentDate.getHours() < endDayHour) {\n          tailDelta = tailDuration;\n        } else {\n          if (currentDate.getHours() >= startDayHour && currentDate.getHours() >= endDayHour) {\n            tailDelta = tailDuration - (gapBeforeAppt - endDayHour * toMs(\"hour\"));\n          } else {\n            if (!fullDays) {\n              result = fullInterval;\n            }\n          }\n        }\n      }\n\n      result += tailDelta;\n    }\n\n    return result;\n  },\n  _getWeekendsCount: function _getWeekendsCount() {\n    return 0;\n  },\n  getAllDayContainer: function getAllDayContainer() {\n    return null;\n  },\n  getTimePanelWidth: function getTimePanelWidth() {\n    return 0;\n  },\n  getPositionShift: function getPositionShift(timeShift) {\n    var positionShift = this.callBase(timeShift),\n        left = this.getCellWidth() * timeShift;\n\n    if (this.option(\"rtlEnabled\")) {\n      left *= -1;\n    }\n\n    left += positionShift.left;\n    return {\n      top: 0,\n      left: left,\n      cellPosition: left\n    };\n  },\n  getVisibleBounds: function getVisibleBounds() {\n    var isRtl = this.option(\"rtlEnabled\");\n\n    var result = {},\n        $scrollable = this.getScrollable().$element(),\n        cellWidth = this.getCellWidth(),\n        scrollableOffset = isRtl ? this.getScrollableOuterWidth() - this.getScrollableScrollLeft() : this.getScrollableScrollLeft(),\n        scrolledCellCount = scrollableOffset / cellWidth,\n        visibleCellCount = $scrollable.width() / cellWidth,\n        totalCellCount = isRtl ? scrolledCellCount - visibleCellCount : scrolledCellCount + visibleCellCount,\n        leftDate = this._getDateByIndex(scrolledCellCount),\n        rightDate = this._getDateByIndex(totalCellCount);\n\n    if (isRtl) {\n      leftDate = this._getDateByIndex(totalCellCount);\n      rightDate = this._getDateByIndex(scrolledCellCount);\n    }\n\n    result.left = {\n      hours: leftDate.getHours(),\n      minutes: leftDate.getMinutes() >= 30 ? 30 : 0,\n      date: dateUtils.trimTime(leftDate)\n    };\n    result.right = {\n      hours: rightDate.getHours(),\n      minutes: rightDate.getMinutes() >= 30 ? 30 : 0,\n      date: dateUtils.trimTime(rightDate)\n    };\n    return result;\n  },\n  needUpdateScrollPosition: function needUpdateScrollPosition(hours, minutes, bounds, date) {\n    var isUpdateNeeded = false;\n    isUpdateNeeded = this._dateWithinBounds(bounds, date);\n\n    if (hours < bounds.left.hours || hours > bounds.right.hours) {\n      isUpdateNeeded = true;\n    }\n\n    if (hours === bounds.left.hours && minutes < bounds.left.minutes) {\n      isUpdateNeeded = true;\n    }\n\n    if (hours === bounds.right.hours && minutes > bounds.right.minutes) {\n      isUpdateNeeded = true;\n    }\n\n    return isUpdateNeeded;\n  },\n  getIntervalDuration: function getIntervalDuration(allDay) {\n    return this.getCellDuration();\n  },\n  _dateWithinBounds: function _dateWithinBounds(bounds, date) {\n    var trimmedDate = dateUtils.trimTime(new Date(date)),\n        isUpdateNeeded = false;\n\n    if (trimmedDate < bounds.left.date || trimmedDate > bounds.right.date) {\n      isUpdateNeeded = true;\n    }\n\n    return isUpdateNeeded;\n  },\n  _supportCompactDropDownAppointments: function _supportCompactDropDownAppointments() {\n    return false;\n  },\n  getCellMinWidth: function getCellMinWidth() {\n    return 0;\n  },\n  getWorkSpaceLeftOffset: function getWorkSpaceLeftOffset() {\n    return 0;\n  },\n  scrollToTime: function scrollToTime(hours, minutes, date) {\n    var coordinates = this._getScrollCoordinates(hours, minutes, date),\n        scrollable = this.getScrollable(),\n        offset = this.option(\"rtlEnabled\") ? this.getScrollableContainer().get(0).getBoundingClientRect().width : 0;\n\n    if (this.option(\"templatesRenderAsynchronously\")) {\n      setTimeout(function () {\n        scrollable.scrollBy({\n          left: coordinates.left - scrollable.scrollLeft() - offset,\n          top: 0\n        });\n      });\n    } else {\n      scrollable.scrollBy({\n        left: coordinates.left - scrollable.scrollLeft() - offset,\n        top: 0\n      });\n    }\n  }\n});\nregisterComponent(\"dxSchedulerTimeline\", SchedulerTimeline);\nmodule.exports = SchedulerTimeline;","map":null,"metadata":{},"sourceType":"script"}