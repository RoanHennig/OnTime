{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/ui.scheduler.appointments.js)\r\n * Version: 19.1.6 (build 19263-1729)\r\n * Build date: Fri Sep 20 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _dom_adapter = require(\"../../core/dom_adapter\");\n\nvar _dom_adapter2 = _interopRequireDefault(_dom_adapter);\n\nvar _events_engine = require(\"../../events/core/events_engine\");\n\nvar _events_engine2 = _interopRequireDefault(_events_engine);\n\nvar _element_data = require(\"../../core/element_data\");\n\nvar _element_data2 = _interopRequireDefault(_element_data);\n\nvar _translator = require(\"../../animation/translator\");\n\nvar _translator2 = _interopRequireDefault(_translator);\n\nvar _date = require(\"../../core/utils/date\");\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _common2 = _interopRequireDefault(_common);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _object = require(\"../../core/utils/object\");\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _array = require(\"../../core/utils/array\");\n\nvar _array2 = _interopRequireDefault(_array);\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _dom = require(\"../../core/utils/dom\");\n\nvar _utils = require(\"./utils.recurrence\");\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _component_registrator = require(\"../../core/component_registrator\");\n\nvar _component_registrator2 = _interopRequireDefault(_component_registrator);\n\nvar _uiScheduler = require(\"./ui.scheduler.publisher_mixin\");\n\nvar _uiScheduler2 = _interopRequireDefault(_uiScheduler);\n\nvar _uiScheduler3 = require(\"./ui.scheduler.appointment\");\n\nvar _uiScheduler4 = _interopRequireDefault(_uiScheduler3);\n\nvar _utils3 = require(\"../../events/utils\");\n\nvar _utils4 = _interopRequireDefault(_utils3);\n\nvar _double_click = require(\"../../events/double_click\");\n\nvar _double_click2 = _interopRequireDefault(_double_click);\n\nvar _date3 = require(\"../../localization/date\");\n\nvar _date4 = _interopRequireDefault(_date3);\n\nvar _message = require(\"../../localization/message\");\n\nvar _message2 = _interopRequireDefault(_message);\n\nvar _uiCollection_widget = require(\"../collection/ui.collection_widget.edit\");\n\nvar _uiCollection_widget2 = _interopRequireDefault(_uiCollection_widget);\n\nvar _draggable = require(\"../draggable\");\n\nvar _draggable2 = _interopRequireDefault(_draggable);\n\nvar _deferred = require(\"../../core/utils/deferred\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar APPOINTMENT_SETTINGS_NAME = \"dxAppointmentSettings\";\n\nvar COMPONENT_CLASS = \"dx-scheduler-scrollable-appointments\",\n    APPOINTMENT_ITEM_CLASS = \"dx-scheduler-appointment\",\n    APPOINTMENT_TITLE_CLASS = \"dx-scheduler-appointment-title\",\n    APPOINTMENT_CONTENT_DETAILS_CLASS = \"dx-scheduler-appointment-content-details\",\n    APPOINTMENT_DATE_CLASS = \"dx-scheduler-appointment-content-date\",\n    RECURRING_ICON_CLASS = \"dx-scheduler-appointment-recurrence-icon\",\n    ALL_DAY_CONTENT_CLASS = \"dx-scheduler-appointment-content-allday\",\n    DBLCLICK_EVENT_NAME = _utils4.default.addNamespace(_double_click2.default.name, \"dxSchedulerAppointment\");\n\nvar toMs = _date2.default.dateToMilliseconds;\n\nvar SchedulerAppointments = _uiCollection_widget2.default.inherit({\n  _supportedKeys: function _supportedKeys() {\n    var parent = this.callBase();\n\n    var tabHandler = function tabHandler(e) {\n      var appointments = this._getAccessAppointments(),\n          focusedAppointment = appointments.filter(\".dx-state-focused\"),\n          index = focusedAppointment.data(\"dxAppointmentSettings\").sortedIndex,\n          lastIndex = appointments.length - 1;\n\n      if (index > 0 && e.shiftKey || index < lastIndex && !e.shiftKey) {\n        e.preventDefault();\n        e.shiftKey ? index-- : index++;\n\n        var $nextAppointment = this._getAppointmentByIndex(index);\n\n        this._resetTabIndex($nextAppointment);\n\n        _events_engine2.default.trigger($nextAppointment, \"focus\");\n      }\n    };\n\n    return (0, _extend.extend)(parent, {\n      escape: function () {\n        this.moveAppointmentBack();\n        this._escPressed = true;\n      }.bind(this),\n      del: function (e) {\n        if (this.option(\"allowDelete\")) {\n          e.preventDefault();\n\n          var data = this._getItemData(e.target);\n\n          this.notifyObserver(\"deleteAppointment\", {\n            data: data,\n            target: e.target\n          });\n          this.notifyObserver(\"hideAppointmentTooltip\");\n        }\n      }.bind(this),\n      tab: tabHandler\n    });\n  },\n  _getAppointmentByIndex: function _getAppointmentByIndex(sortedIndex) {\n    var appointments = this._getAccessAppointments();\n\n    return appointments.filter(function (_, $item) {\n      return _element_data2.default.data($item, \"dxAppointmentSettings\").sortedIndex === sortedIndex;\n    }).eq(0);\n  },\n  _getAccessAppointments: function _getAccessAppointments() {\n    return this._itemElements().filter(\":visible\").not(\".dx-state-disabled\");\n  },\n  _resetTabIndex: function _resetTabIndex($appointment) {\n    this._focusTarget().attr(\"tabIndex\", -1);\n\n    $appointment.attr(\"tabIndex\", this.option(\"tabIndex\"));\n  },\n  _moveFocus: _common2.default.noop,\n  _focusTarget: function _focusTarget() {\n    return this._itemElements();\n  },\n  _renderFocusTarget: function _renderFocusTarget() {\n    var $appointment = this._getAppointmentByIndex(0);\n\n    this._resetTabIndex($appointment);\n  },\n  _focusInHandler: function _focusInHandler(e) {\n    if (this._targetIsDisabled(e)) {\n      e.stopPropagation();\n      return;\n    }\n\n    clearTimeout(this._appointmentFocusedTimeout);\n    this.callBase.apply(this, arguments);\n    this._$currentAppointment = (0, _renderer2.default)(e.target);\n    this.option(\"focusedElement\", (0, _dom.getPublicElement)((0, _renderer2.default)(e.target)));\n    var that = this;\n    this._appointmentFocusedTimeout = setTimeout(function () {\n      that.notifyObserver(\"appointmentFocused\");\n    });\n  },\n  _targetIsDisabled: function _targetIsDisabled(e) {\n    return (0, _renderer2.default)(e.currentTarget).is(\".dx-state-disabled, .dx-state-disabled *\");\n  },\n  _focusOutHandler: function _focusOutHandler() {\n    var $appointment = this._getAppointmentByIndex(0);\n\n    this.option(\"focusedElement\", (0, _dom.getPublicElement)($appointment));\n    this.callBase.apply(this, arguments);\n  },\n  _eventBindingTarget: function _eventBindingTarget() {\n    return this._itemContainer();\n  },\n  _getDefaultOptions: function _getDefaultOptions() {\n    return (0, _extend.extend)(this.callBase(), {\n      noDataText: null,\n      activeStateEnabled: true,\n      hoverStateEnabled: true,\n      tabIndex: 0,\n      fixedContainer: null,\n      allDayContainer: null,\n      allowDrag: true,\n      allowResize: true,\n      allowAllDayResize: true,\n      onAppointmentDblClick: null,\n      _collectorOffset: 0\n    });\n  },\n  _optionChanged: function _optionChanged(args) {\n    switch (args.name) {\n      case \"items\":\n        this._cleanFocusState();\n\n        this._clearDropDownItems();\n\n        this._clearDropDownItemsElements();\n\n        this._repaintAppointments(args.value);\n\n        this._renderDropDownAppointments();\n\n        this._attachAppointmentsEvents();\n\n        break;\n\n      case \"fixedContainer\":\n      case \"allDayContainer\":\n      case \"onAppointmentDblClick\":\n        break;\n\n      case \"allowDrag\":\n      case \"allowResize\":\n      case \"allowAllDayResize\":\n        this._invalidate();\n\n        break;\n\n      case \"focusedElement\":\n        this._resetTabIndex((0, _renderer2.default)(args.value));\n\n        this.callBase(args);\n        break;\n\n      case \"allowDelete\":\n        break;\n\n      case \"focusStateEnabled\":\n        this._clearDropDownItemsElements();\n\n        this._renderDropDownAppointments();\n\n        this.callBase(args);\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  _isAllDayAppointment: function _isAllDayAppointment(appointment) {\n    return appointment.settings.length && appointment.settings[0].allDay || false;\n  },\n  _isRepaintAppointment: function _isRepaintAppointment(appointment) {\n    return !_type2.default.isDefined(appointment.needRepaint) || true === appointment.needRepaint;\n  },\n  _isRepaintAll: function _isRepaintAll(appointments) {\n    if (this.invoke(\"isCurrentViewAgenda\")) {\n      return true;\n    }\n\n    for (var i = 0; i < appointments.length; i++) {\n      var appointment = appointments[i];\n\n      if (!this._isRepaintAppointment(appointment)) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  _applyFragment: function _applyFragment(fragment, allDay) {\n    if (fragment.children().length > 0) {\n      this._getAppointmentContainer(allDay).append(fragment);\n    }\n  },\n  _onEachAppointment: function _onEachAppointment(appointment, index, container, isRepaintAll) {\n    if (appointment && true === appointment.needRemove) {\n      this._clearItem(appointment);\n\n      return;\n    }\n\n    if (this._isRepaintAppointment(appointment)) {\n      appointment.needRepaint = false;\n      !isRepaintAll && this._clearItem(appointment);\n\n      this._renderItem(index, appointment, container);\n    }\n  },\n  _repaintAppointments: function _repaintAppointments(appointments) {\n    var _this = this;\n\n    var isRepaintAll = this._isRepaintAll(appointments);\n\n    var allDayFragment = (0, _renderer2.default)(this._getAppointmentContainer(true));\n    var commonFragment = (0, _renderer2.default)(this._getAppointmentContainer(false));\n\n    if (isRepaintAll) {\n      this._getAppointmentContainer(true).html(\"\");\n\n      this._getAppointmentContainer(false).html(\"\");\n    }\n\n    !appointments.length && this._cleanItemContainer();\n    appointments.forEach(function (appointment, index) {\n      var container = _this._isAllDayAppointment(appointment) ? allDayFragment : commonFragment;\n\n      _this._onEachAppointment(appointment, index, container, isRepaintAll);\n    });\n\n    this._applyFragment(allDayFragment, true);\n\n    this._applyFragment(commonFragment, false);\n  },\n  _attachAppointmentsEvents: function _attachAppointmentsEvents() {\n    this._attachClickEvent();\n\n    this._attachHoldEvent();\n\n    this._attachContextMenuEvent();\n\n    this._attachAppointmentDblClick();\n\n    this._renderFocusState();\n\n    this._attachFeedbackEvents();\n\n    this._attachHoverEvents();\n  },\n  _clearItem: function _clearItem(item) {\n    var $items = this._findItemElementByItem(item.itemData);\n\n    if (!$items.length) {\n      return;\n    }\n\n    (0, _iterator.each)($items, function (_, $item) {\n      $item.detach();\n      $item.remove();\n    });\n  },\n  _clearDropDownItems: function _clearDropDownItems() {\n    this._virtualAppointments = {};\n  },\n  _clearDropDownItemsElements: function _clearDropDownItemsElements() {\n    this.invoke(\"clearCompactAppointments\");\n  },\n  _findItemElementByItem: function _findItemElementByItem(item) {\n    var result = [],\n        that = this;\n    this.itemElements().each(function () {\n      var $item = (0, _renderer2.default)(this);\n\n      if ($item.data(that._itemDataKey()) === item) {\n        result.push($item);\n      }\n    });\n    return result;\n  },\n  _itemClass: function _itemClass() {\n    return APPOINTMENT_ITEM_CLASS;\n  },\n  _itemContainer: function _itemContainer() {\n    var $container = this.callBase(),\n        $result = $container,\n        $allDayContainer = this.option(\"allDayContainer\");\n\n    if ($allDayContainer) {\n      $result = $container.add($allDayContainer);\n    }\n\n    return $result;\n  },\n  _cleanItemContainer: function _cleanItemContainer() {\n    this.callBase();\n    var $allDayContainer = this.option(\"allDayContainer\");\n\n    if ($allDayContainer) {\n      $allDayContainer.empty();\n    }\n\n    this._virtualAppointments = {};\n  },\n  _clean: function _clean() {\n    this.callBase();\n    delete this._$currentAppointment;\n    delete this._initialSize;\n    delete this._initialCoordinates;\n  },\n  _init: function _init() {\n    this.callBase();\n    this.$element().addClass(COMPONENT_CLASS);\n    this._preventSingleAppointmentClick = false;\n  },\n  _renderAppointmentTemplate: function _renderAppointmentTemplate($container, data, model) {\n    var startDate = model.settings ? new Date(this.invoke(\"getField\", \"startDate\", model.settings)) : data.startDate,\n        endDate = model.settings ? new Date(this.invoke(\"getField\", \"endDate\", model.settings)) : data.endDate;\n\n    if (isNaN(startDate) || isNaN(endDate)) {\n      startDate = data.startDate;\n      endDate = data.endDate;\n    }\n\n    (0, _renderer2.default)(\"<div>\").text(this._createAppointmentTitle(data)).addClass(APPOINTMENT_TITLE_CLASS).appendTo($container);\n\n    if (_type2.default.isPlainObject(data)) {\n      if (data.html) {\n        $container.html(data.html);\n      }\n    }\n\n    var recurrenceRule = data.recurrenceRule,\n        allDay = data.allDay,\n        $contentDetails = (0, _renderer2.default)(\"<div>\").addClass(APPOINTMENT_CONTENT_DETAILS_CLASS);\n    var apptStartTz = data.startDateTimeZone,\n        apptEndTz = data.endDateTimeZone;\n    startDate = this.invoke(\"convertDateByTimezone\", startDate, apptStartTz);\n    endDate = this.invoke(\"convertDateByTimezone\", endDate, apptEndTz);\n    (0, _renderer2.default)(\"<div>\").addClass(APPOINTMENT_DATE_CLASS).text(_date4.default.format(startDate, \"shorttime\")).appendTo($contentDetails);\n    (0, _renderer2.default)(\"<div>\").addClass(APPOINTMENT_DATE_CLASS).text(\" - \").appendTo($contentDetails);\n    (0, _renderer2.default)(\"<div>\").addClass(APPOINTMENT_DATE_CLASS).text(_date4.default.format(endDate, \"shorttime\")).appendTo($contentDetails);\n    $contentDetails.appendTo($container);\n\n    if (recurrenceRule) {\n      (0, _renderer2.default)(\"<span>\").addClass(RECURRING_ICON_CLASS + \" dx-icon-repeat\").appendTo($container);\n    }\n\n    if (allDay) {\n      (0, _renderer2.default)(\"<div>\").text(\" \" + _message2.default.format(\"dxScheduler-allDay\") + \": \").addClass(ALL_DAY_CONTENT_CLASS).prependTo($contentDetails);\n    }\n  },\n  _createAppointmentTitle: function _createAppointmentTitle(data) {\n    if (_type2.default.isPlainObject(data)) {\n      return data.text;\n    }\n\n    return String(data);\n  },\n  _executeItemRenderAction: function _executeItemRenderAction(index, itemData, itemElement) {\n    var action = this._getItemRenderAction();\n\n    if (action) {\n      action({\n        appointmentElement: itemElement,\n        appointmentData: itemData,\n        targetedAppointmentData: this.invoke(\"getTargetedAppointmentData\", itemData, itemElement, index)\n      });\n    }\n\n    delete this._currentAppointmentSettings;\n  },\n  _itemClickHandler: function _itemClickHandler(e) {\n    this.callBase(e, {}, {\n      afterExecute: function (e) {\n        this._processItemClick(e.args[0].event);\n      }.bind(this)\n    });\n  },\n  _processItemClick: function _processItemClick(e) {\n    var $target = (0, _renderer2.default)(e.currentTarget),\n        data = this._getItemData($target);\n\n    if (this._targetIsDisabled(e)) {\n      e.stopPropagation();\n      return;\n    }\n\n    if (\"keydown\" === e.type || _utils4.default.isFakeClickEvent(e)) {\n      this.notifyObserver(\"showEditAppointmentPopup\", {\n        data: data,\n        target: $target\n      });\n      return;\n    }\n\n    this._appointmentClickTimeout = setTimeout(function () {\n      if (!this._preventSingleAppointmentClick && _dom_adapter2.default.getBody().contains($target[0])) {\n        this.notifyObserver(\"showAppointmentTooltip\", {\n          data: data,\n          target: $target\n        });\n      }\n\n      this._preventSingleAppointmentClick = false;\n    }.bind(this), 300);\n  },\n  _extendActionArgs: function _extendActionArgs() {\n    var args = this.callBase.apply(this, arguments);\n    return this.invoke(\"mapAppointmentFields\", args);\n  },\n  _render: function _render() {\n    this.callBase.apply(this, arguments);\n\n    this._attachAppointmentDblClick();\n  },\n  _attachAppointmentDblClick: function _attachAppointmentDblClick() {\n    var that = this;\n\n    var itemSelector = that._itemSelector();\n\n    var itemContainer = this._itemContainer();\n\n    _events_engine2.default.off(itemContainer, DBLCLICK_EVENT_NAME, itemSelector);\n\n    _events_engine2.default.on(itemContainer, DBLCLICK_EVENT_NAME, itemSelector, function (e) {\n      that._itemDXEventHandler(e, \"onAppointmentDblClick\", {}, {\n        afterExecute: function afterExecute(e) {\n          that._dblClickHandler(e.args[0].event);\n        }\n      });\n    });\n  },\n  _dblClickHandler: function _dblClickHandler(e) {\n    var $targetAppointment = (0, _renderer2.default)(e.currentTarget),\n        appointmentData = this._getItemData($targetAppointment);\n\n    clearTimeout(this._appointmentClickTimeout);\n    this._preventSingleAppointmentClick = true;\n    this.notifyObserver(\"showEditAppointmentPopup\", {\n      data: appointmentData,\n      target: $targetAppointment\n    });\n  },\n  _renderItem: function _renderItem(index, item, container) {\n    var itemData = item.itemData;\n\n    for (var i = 0; i < item.settings.length; i++) {\n      var setting = item.settings[i];\n      this._currentAppointmentSettings = setting;\n      var $item = this.callBase(index, itemData, container);\n      $item.data(APPOINTMENT_SETTINGS_NAME, setting);\n    }\n  },\n  _getItemContent: function _getItemContent($itemFrame) {\n    $itemFrame.data(APPOINTMENT_SETTINGS_NAME, this._currentAppointmentSettings);\n    var $itemContent = this.callBase($itemFrame);\n    return $itemContent;\n  },\n  _createItemByTemplate: function _createItemByTemplate(itemTemplate, renderArgs) {\n    return itemTemplate.render({\n      model: renderArgs.itemData,\n      container: renderArgs.container,\n      index: renderArgs.index\n    });\n  },\n  _getAppointmentContainer: function _getAppointmentContainer(allDay) {\n    var $allDayContainer = this.option(\"allDayContainer\"),\n        $container = this.itemsContainer().not($allDayContainer);\n\n    if (allDay && $allDayContainer) {\n      $container = $allDayContainer;\n    }\n\n    return $container;\n  },\n  _postprocessRenderItem: function _postprocessRenderItem(args) {\n    this._renderAppointment(args.itemElement, this._currentAppointmentSettings);\n  },\n  _renderAppointment: function _renderAppointment($appointment, settings) {\n    $appointment.data(APPOINTMENT_SETTINGS_NAME, settings);\n\n    this._applyResourceDataAttr($appointment);\n\n    var data = this._getItemData($appointment),\n        geometry = this.invoke(\"getAppointmentGeometry\", settings),\n        allowResize = !settings.isCompact && this.option(\"allowResize\") && (!_type2.default.isDefined(settings.skipResizing) || _type2.default.isString(settings.skipResizing)),\n        allowDrag = this.option(\"allowDrag\"),\n        allDay = settings.allDay;\n\n    this.invoke(\"setCellDataCacheAlias\", this._currentAppointmentSettings, geometry);\n\n    var deferredColor = this._getAppointmentColor($appointment, settings.groupIndex);\n\n    if (settings.virtual) {\n      this._processVirtualAppointment(settings, $appointment, data, deferredColor);\n    } else {\n      this._createComponent($appointment, _uiScheduler4.default, {\n        observer: this.option(\"observer\"),\n        data: data,\n        geometry: geometry,\n        direction: settings.direction || \"vertical\",\n        allowResize: allowResize,\n        allowDrag: allowDrag,\n        allDay: allDay,\n        reduced: settings.appointmentReduced,\n        isCompact: settings.isCompact,\n        startDate: new Date(settings.startDate),\n        cellWidth: this.invoke(\"getCellWidth\"),\n        cellHeight: this.invoke(\"getCellHeight\"),\n        resizableConfig: this._resizableConfig(data, settings)\n      });\n\n      deferredColor.done(function (color) {\n        if (color) {\n          $appointment.css(\"backgroundColor\", color);\n        }\n      });\n\n      this._renderDraggable($appointment, allDay);\n    }\n  },\n  _applyResourceDataAttr: function _applyResourceDataAttr($appointment) {\n    this.notifyObserver(\"getResourcesFromItem\", {\n      itemData: this._getItemData($appointment),\n      callback: function callback(resources) {\n        if (resources) {\n          (0, _iterator.each)(resources, function (name, values) {\n            var attr = \"data-\" + _common2.default.normalizeKey(name.toLowerCase()) + \"-\";\n\n            for (var i = 0; i < values.length; i++) {\n              $appointment.attr(attr + _common2.default.normalizeKey(values[i]), true);\n            }\n          });\n        }\n      }\n    });\n  },\n  _resizableConfig: function _resizableConfig(appointmentData, itemSetting) {\n    return {\n      area: this._calculateResizableArea(itemSetting, appointmentData),\n      onResizeStart: function (e) {\n        this._$currentAppointment = (0, _renderer2.default)(e.element);\n\n        if (this.invoke(\"needRecalculateResizableArea\")) {\n          var updatedArea = this._calculateResizableArea(this._$currentAppointment.data(\"dxAppointmentSettings\"), this._$currentAppointment.data(\"dxItemData\"));\n\n          e.component.option(\"area\", updatedArea);\n\n          e.component._renderDragOffsets(e.event);\n        }\n\n        this._initialSize = {\n          width: e.width,\n          height: e.height\n        };\n        this._initialCoordinates = _translator2.default.locate(this._$currentAppointment);\n      }.bind(this),\n      onResizeEnd: function (e) {\n        if (this._escPressed) {\n          e.event.cancel = true;\n          return;\n        }\n\n        this._resizeEndHandler(e);\n      }.bind(this)\n    };\n  },\n  _calculateResizableArea: function _calculateResizableArea(itemSetting, appointmentData) {\n    var area = this.$element().closest(\".dx-scrollable-content\");\n    this.notifyObserver(\"getResizableAppointmentArea\", {\n      coordinates: {\n        left: itemSetting.left,\n        top: 0,\n        groupIndex: itemSetting.groupIndex\n      },\n      allDay: itemSetting.allDay,\n      callback: function callback(result) {\n        if (result) {\n          area = result;\n        }\n      }\n    });\n    return area;\n  },\n  _resizeEndHandler: function _resizeEndHandler(e) {\n    var $element = (0, _renderer2.default)(e.element),\n        itemData = this._getItemData($element),\n        startDate = this.invoke(\"getStartDate\", itemData, true),\n        endDate = this.invoke(\"getEndDate\", itemData, true);\n\n    var dateRange = this._getDateRange(e, startDate, endDate);\n\n    var updatedDates = {};\n    this.invoke(\"setField\", \"startDate\", updatedDates, new Date(dateRange[0]));\n    this.invoke(\"setField\", \"endDate\", updatedDates, new Date(dateRange[1]));\n    var data = (0, _extend.extend)({}, itemData, updatedDates);\n    this.notifyObserver(\"updateAppointmentAfterResize\", {\n      target: itemData,\n      data: data,\n      $appointment: $element\n    });\n  },\n  _getDateRange: function _getDateRange(e, startDate, endDate) {\n    var startTime,\n        endTime,\n        itemData = this._getItemData(e.element),\n        deltaTime = this.invoke(\"getDeltaTime\", e, this._initialSize, itemData),\n        renderingStrategyDirection = this.invoke(\"getRenderingStrategyDirection\"),\n        cond = false,\n        isAllDay = this.invoke(\"isAllDay\", itemData),\n        needCorrectDates = this.invoke(\"needCorrectAppointmentDates\") && !isAllDay;\n\n    if (\"vertical\" !== renderingStrategyDirection || isAllDay) {\n      cond = this.option(\"rtlEnabled\") ? e.handles.right : e.handles.left;\n    } else {\n      cond = e.handles.top;\n    }\n\n    if (cond) {\n      startTime = needCorrectDates ? this._correctStartDateByDelta(startDate, deltaTime) : startDate.getTime() - deltaTime;\n      endTime = endDate.getTime();\n    } else {\n      startTime = startDate.getTime();\n      endTime = needCorrectDates ? this._correctEndDateByDelta(endDate, deltaTime) : endDate.getTime() + deltaTime;\n    }\n\n    return [startTime, endTime];\n  },\n  _correctEndDateByDelta: function _correctEndDateByDelta(endDate, deltaTime) {\n    var endDayHour = this.invoke(\"getEndDayHour\"),\n        startDayHour = this.invoke(\"getStartDayHour\"),\n        result = endDate.getTime() + deltaTime,\n        visibleDayDuration = (endDayHour - startDayHour) * toMs(\"hour\");\n    var daysCount = deltaTime > 0 ? Math.ceil(deltaTime / visibleDayDuration) : Math.floor(deltaTime / visibleDayDuration),\n        maxDate = new Date(endDate),\n        minDate = new Date(endDate);\n    minDate.setHours(startDayHour, 0, 0, 0);\n    maxDate.setHours(endDayHour, 0, 0, 0);\n\n    if (result > maxDate.getTime() || result <= minDate.getTime()) {\n      var tailOfCurrentDay = maxDate.getTime() - endDate.getTime(),\n          tailOfPrevDays = deltaTime - tailOfCurrentDay;\n      var lastDay = new Date(endDate.setDate(endDate.getDate() + daysCount));\n      lastDay.setHours(startDayHour, 0, 0, 0);\n      result = lastDay.getTime() + tailOfPrevDays - visibleDayDuration * (daysCount - 1);\n    }\n\n    return result;\n  },\n  _correctStartDateByDelta: function _correctStartDateByDelta(startDate, deltaTime) {\n    var endDayHour = this.invoke(\"getEndDayHour\"),\n        startDayHour = this.invoke(\"getStartDayHour\"),\n        result = startDate.getTime() - deltaTime,\n        visibleDayDuration = (endDayHour - startDayHour) * toMs(\"hour\");\n    var daysCount = deltaTime > 0 ? Math.ceil(deltaTime / visibleDayDuration) : Math.floor(deltaTime / visibleDayDuration),\n        maxDate = new Date(startDate),\n        minDate = new Date(startDate);\n    minDate.setHours(startDayHour, 0, 0, 0);\n    maxDate.setHours(endDayHour, 0, 0, 0);\n\n    if (result < minDate.getTime() || result >= maxDate.getTime()) {\n      var tailOfCurrentDay = startDate.getTime() - minDate.getTime(),\n          tailOfPrevDays = deltaTime - tailOfCurrentDay;\n      var firstDay = new Date(startDate.setDate(startDate.getDate() - daysCount));\n      firstDay.setHours(endDayHour, 0, 0, 0);\n      result = firstDay.getTime() - tailOfPrevDays + visibleDayDuration * (daysCount - 1);\n    }\n\n    return result;\n  },\n  _tryGetAppointmentColor: function _tryGetAppointmentColor(appointment) {\n    var settings = (0, _renderer2.default)(appointment).data(APPOINTMENT_SETTINGS_NAME);\n\n    if (!settings) {\n      return;\n    }\n\n    return this._getAppointmentColor(appointment, settings.groupIndex);\n  },\n  _getAppointmentColor: function _getAppointmentColor($appointment, groupIndex) {\n    var res = new _deferred.Deferred();\n    this.notifyObserver(\"getAppointmentColor\", {\n      itemData: this._getItemData($appointment),\n      groupIndex: groupIndex,\n      callback: function callback(d) {\n        return d.done(function (color) {\n          return res.resolve(color);\n        });\n      }\n    });\n    return res.promise();\n  },\n  _renderDraggable: function _renderDraggable($appointment, allDay) {\n    if (!this.option(\"allowDrag\")) {\n      return;\n    }\n\n    var draggableArea,\n        that = this,\n        $fixedContainer = this.option(\"fixedContainer\"),\n        correctCoordinates = function correctCoordinates(element, isFixedContainer) {\n      var coordinates = _translator2.default.locate((0, _renderer2.default)(element));\n\n      that.notifyObserver(\"correctAppointmentCoordinates\", {\n        coordinates: coordinates,\n        allDay: allDay,\n        isFixedContainer: isFixedContainer,\n        callback: function callback(result) {\n          if (result) {\n            coordinates = result;\n          }\n        }\n      });\n\n      _translator2.default.move($appointment, coordinates);\n    };\n\n    this.notifyObserver(\"getDraggableAppointmentArea\", {\n      callback: function callback(result) {\n        if (result) {\n          draggableArea = result;\n        }\n      }\n    });\n\n    this._createComponent($appointment, _draggable2.default, {\n      area: draggableArea,\n      boundOffset: that._calculateBoundOffset(),\n      immediate: false,\n      onDragStart: function onDragStart(args) {\n        var e = args.event;\n\n        that._skipDraggableRestriction(e);\n\n        that.notifyObserver(\"hideAppointmentTooltip\");\n        $fixedContainer.append($appointment);\n        that._$currentAppointment = (0, _renderer2.default)(args.element);\n        that._initialSize = {\n          width: args.width,\n          height: args.height\n        };\n        that._initialCoordinates = _translator2.default.locate(that._$currentAppointment);\n      },\n      onDrag: function onDrag(args) {\n        correctCoordinates(args.element);\n      },\n      onDragEnd: function onDragEnd(args) {\n        correctCoordinates(args.element, true);\n\n        var $container = that._getAppointmentContainer(allDay);\n\n        $container.append($appointment);\n\n        if (this._escPressed) {\n          args.event.cancel = true;\n          return;\n        }\n\n        that._dragEndHandler(args);\n      }\n    });\n  },\n  _calculateBoundOffset: function _calculateBoundOffset() {\n    var result = {\n      top: 0\n    };\n    this.notifyObserver(\"getBoundOffset\", {\n      callback: function callback(offset) {\n        result = offset;\n      }\n    });\n    return result;\n  },\n  _skipDraggableRestriction: function _skipDraggableRestriction(e) {\n    if (this.option(\"rtlEnabled\")) {\n      e.maxLeftOffset = null;\n    } else {\n      e.maxRightOffset = null;\n    }\n\n    e.maxBottomOffset = null;\n  },\n  _dragEndHandler: function _dragEndHandler(e) {\n    var $element = (0, _renderer2.default)(e.element),\n        itemData = this._getItemData($element),\n        coordinates = this._initialCoordinates;\n\n    this.notifyObserver(\"updateAppointmentAfterDrag\", {\n      data: itemData,\n      $appointment: $element,\n      coordinates: coordinates\n    });\n  },\n  _virtualAppointments: {},\n  _processVirtualAppointment: function _processVirtualAppointment(appointmentSetting, $appointment, appointmentData, color) {\n    var virtualAppointment = appointmentSetting.virtual,\n        virtualGroupIndex = virtualAppointment.index;\n\n    if (!_type2.default.isDefined(this._virtualAppointments[virtualGroupIndex])) {\n      this._virtualAppointments[virtualGroupIndex] = {\n        coordinates: {\n          top: virtualAppointment.top,\n          left: virtualAppointment.left\n        },\n        items: {\n          data: [],\n          colors: []\n        },\n        isAllDay: virtualAppointment.isAllDay ? true : false,\n        buttonColor: color\n      };\n    }\n\n    appointmentData.settings = [appointmentSetting];\n\n    this._virtualAppointments[virtualGroupIndex].items.data.push(appointmentData);\n\n    this._virtualAppointments[virtualGroupIndex].items.colors.push(color);\n\n    $appointment.remove();\n  },\n  _renderContentImpl: function _renderContentImpl() {\n    this.callBase();\n\n    this._renderDropDownAppointments();\n  },\n  _renderDropDownAppointments: function _renderDropDownAppointments() {\n    (0, _iterator.each)(this._virtualAppointments, function (groupIndex) {\n      var virtualGroup = this._virtualAppointments[groupIndex],\n          virtualItems = virtualGroup.items,\n          virtualCoordinates = virtualGroup.coordinates,\n          $container = virtualGroup.isAllDay ? this.option(\"allDayContainer\") : this.$element(),\n          left = virtualCoordinates.left;\n      var buttonWidth = this.invoke(\"getDropDownAppointmentWidth\", virtualGroup.isAllDay),\n          buttonHeight = this.invoke(\"getDropDownAppointmentHeight\"),\n          rtlOffset = 0;\n\n      if (this.option(\"rtlEnabled\")) {\n        rtlOffset = buttonWidth;\n      }\n\n      this.notifyObserver(\"renderCompactAppointments\", {\n        $container: $container,\n        coordinates: {\n          top: virtualCoordinates.top,\n          left: left + rtlOffset\n        },\n        items: virtualItems,\n        buttonColor: virtualGroup.buttonColor,\n        itemTemplate: this.option(\"itemTemplate\"),\n        width: buttonWidth - this.option(\"_collectorOffset\"),\n        height: buttonHeight,\n        onAppointmentClick: this.option(\"onItemClick\"),\n        isCompact: this.invoke(\"isAdaptive\") || this._isGroupCompact(virtualGroup),\n        applyOffset: this._isGroupCompact(virtualGroup)\n      });\n    }.bind(this));\n  },\n  _isGroupCompact: function _isGroupCompact(virtualGroup) {\n    return !virtualGroup.isAllDay && this.invoke(\"supportCompactDropDownAppointments\");\n  },\n  _sortAppointmentsByStartDate: function _sortAppointmentsByStartDate(appointments) {\n    appointments.sort(function (a, b) {\n      var result = 0,\n          firstDate = new Date(this.invoke(\"getField\", \"startDate\", a.settings || a)).getTime(),\n          secondDate = new Date(this.invoke(\"getField\", \"startDate\", b.settings || b)).getTime();\n\n      if (firstDate < secondDate) {\n        result = -1;\n      }\n\n      if (firstDate > secondDate) {\n        result = 1;\n      }\n\n      return result;\n    }.bind(this));\n  },\n  _processRecurrenceAppointment: function _processRecurrenceAppointment(appointment, index, skipLongAppointments) {\n    var recurrenceRule = this.invoke(\"getField\", \"recurrenceRule\", appointment),\n        result = {\n      parts: [],\n      indexes: []\n    };\n\n    if (recurrenceRule) {\n      var dates = appointment.settings || appointment;\n\n      var startDate = new Date(this.invoke(\"getField\", \"startDate\", dates)),\n          endDate = new Date(this.invoke(\"getField\", \"endDate\", dates)),\n          appointmentDuration = endDate.getTime() - startDate.getTime(),\n          recurrenceException = this.invoke(\"getField\", \"recurrenceException\", appointment),\n          startViewDate = this.invoke(\"getStartViewDate\"),\n          endViewDate = this.invoke(\"getEndViewDate\"),\n          recurrentDates = _utils2.default.getDatesByRecurrence({\n        rule: recurrenceRule,\n        exception: recurrenceException,\n        start: startDate,\n        end: endDate,\n        min: startViewDate,\n        max: endViewDate\n      }),\n          recurrentDateCount = appointment.settings ? 1 : recurrentDates.length;\n\n      for (var i = 0; i < recurrentDateCount; i++) {\n        var appointmentPart = (0, _extend.extend)({}, appointment, true);\n\n        if (recurrentDates[i]) {\n          var appointmentSettings = this._applyStartDateToObj(recurrentDates[i], {});\n\n          this._applyEndDateToObj(new Date(recurrentDates[i].getTime() + appointmentDuration), appointmentSettings);\n\n          appointmentPart.settings = appointmentSettings;\n        } else {\n          appointmentPart.settings = dates;\n        }\n\n        result.parts.push(appointmentPart);\n\n        if (!skipLongAppointments) {\n          this._processLongAppointment(appointmentPart, result);\n        }\n      }\n\n      result.indexes.push(index);\n    }\n\n    return result;\n  },\n  _processLongAppointment: function _processLongAppointment(appointment, result) {\n    var parts = this.splitAppointmentByDay(appointment),\n        partCount = parts.length,\n        endViewDate = this.invoke(\"getEndViewDate\").getTime(),\n        startViewDate = this.invoke(\"getStartViewDate\").getTime(),\n        startDateTimeZone = this.invoke(\"getField\", \"startDateTimeZone\", appointment);\n    result = result || {\n      parts: []\n    };\n\n    if (partCount > 1) {\n      (0, _extend.extend)(appointment, parts[0]);\n\n      for (var i = 1; i < partCount; i++) {\n        var startDate = this.invoke(\"getField\", \"startDate\", parts[i].settings).getTime();\n        startDate = this.invoke(\"convertDateByTimezone\", startDate, startDateTimeZone);\n\n        if (startDate < endViewDate && startDate > startViewDate) {\n          result.parts.push(parts[i]);\n        }\n      }\n    }\n\n    return result;\n  },\n  _reduceRecurrenceAppointments: function _reduceRecurrenceAppointments(recurrenceIndexes, appointments) {\n    (0, _iterator.each)(recurrenceIndexes, function (i, index) {\n      appointments.splice(index - i, 1);\n    });\n  },\n  _combineAppointments: function _combineAppointments(appointments, additionalAppointments) {\n    if (additionalAppointments.length) {\n      _array2.default.merge(appointments, additionalAppointments);\n    }\n\n    this._sortAppointmentsByStartDate(appointments);\n  },\n  _applyStartDateToObj: function _applyStartDateToObj(startDate, obj) {\n    this.invoke(\"setField\", \"startDate\", obj, startDate);\n    return obj;\n  },\n  _applyEndDateToObj: function _applyEndDateToObj(endDate, obj) {\n    this.invoke(\"setField\", \"endDate\", obj, endDate);\n    return obj;\n  },\n  updateDraggablesBoundOffsets: function updateDraggablesBoundOffsets() {\n    if (this.option(\"allowDrag\")) {\n      this.$element().find(\".\" + APPOINTMENT_ITEM_CLASS).each(function (_, appointmentElement) {\n        var $appointment = (0, _renderer2.default)(appointmentElement),\n            appointmentData = this._getItemData($appointment);\n\n        if (!this.invoke(\"isAllDay\", appointmentData)) {\n          _draggable2.default.getInstance($appointment).option(\"boundOffset\", this._calculateBoundOffset());\n        }\n      }.bind(this));\n    }\n  },\n  moveAppointmentBack: function moveAppointmentBack() {\n    var $appointment = this._$currentAppointment,\n        size = this._initialSize,\n        coords = this._initialCoordinates;\n\n    if ($appointment) {\n      if (coords) {\n        _translator2.default.move($appointment, coords);\n\n        delete this._initialSize;\n      }\n\n      if (size) {\n        $appointment.outerWidth(size.width);\n        $appointment.outerHeight(size.height);\n        delete this._initialCoordinates;\n      }\n    }\n  },\n  focus: function focus() {\n    var $appointment = this._$currentAppointment;\n\n    if ($appointment) {\n      this.option(\"focusedElement\", (0, _dom.getPublicElement)($appointment));\n\n      _events_engine2.default.trigger(this.option(\"focusedElement\"), \"focus\");\n    }\n  },\n  splitAppointmentByDay: function splitAppointmentByDay(appointment) {\n    var dates = appointment.settings || appointment;\n\n    var originalStartDate = new Date(this.invoke(\"getField\", \"startDate\", dates)),\n        startDate = _date2.default.makeDate(originalStartDate),\n        endDate = _date2.default.makeDate(this.invoke(\"getField\", \"endDate\", dates)),\n        startDateTimeZone = this.invoke(\"getField\", \"startDateTimeZone\", appointment),\n        endDateTimeZone = this.invoke(\"getField\", \"endDateTimeZone\", appointment),\n        maxAllowedDate = this.invoke(\"getEndViewDate\"),\n        startDayHour = this.invoke(\"getStartDayHour\"),\n        endDayHour = this.invoke(\"getEndDayHour\"),\n        appointmentIsLong = this.invoke(\"appointmentTakesSeveralDays\", appointment),\n        result = [];\n\n    startDate = this.invoke(\"convertDateByTimezone\", startDate, startDateTimeZone);\n    endDate = this.invoke(\"convertDateByTimezone\", endDate, endDateTimeZone);\n\n    if (startDate.getHours() <= endDayHour && startDate.getHours() >= startDayHour && !appointmentIsLong) {\n      result.push(this._applyStartDateToObj(new Date(startDate), {\n        appointmentData: appointment\n      }));\n      startDate.setDate(startDate.getDate() + 1);\n    }\n\n    while (appointmentIsLong && startDate.getTime() < endDate.getTime() - 1 && startDate < maxAllowedDate) {\n      var currentStartDate = new Date(startDate),\n          currentEndDate = new Date(startDate);\n\n      this._checkStartDate(currentStartDate, originalStartDate, startDayHour);\n\n      this._checkEndDate(currentEndDate, endDate, endDayHour);\n\n      var appointmentData = _object2.default.deepExtendArraySafe({}, appointment, true),\n          appointmentSettings = {};\n\n      this._applyStartDateToObj(currentStartDate, appointmentSettings);\n\n      this._applyEndDateToObj(currentEndDate, appointmentSettings);\n\n      appointmentData.settings = appointmentSettings;\n      result.push(appointmentData);\n      startDate.setDate(startDate.getDate() + 1);\n      startDate.setHours(startDayHour);\n    }\n\n    return result;\n  },\n  _checkStartDate: function _checkStartDate(currentDate, originalDate, startDayHour) {\n    if (!_date2.default.sameDate(currentDate, originalDate) || currentDate.getHours() <= startDayHour) {\n      currentDate.setHours(startDayHour, 0, 0, 0);\n    } else {\n      currentDate.setHours(originalDate.getHours(), originalDate.getMinutes(), originalDate.getSeconds(), originalDate.getMilliseconds());\n    }\n  },\n  _checkEndDate: function _checkEndDate(currentDate, originalDate, endDayHour) {\n    if (!_date2.default.sameDate(currentDate, originalDate) || currentDate.getHours() > endDayHour) {\n      currentDate.setHours(endDayHour, 0, 0, 0);\n    } else {\n      currentDate.setHours(originalDate.getHours(), originalDate.getMinutes(), originalDate.getSeconds(), originalDate.getMilliseconds());\n    }\n  }\n}).include(_uiScheduler2.default);\n\n(0, _component_registrator2.default)(\"dxSchedulerAppointments\", SchedulerAppointments);\nmodule.exports = SchedulerAppointments;","map":null,"metadata":{},"sourceType":"script"}