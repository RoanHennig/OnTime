{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/ui.scheduler.subscribes.js)\r\n * Version: 19.1.6 (build 19263-1729)\r\n * Build date: Fri Sep 20 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _array = require(\"../../core/utils/array\");\n\nvar _array2 = _interopRequireDefault(_array);\n\nvar _utils = require(\"./utils.recurrence\");\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _date = require(\"../../core/utils/date\");\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _translator = require(\"../../animation/translator\");\n\nvar _translator2 = _interopRequireDefault(_translator);\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _date3 = require(\"../../localization/date\");\n\nvar _date4 = _interopRequireDefault(_date3);\n\nvar _uiScheduler = require(\"./timezones/ui.scheduler.timezones\");\n\nvar _uiScheduler2 = _interopRequireDefault(_uiScheduler);\n\nvar _deferred = require(\"../../core/utils/deferred\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar MINUTES_IN_HOUR = 60;\nvar toMs = _date2.default.dateToMilliseconds;\nvar subscribes = {\n  isCurrentViewAgenda: function isCurrentViewAgenda() {\n    return \"agenda\" === this.option(\"currentView\");\n  },\n  currentViewUpdated: function currentViewUpdated(currentView) {\n    this.option(\"currentView\", currentView);\n  },\n  currentDateUpdated: function currentDateUpdated(date) {\n    this.option(\"currentDate\", date);\n  },\n  setCellDataCacheAlias: function setCellDataCacheAlias(appointment, geometry) {\n    this._workSpace.setCellDataCacheAlias(appointment, geometry);\n  },\n  needCoordinates: function needCoordinates(options) {\n    var _this = this;\n\n    var appointmentData = options.appointmentData,\n        startDate = options.startDate,\n        endDate = this._getEndDate(appointmentData),\n        recurrenceRule = this.fire(\"getField\", \"recurrenceRule\", appointmentData),\n        recurrenceException = this._getRecurrenceException(appointmentData),\n        dateRange = this._workSpace.getDateRange(),\n        allDay = this.appointmentTakesAllDay(appointmentData),\n        startViewDate = this.appointmentTakesAllDay(appointmentData) ? _date2.default.trimTime(new Date(dateRange[0])) : dateRange[0],\n        originalStartDate = options.originalStartDate || startDate,\n        renderingStrategy = this.getLayoutManager().getRenderingStrategyInstance(),\n        firstDayOfWeek = this.option(\"firstDayOfWeek\");\n\n    var recurrenceOptions = {\n      rule: recurrenceRule,\n      exception: recurrenceException,\n      start: originalStartDate,\n      end: endDate,\n      min: startViewDate,\n      max: dateRange[1],\n      firstDayOfWeek: firstDayOfWeek\n    };\n\n    var dates = _utils2.default.getDatesByRecurrence(recurrenceOptions),\n        initialDates = void 0;\n\n    if (!dates.length) {\n      dates.push(startDate);\n      initialDates = dates;\n    } else {\n      initialDates = dates;\n      dates = dates.map(function (date) {\n        return _date2.default.roundDateByStartDayHour(date, _this._getCurrentViewOption(\"startDayHour\"));\n      });\n    }\n\n    if (renderingStrategy.needSeparateAppointment(allDay)) {\n      var datesLength = dates.length,\n          longParts = [],\n          resultDates = [];\n\n      var _loop = function _loop(i) {\n        var endDateOfPart = renderingStrategy.endDate(appointmentData, {\n          startDate: dates[i]\n        }, !!recurrenceRule);\n        longParts = _date2.default.getDatesOfInterval(dates[i], endDateOfPart, {\n          milliseconds: _this.getWorkSpace().getIntervalDuration(allDay)\n        });\n        var maxDate = new Date(dateRange[1]);\n        resultDates = resultDates.concat(longParts.filter(function (el) {\n          return new Date(el) < maxDate;\n        }));\n      };\n\n      for (var i = 0; i < datesLength; i++) {\n        _loop(i);\n      }\n\n      dates = resultDates;\n    }\n\n    var itemResources = this._resourcesManager.getResourcesFromItem(appointmentData);\n\n    allDay = this.appointmentTakesAllDay(appointmentData) && this._workSpace.supportAllDayRow();\n    options.callback(this._getCoordinates(initialDates, dates, itemResources, allDay));\n  },\n  isGroupedByDate: function isGroupedByDate() {\n    return this.getWorkSpace().isGroupedByDate();\n  },\n  showAppointmentTooltip: function showAppointmentTooltip(options) {\n    options.skipDateCalculation = true;\n    options.$appointment = (0, _renderer2.default)(options.target);\n\n    var appointmentData = options.data,\n        singleAppointmentData = this._getSingleAppointmentData(appointmentData, options);\n\n    this.showAppointmentTooltip(appointmentData, options.target, singleAppointmentData);\n  },\n  hideAppointmentTooltip: function hideAppointmentTooltip() {\n    this.hideAppointmentTooltip();\n  },\n  showAddAppointmentPopup: function showAddAppointmentPopup(appointmentData) {\n    var processedData = {};\n    (0, _iterator.each)([\"startDate\", \"endDate\", \"allDay\"], function (_, field) {\n      if (void 0 !== appointmentData[field]) {\n        this.fire(\"setField\", field, processedData, appointmentData[field]);\n        delete appointmentData[field];\n      }\n    }.bind(this));\n    this.showAppointmentPopup((0, _extend.extend)(processedData, appointmentData), true);\n  },\n  showEditAppointmentPopup: function showEditAppointmentPopup(options) {\n    var appointmentData = options.data;\n    options.$appointment = (0, _renderer2.default)(options.target);\n    options.skipHoursProcessing = true;\n\n    var singleAppointmentData = this._getSingleAppointmentData(appointmentData, options),\n        startDate = this.fire(\"getField\", \"startDate\", singleAppointmentData);\n\n    this.showAppointmentPopup(appointmentData, false, singleAppointmentData, startDate);\n  },\n  updateAppointmentAfterResize: function updateAppointmentAfterResize(options) {\n    var targetAppointment = options.target,\n        singleAppointment = this._getSingleAppointmentData(targetAppointment, options),\n        startDate = this.fire(\"getField\", \"startDate\", singleAppointment),\n        updatedData = (0, _extend.extend)(true, {}, options.data);\n\n    this._convertDatesByTimezoneBack(true, updatedData);\n\n    this._checkRecurringAppointment(targetAppointment, singleAppointment, startDate, function () {\n      this._updateAppointment(targetAppointment, updatedData, function () {\n        this._appointments.moveAppointmentBack();\n      });\n    }.bind(this));\n  },\n  updateAppointmentAfterDrag: function updateAppointmentAfterDrag(options) {\n    var target = options.data,\n        updatedData = this._getUpdatedData(options),\n        newCellIndex = this._workSpace.getDroppableCellIndex(),\n        oldCellIndex = this._workSpace.getCellIndexByCoordinates(options.coordinates),\n        becomeAllDay = this.fire(\"getField\", \"allDay\", updatedData),\n        wasAllDay = this.fire(\"getField\", \"allDay\", target);\n\n    var appointment = (0, _extend.extend)({}, target, updatedData);\n\n    var movedToAllDay = this._workSpace.supportAllDayRow() && becomeAllDay,\n        cellData = this._workSpace.getCellDataByCoordinates(options.coordinates, movedToAllDay),\n        movedBetweenAllDayAndSimple = this._workSpace.supportAllDayRow() && (wasAllDay && !becomeAllDay || !wasAllDay && becomeAllDay);\n\n    if (newCellIndex !== oldCellIndex || movedBetweenAllDayAndSimple) {\n      this._checkRecurringAppointment(target, appointment, cellData.startDate, function () {\n        this._convertDatesByTimezoneBack(true, updatedData, appointment);\n\n        this._updateAppointment(target, appointment, function () {\n          this._appointments.moveAppointmentBack();\n        });\n      }.bind(this));\n    } else {\n      this._appointments.moveAppointmentBack();\n    }\n  },\n  deleteAppointment: function deleteAppointment(options) {\n    options.$appointment = (0, _renderer2.default)(options.target);\n\n    var appointmentData = options.data,\n        singleAppointmentData = this._getSingleAppointmentData(appointmentData, options),\n        startDate = this.fire(\"getField\", \"startDate\", singleAppointmentData);\n\n    this._checkRecurringAppointment(appointmentData, singleAppointmentData, startDate, function () {\n      this.deleteAppointment(appointmentData);\n    }.bind(this), true);\n  },\n  getResourceForPainting: function getResourceForPainting() {\n    return this._resourcesManager.getResourceForPainting(this._getCurrentViewOption(\"groups\"));\n  },\n  getAppointmentColor: function getAppointmentColor(options) {\n    var resourcesManager = this._resourcesManager,\n        resourceForPainting = resourcesManager.getResourceForPainting(this._getCurrentViewOption(\"groups\")),\n        response = new _deferred.Deferred().resolve().promise();\n\n    if (resourceForPainting) {\n      var field = resourcesManager.getField(resourceForPainting),\n          groupIndex = options.groupIndex,\n          groups = this._workSpace._getCellGroups(groupIndex),\n          resourceValues = _array2.default.wrapToArray(resourcesManager.getDataAccessors(field, \"getter\")(options.itemData)),\n          groupId = resourceValues.length ? resourceValues[0] : void 0;\n\n      for (var i = 0; i < groups.length; i++) {\n        if (groups[i].name === field) {\n          groupId = groups[i].id;\n          break;\n        }\n      }\n\n      response = resourcesManager.getResourceColor(field, groupId);\n    }\n\n    options.callback(response);\n  },\n  getHeaderHeight: function getHeaderHeight() {\n    return this._header._$element && parseInt(this._header._$element.outerHeight(), 10);\n  },\n  getResourcesFromItem: function getResourcesFromItem(options) {\n    options.callback(this._resourcesManager.getResourcesFromItem(options.itemData));\n  },\n  getBoundOffset: function getBoundOffset(options) {\n    options.callback({\n      top: -this.getWorkSpaceAllDayHeight()\n    });\n  },\n  appointmentTakesAllDay: function appointmentTakesAllDay(options) {\n    options.callback(this.appointmentTakesAllDay(options.appointment));\n  },\n  appointmentTakesSeveralDays: function appointmentTakesSeveralDays(appointment) {\n    return this._appointmentModel.appointmentTakesSeveralDays(appointment);\n  },\n  appointmentFocused: function appointmentFocused() {\n    this._workSpace.restoreScrollTop();\n  },\n  getResizableAppointmentArea: function getResizableAppointmentArea(options) {\n    var area = void 0,\n        allDay = options.allDay,\n        groups = this._getCurrentViewOption(\"groups\"),\n        isGrouped = groups && groups.length;\n\n    if (isGrouped) {\n      if (allDay || this.getLayoutManager().getRenderingStrategyInstance()._needHorizontalGroupBounds()) {\n        var horizontalGroupBounds = this._workSpace.getGroupBounds(options.coordinates);\n\n        area = {\n          left: horizontalGroupBounds.left,\n          right: horizontalGroupBounds.right,\n          top: 0,\n          bottom: 0\n        };\n      }\n\n      if (this.getLayoutManager().getRenderingStrategyInstance()._needVerticalGroupBounds(allDay) && this._workSpace._isVerticalGroupedWorkSpace()) {\n        var verticalGroupBounds = this._workSpace.getGroupBounds(options.coordinates);\n\n        area = {\n          left: 0,\n          right: 0,\n          top: verticalGroupBounds.top,\n          bottom: verticalGroupBounds.bottom\n        };\n      }\n    }\n\n    options.callback(area);\n  },\n  needRecalculateResizableArea: function needRecalculateResizableArea() {\n    return this.getWorkSpace().needRecalculateResizableArea();\n  },\n  getDraggableAppointmentArea: function getDraggableAppointmentArea(options) {\n    options.callback(this.getWorkSpaceScrollableContainer());\n  },\n  getAppointmentGeometry: function getAppointmentGeometry(settings) {\n    return this.getLayoutManager().getRenderingStrategyInstance().getAppointmentGeometry(settings);\n  },\n  isAllDay: function isAllDay(appointmentData) {\n    return this.getLayoutManager().getRenderingStrategyInstance().isAllDay(appointmentData);\n  },\n  getDeltaTime: function getDeltaTime(e, initialSize, itemData) {\n    return this.getLayoutManager().getRenderingStrategyInstance().getDeltaTime(e, initialSize, itemData);\n  },\n  getDropDownAppointmentWidth: function getDropDownAppointmentWidth(isAllDay) {\n    return this.getLayoutManager().getRenderingStrategyInstance().getDropDownAppointmentWidth(this._getViewCountConfig().intervalCount, isAllDay);\n  },\n  getDropDownAppointmentHeight: function getDropDownAppointmentHeight() {\n    return this.getLayoutManager().getRenderingStrategyInstance().getDropDownAppointmentHeight();\n  },\n  getStartDate: function getStartDate(appointmentData, skipNormalize) {\n    return this._getStartDate(appointmentData, skipNormalize);\n  },\n  getCellWidth: function getCellWidth() {\n    return this._cellWidth;\n  },\n  getCellHeight: function getCellHeight() {\n    return this._cellHeight;\n  },\n  getResizableStep: function getResizableStep() {\n    var cellWidth = this._cellWidth,\n        workSpace = this.getWorkSpace();\n\n    if (workSpace.isGroupedByDate()) {\n      return workSpace._getGroupCount() * cellWidth;\n    }\n\n    return cellWidth;\n  },\n  getEndDate: function getEndDate(appointmentData, skipNormalize) {\n    return this._getEndDate(appointmentData, skipNormalize);\n  },\n  getRenderingStrategy: function getRenderingStrategy() {\n    return this._getAppointmentsRenderingStrategy();\n  },\n  needCorrectAppointmentDates: function needCorrectAppointmentDates() {\n    return this.getRenderingStrategyInstance().needCorrectAppointmentDates();\n  },\n  getRenderingStrategyDirection: function getRenderingStrategyDirection() {\n    return this.getRenderingStrategyInstance().getDirection();\n  },\n  getWorkSpaceDateTableOffset: function getWorkSpaceDateTableOffset() {\n    return this.getWorkSpaceDateTableOffset();\n  },\n  correctAppointmentCoordinates: function correctAppointmentCoordinates(options) {\n    var isAllDay = options.allDay,\n        containerSign = options.isFixedContainer ? -1 : 1;\n    var scrollTop = this.getWorkSpaceScrollableScrollTop(isAllDay),\n        allDayPanelTopOffset = !isAllDay ? this.getWorkSpaceAllDayOffset() : 0,\n        headerHeight = this.getWorkSpaceHeaderPanelHeight(),\n        scrollLeft = this.getWorkSpaceScrollableScrollLeft(),\n        tableLeftOffset = this.getWorkSpaceDateTableOffset();\n    var topOffset = -scrollTop + allDayPanelTopOffset + headerHeight,\n        leftOffset = -scrollLeft - tableLeftOffset;\n    options.callback({\n      top: options.coordinates.top + containerSign * topOffset,\n      left: options.coordinates.left + containerSign * leftOffset\n    });\n  },\n  allDayPanelToggled: function allDayPanelToggled() {\n    this._appointments.updateDraggablesBoundOffsets();\n  },\n  formatDates: function formatDates(options) {\n    var startDate = options.startDate,\n        endDate = options.endDate,\n        formatType = options.formatType;\n    var formatTypes = {\n      DATETIME: function DATETIME() {\n        var dateTimeFormat = \"mediumdatemediumtime\",\n            startDateString = _date4.default.format(startDate, dateTimeFormat) + \" - \";\n        var endDateString = startDate.getDate() === endDate.getDate() ? _date4.default.format(endDate, \"shorttime\") : _date4.default.format(endDate, dateTimeFormat);\n        return startDateString + endDateString;\n      },\n      TIME: function TIME() {\n        return _date4.default.format(startDate, \"shorttime\") + \" - \" + _date4.default.format(endDate, \"shorttime\");\n      },\n      DATE: function DATE() {\n        var dateTimeFormat = \"monthAndDay\",\n            startDateString = _date4.default.format(startDate, dateTimeFormat),\n            isDurationMoreThanDay = endDate.getTime() - startDate.getTime() > toMs(\"day\");\n\n        var endDateString = isDurationMoreThanDay || endDate.getDate() !== startDate.getDate() ? \" - \" + _date4.default.format(endDate, dateTimeFormat) : \"\";\n        return startDateString + endDateString;\n      }\n    };\n    options.callback(formatTypes[formatType]());\n  },\n  getFullWeekAppointmentWidth: function getFullWeekAppointmentWidth(options) {\n    var groupIndex = options.groupIndex,\n        groupWidth = this._workSpace.getGroupWidth(groupIndex);\n\n    options.callback(groupWidth);\n  },\n  getMaxAppointmentWidth: function getMaxAppointmentWidth(options) {\n    var cellCountToLastViewDate = this._workSpace.getCellCountToLastViewDate(options.date);\n\n    options.callback(cellCountToLastViewDate * this._workSpace.getCellWidth());\n  },\n  updateAppointmentStartDate: function updateAppointmentStartDate(options) {\n    var appointment = options.appointment,\n        firstViewDate = this._workSpace.getStartViewDate(),\n        startDate = new Date(options.startDate),\n        startDayHour = this._getCurrentViewOption(\"startDayHour\"),\n        updatedStartDate = void 0;\n\n    if (this.appointmentTakesAllDay(appointment)) {\n      updatedStartDate = _date2.default.normalizeDate(startDate, firstViewDate);\n    } else {\n      if (startDate < firstViewDate) {\n        startDate = firstViewDate;\n      }\n\n      updatedStartDate = _date2.default.normalizeDate(options.startDate, new Date(startDate));\n    }\n\n    updatedStartDate = _date2.default.roundDateByStartDayHour(updatedStartDate, startDayHour);\n    options.callback(updatedStartDate);\n  },\n  updateAppointmentEndDate: function updateAppointmentEndDate(options) {\n    var endDate = new Date(options.endDate),\n        endDayHour = this._getCurrentViewOption(\"endDayHour\"),\n        startDayHour = this._getCurrentViewOption(\"startDayHour\"),\n        updatedEndDate = endDate;\n\n    if (endDate.getHours() >= endDayHour) {\n      updatedEndDate.setHours(endDayHour, 0, 0, 0);\n    } else {\n      if (startDayHour > 0 && 60 * endDate.getHours() + endDate.getMinutes() < 60 * startDayHour) {\n        updatedEndDate = new Date(updatedEndDate.getTime() - toMs(\"day\"));\n        updatedEndDate.setHours(endDayHour, 0, 0, 0);\n      }\n    }\n\n    options.callback(updatedEndDate);\n  },\n  renderCompactAppointments: function renderCompactAppointments(options) {\n    this._compactAppointmentsHelper.render(options);\n  },\n  clearCompactAppointments: function clearCompactAppointments() {\n    this._compactAppointmentsHelper.clear();\n  },\n  supportCompactDropDownAppointments: function supportCompactDropDownAppointments() {\n    return this._workSpace._supportCompactDropDownAppointments();\n  },\n  getGroupCount: function getGroupCount() {\n    return this._workSpace._getGroupCount();\n  },\n  mapAppointmentFields: function mapAppointmentFields(config) {\n    var result = {\n      appointmentData: config.itemData,\n      appointmentElement: config.itemElement\n    };\n\n    if (config.itemData) {\n      result.targetedAppointmentData = this.fire(\"getTargetedAppointmentData\", config.itemData, config.itemElement);\n    }\n\n    return result;\n  },\n  getOffsetByAllDayPanel: function getOffsetByAllDayPanel(groupIndex) {\n    return this._workSpace._getOffsetByAllDayPanel(groupIndex);\n  },\n  getGroupTop: function getGroupTop(groupIndex) {\n    return this._workSpace._getGroupTop(groupIndex);\n  },\n  updateResizableArea: function updateResizableArea() {\n    var $allResizableElements = this.$element().find(\".dx-scheduler-appointment.dx-resizable\");\n    var horizontalResizables = (0, _common.grep)($allResizableElements, function (el) {\n      var $el = (0, _renderer2.default)(el),\n          resizableInst = $el.dxResizable(\"instance\"),\n          area = resizableInst.option(\"area\");\n      return (0, _array.inArray)(resizableInst.option(\"handles\"), [\"right left\", \"left right\"]) > -1 && _type2.default.isPlainObject(area);\n    });\n    (0, _iterator.each)(horizontalResizables, function (_, el) {\n      var $el = (0, _renderer2.default)(el),\n          position = _translator2.default.locate($el),\n          appointmentData = this._appointments._getItemData($el);\n\n      var area = this._appointments._calculateResizableArea({\n        left: position.left\n      }, appointmentData);\n\n      $el.dxResizable(\"instance\").option(\"area\", area);\n    }.bind(this));\n  },\n  recurrenceEditorVisibilityChanged: function recurrenceEditorVisibilityChanged(visible) {\n    this.recurrenceEditorVisibilityChanged(visible);\n  },\n  resizePopup: function resizePopup() {\n    this.resizePopup();\n  },\n  getField: function getField(field, obj) {\n    if (!_type2.default.isDefined(this._dataAccessors.getter[field])) {\n      return;\n    }\n\n    return this._dataAccessors.getter[field](obj);\n  },\n  setField: function setField(field, obj, value) {\n    if (!_type2.default.isDefined(this._dataAccessors.setter[field])) {\n      return;\n    }\n\n    var splitExprStr = this.option(field + \"Expr\").split(\".\"),\n        rootField = splitExprStr[0];\n\n    if (void 0 === obj[rootField] && splitExprStr.length > 1) {\n      var emptyChain = function (arr) {\n        var result = {},\n            tmp = result,\n            arrLength = arr.length - 1;\n\n        for (var i = 1; i < arrLength; i++) {\n          tmp = tmp[arr[i]] = {};\n        }\n\n        return result;\n      }(splitExprStr);\n\n      obj[rootField] = emptyChain;\n    }\n\n    this._dataAccessors.setter[field](obj, value);\n\n    return obj;\n  },\n  prerenderFilter: function prerenderFilter() {\n    var dateRange = this.getWorkSpace().getDateRange(),\n        resources = this._resourcesManager.getResourcesData(),\n        allDay = void 0;\n\n    if (!this.option(\"showAllDayPanel\") && this._workSpace.supportAllDayRow()) {\n      allDay = false;\n    }\n\n    return this._appointmentModel.filterLoadedAppointments({\n      startDayHour: this._getCurrentViewOption(\"startDayHour\"),\n      endDayHour: this._getCurrentViewOption(\"endDayHour\"),\n      min: dateRange[0],\n      max: dateRange[1],\n      resources: resources,\n      allDay: allDay,\n      firstDayOfWeek: this.option(\"firstDayOfWeek\"),\n      recurrenceException: this._getRecurrenceException.bind(this)\n    }, this._subscribes.convertDateByTimezone.bind(this));\n  },\n  dayHasAppointment: function dayHasAppointment(day, appointment, trimTime) {\n    return this.dayHasAppointment(day, appointment, trimTime);\n  },\n  createResourcesTree: function createResourcesTree() {\n    return this._resourcesManager.createResourcesTree(this._loadedResources);\n  },\n  getResourceTreeLeaves: function getResourceTreeLeaves(tree, appointmentResources) {\n    return this._resourcesManager.getResourceTreeLeaves(tree, appointmentResources);\n  },\n  createReducedResourcesTree: function createReducedResourcesTree() {\n    var tree = this._resourcesManager.createResourcesTree(this._loadedResources);\n\n    return this._resourcesManager.reduceResourcesTree(tree, this.getFilteredItems());\n  },\n  groupAppointmentsByResources: function groupAppointmentsByResources(appointments) {\n    var result = {\n      0: appointments\n    },\n        groups = this._getCurrentViewOption(\"groups\");\n\n    if (groups && groups.length && this._resourcesManager.getResourcesData().length) {\n      result = this._resourcesManager.groupAppointmentsByResources(appointments, this._loadedResources);\n    }\n\n    var totalResourceCount = 0;\n    (0, _iterator.each)(this._loadedResources, function (i, resource) {\n      if (!i) {\n        totalResourceCount = resource.items.length;\n      } else {\n        totalResourceCount *= resource.items.length;\n      }\n    });\n\n    for (var j = 0; j < totalResourceCount; j++) {\n      var index = j.toString();\n\n      if (result[index]) {\n        continue;\n      }\n\n      result[index] = [];\n    }\n\n    return result;\n  },\n  getAgendaRows: function getAgendaRows(options) {\n    var renderingStrategy = this._layoutManager.getRenderingStrategyInstance(),\n        calculateRows = renderingStrategy.calculateRows.bind(renderingStrategy),\n        d = new _deferred.Deferred();\n\n    function rowsCalculated(appointments) {\n      var result = calculateRows(appointments, options.agendaDuration, options.currentDate);\n\n      this._dataSourceLoadedCallback.remove(rowsCalculated);\n\n      d.resolve(result);\n    }\n\n    this._dataSourceLoadedCallback.add(rowsCalculated);\n\n    return d.promise();\n  },\n  getAgendaVerticalStepHeight: function getAgendaVerticalStepHeight() {\n    return this.getWorkSpace().getAgendaVerticalStepHeight();\n  },\n  getAgendaDuration: function getAgendaDuration() {\n    return this._getCurrentViewOption(\"agendaDuration\");\n  },\n  getStartViewDate: function getStartViewDate() {\n    return this.getStartViewDate();\n  },\n  getEndViewDate: function getEndViewDate() {\n    return this.getEndViewDate();\n  },\n  getMaxAppointmentsPerCell: function getMaxAppointmentsPerCell() {\n    return this.getMaxAppointmentsPerCell();\n  },\n  forceMaxAppointmentPerCell: function forceMaxAppointmentPerCell() {\n    return this.forceMaxAppointmentPerCell();\n  },\n  agendaIsReady: function agendaIsReady(rows, innerRowOffset, outerRowOffset) {\n    var $appts = this.getAppointmentsInstance()._itemElements(),\n        total = 0;\n\n    $appts.css(\"marginBottom\", innerRowOffset);\n\n    var applyOffset = function applyOffset(_, count) {\n      var index = count + total - 1;\n      $appts.eq(index).css(\"marginBottom\", outerRowOffset);\n      total += count;\n    };\n\n    for (var i = 0; i < rows.length; i++) {\n      (0, _iterator.each)(rows[i], applyOffset);\n    }\n  },\n  getTimezone: function getTimezone() {\n    return this._getTimezoneOffsetByOption();\n  },\n  getClientTimezoneOffset: function getClientTimezoneOffset(date) {\n    date = date || new Date();\n    return _uiScheduler2.default.getClientTimezoneOffset(date);\n  },\n  convertDateByTimezone: function convertDateByTimezone(date, appointmentTimezone) {\n    date = new Date(date);\n\n    var tzOffsets = this._subscribes.getComplexOffsets(this, date, appointmentTimezone);\n\n    date = this._subscribes.translateDateToAppointmentTimeZone(date, tzOffsets);\n    date = this._subscribes.translateDateToCommonTimeZone(date, tzOffsets);\n    return date;\n  },\n  convertDateByTimezoneBack: function convertDateByTimezoneBack(date, appointmentTimezone) {\n    date = new Date(date);\n\n    var tzOffsets = this._subscribes.getComplexOffsets(this, date, appointmentTimezone);\n\n    date = this._subscribes.translateDateToAppointmentTimeZone(date, tzOffsets, true);\n    date = this._subscribes.translateDateToCommonTimeZone(date, tzOffsets, true);\n    return date;\n  },\n  translateDateToAppointmentTimeZone: function translateDateToAppointmentTimeZone(date, offsets, back) {\n    var operation = back ? -1 : 1;\n    var dateInUTC = date.getTime() - operation * offsets.client * toMs(\"hour\");\n    return new Date(dateInUTC + operation * offsets.appointment * toMs(\"hour\"));\n  },\n  translateDateToCommonTimeZone: function translateDateToCommonTimeZone(date, offsets, back) {\n    var operation = back ? -1 : 1;\n\n    if (\"number\" === typeof offsets.common) {\n      var offset = offsets.common - offsets.appointment,\n          hoursOffset = (offset < 0 ? -1 : 1) * Math.floor(Math.abs(offset)),\n          minutesOffset = offset % 1;\n      date.setHours(date.getHours() + operation * hoursOffset);\n      date.setMinutes(date.getMinutes() + operation * minutesOffset * MINUTES_IN_HOUR);\n    }\n\n    return date;\n  },\n  getComplexOffsets: function getComplexOffsets(scheduler, date, appointmentTimezone) {\n    var clientTimezoneOffset = -this.getClientTimezoneOffset(date) / toMs(\"hour\");\n\n    var commonTimezoneOffset = scheduler._getTimezoneOffsetByOption(date);\n\n    var appointmentTimezoneOffset = scheduler._calculateTimezoneByValue(appointmentTimezone, date);\n\n    if (\"number\" !== typeof appointmentTimezoneOffset) {\n      appointmentTimezoneOffset = clientTimezoneOffset;\n    }\n\n    return {\n      client: clientTimezoneOffset,\n      common: commonTimezoneOffset,\n      appointment: appointmentTimezoneOffset\n    };\n  },\n  getDaylightOffset: function getDaylightOffset(startDate, endDate) {\n    return startDate.getTimezoneOffset() - endDate.getTimezoneOffset();\n  },\n  getTimezonesDisplayName: function getTimezonesDisplayName() {\n    return _uiScheduler2.default.getTimezonesDisplayName();\n  },\n  getTimezoneDisplayNameById: function getTimezoneDisplayNameById(id) {\n    return _uiScheduler2.default.getTimezoneDisplayNameById(id);\n  },\n  getSimilarTimezones: function getSimilarTimezones(id) {\n    return _uiScheduler2.default.getSimilarTimezones(id);\n  },\n  getTimezonesIdsByDisplayName: function getTimezonesIdsByDisplayName(displayName) {\n    return _uiScheduler2.default.getTimezonesIdsByDisplayName(displayName);\n  },\n  getTargetedAppointmentData: function getTargetedAppointmentData(appointmentData, appointmentElement) {\n    var $appointmentElement = (0, _renderer2.default)(appointmentElement),\n        appointmentIndex = $appointmentElement.data(this._appointments._itemIndexKey()),\n        recurringData = this._getSingleAppointmentData(appointmentData, {\n      skipDateCalculation: true,\n      $appointment: $appointmentElement,\n      skipHoursProcessing: true\n    }),\n        result = {};\n\n    (0, _extend.extend)(true, result, appointmentData, recurringData);\n\n    this._convertDatesByTimezoneBack(false, result);\n\n    appointmentElement && this.setTargetedAppointmentResources(result, appointmentElement, appointmentIndex);\n    return result;\n  },\n  getAppointmentDurationInMs: function getAppointmentDurationInMs(options) {\n    var startDate = options.startDate,\n        endDate = options.endDate,\n        allDay = options.allDay,\n        appointmentDuration = endDate.getTime() - startDate.getTime();\n\n    var dayDuration = toMs(\"day\"),\n        visibleDayDuration = this._workSpace.getVisibleDayDuration(),\n        result = 0;\n\n    if (allDay) {\n      var ceilQuantityOfDays = Math.ceil(appointmentDuration / dayDuration);\n      result = ceilQuantityOfDays * visibleDayDuration;\n    } else {\n      var isDifferentDate = !_date2.default.sameDate(startDate, new Date(endDate.getTime() - 1)),\n          floorQuantityOfDays = Math.floor(appointmentDuration / dayDuration),\n          tailDuration = void 0;\n\n      if (isDifferentDate) {\n        var hiddenDayDuration = dayDuration - visibleDayDuration;\n        tailDuration = appointmentDuration - (floorQuantityOfDays ? floorQuantityOfDays * dayDuration : hiddenDayDuration);\n\n        var startDayTime = this.option(\"startDayHour\") * toMs(\"hour\"),\n            endPartDuration = endDate - _date2.default.trimTime(endDate);\n\n        if (endPartDuration < startDayTime) {\n          if (floorQuantityOfDays) {\n            tailDuration -= hiddenDayDuration;\n          }\n\n          tailDuration += startDayTime - endPartDuration;\n        }\n      } else {\n        tailDuration = appointmentDuration % dayDuration;\n      }\n\n      if (tailDuration > visibleDayDuration) {\n        tailDuration = visibleDayDuration;\n      }\n\n      result = floorQuantityOfDays * visibleDayDuration + tailDuration;\n    }\n\n    options.callback(result);\n  },\n  fixWrongEndDate: function fixWrongEndDate(appointment, startDate, endDate) {\n    return this._appointmentModel.fixWrongEndDate(appointment, startDate, endDate);\n  },\n  getEndDayHour: function getEndDayHour() {\n    return this._workSpace.option(\"endDayHour\") || this.option(\"endDayHour\");\n  },\n  getStartDayHour: function getStartDayHour() {\n    return this._workSpace.option(\"startDayHour\") || this.option(\"startDayHour\");\n  },\n  isAdaptive: function isAdaptive() {\n    return this.option(\"adaptivityEnabled\");\n  }\n};\nmodule.exports = subscribes;","map":null,"metadata":{},"sourceType":"script"}