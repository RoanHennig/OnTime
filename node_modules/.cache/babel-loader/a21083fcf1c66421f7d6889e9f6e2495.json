{"ast":null,"code":"/**\r\n * DevExtreme (ui/list/ui.list.edit.decorator.reorder.js)\r\n * Version: 19.1.6 (build 19263-1729)\r\n * Build date: Fri Sep 20 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../../core/renderer\"),\n    each = require(\"../../core/utils/iterator\").each,\n    eventsEngine = require(\"../../events/core/events_engine\"),\n    translator = require(\"../../animation/translator\"),\n    fx = require(\"../../animation/fx\"),\n    dragEvents = require(\"../../events/drag\"),\n    mathUtils = require(\"../../core/utils/math\"),\n    Animator = require(\"../scroll_view/animator\"),\n    eventUtils = require(\"../../events/utils\"),\n    registerDecorator = require(\"./ui.list.edit.decorator_registry\").register,\n    EditDecorator = require(\"./ui.list.edit.decorator\");\n\nvar ReorderScrollAnimator = Animator.inherit({\n  ctor: function ctor(strategy) {\n    this.callBase();\n    this._strategy = strategy;\n  },\n  _isFinished: function _isFinished() {\n    return this._strategy.scrollFinished();\n  },\n  _step: function _step() {\n    this._strategy.scrollByStep();\n  }\n});\nvar LIST_EDIT_DECORATOR = \"dxListEditDecorator\",\n    DRAG_START_EVENT_NAME = eventUtils.addNamespace(dragEvents.start, LIST_EDIT_DECORATOR),\n    DRAG_UPDATE_EVENT_NAME = eventUtils.addNamespace(dragEvents.move, LIST_EDIT_DECORATOR),\n    DRAG_END_EVENT_NAME = eventUtils.addNamespace(dragEvents.end, LIST_EDIT_DECORATOR),\n    REORDER_HANDLE_CONTAINER_CLASS = \"dx-list-reorder-handle-container\",\n    REORDER_HANDLE_CLASS = \"dx-list-reorder-handle\",\n    REOREDERING_ITEM_CLASS = \"dx-list-item-reordering\",\n    REOREDERING_ITEM_GHOST_CLASS = \"dx-list-item-ghost-reordering\";\nregisterDecorator(\"reorder\", \"default\", EditDecorator.inherit({\n  _init: function _init() {\n    this._groupedEnabled = this._list.option(\"grouped\");\n\n    this._initAnimator();\n  },\n  _initAnimator: function _initAnimator() {\n    this._scrollAnimator = new ReorderScrollAnimator(this);\n  },\n  _startAnimator: function _startAnimator() {\n    if (!this._scrollAnimator.inProgress()) {\n      this._scrollAnimator.start();\n    }\n  },\n  _stopAnimator: function _stopAnimator() {\n    this._scrollAnimator.stop();\n  },\n  afterBag: function afterBag(config) {\n    var $itemElement = config.$itemElement,\n        $container = config.$container;\n    var $handle = $(\"<div>\").addClass(REORDER_HANDLE_CLASS);\n    var lockedDrag = false;\n    eventsEngine.on($handle, \"dxpointerdown\", function (e) {\n      lockedDrag = !eventUtils.isMouseEvent(e);\n    });\n    eventsEngine.on($handle, \"dxhold\", {\n      timeout: 30\n    }, function (e) {\n      e.cancel = true;\n      lockedDrag = false;\n    });\n    eventsEngine.on($handle, DRAG_START_EVENT_NAME, {\n      direction: \"vertical\",\n      immediate: true\n    }, function (e) {\n      if (lockedDrag) {\n        e.cancel = true;\n        return;\n      }\n\n      this._dragStartHandler($itemElement, e);\n    }.bind(this));\n    eventsEngine.on($handle, DRAG_UPDATE_EVENT_NAME, this._dragHandler.bind(this, $itemElement));\n    eventsEngine.on($handle, DRAG_END_EVENT_NAME, this._dragEndHandler.bind(this, $itemElement));\n    $container.addClass(REORDER_HANDLE_CONTAINER_CLASS);\n    $container.append($handle);\n  },\n  _dragStartHandler: function _dragStartHandler($itemElement, e) {\n    if ($itemElement.is(\".dx-state-disabled, .dx-state-disabled *\")) {\n      e.cancel = true;\n      return;\n    }\n\n    this._stopPreviousAnimation();\n\n    e.targetElements = [];\n\n    this._cacheItemsPositions();\n\n    this._startPointerOffset = e.pageY - $itemElement.offset().top;\n    this._elementHeight = $itemElement.outerHeight();\n\n    var itemIndex = this._list.getFlatIndexByItemElement($itemElement);\n\n    this._startIndex = itemIndex;\n    this._lastIndex = itemIndex;\n    this._dragRange = this._getDragRange(itemIndex);\n\n    this._cacheScrollData();\n\n    var that = this;\n    this._createGhostTimeout = setTimeout(function () {\n      that._createGhost($itemElement);\n\n      that._updateGhostPosition();\n\n      $itemElement.addClass(REOREDERING_ITEM_CLASS);\n    });\n  },\n  _stopPreviousAnimation: function _stopPreviousAnimation() {\n    fx.stop(this._$ghostItem, true);\n  },\n  _cacheItemsPositions: function _cacheItemsPositions() {\n    var itemPositions = this._itemPositions = [];\n    each(this._list.itemElements(), function (index, item) {\n      var cachedPosition = null;\n      itemPositions.push(function () {\n        cachedPosition = null === cachedPosition ? $(item).position().top : cachedPosition;\n        return cachedPosition;\n      });\n    });\n  },\n  _getDraggingElementPosition: function _getDraggingElementPosition() {\n    return this._itemPositions[this._startIndex]();\n  },\n  _getLastElementPosition: function _getLastElementPosition() {\n    return this._itemPositions[this._lastIndex]();\n  },\n  _cacheScrollData: function _cacheScrollData() {\n    this._list.updateDimensions();\n\n    this._startScrollTop = this._list.scrollTop();\n    this._scrollOffset = 0;\n    this._scrollHeight = this._list.scrollHeight();\n    this._clientHeight = this._list.clientHeight();\n  },\n  _scrollTop: function _scrollTop() {\n    return this._startScrollTop + this._scrollOffset;\n  },\n  _createGhost: function _createGhost($itemElement) {\n    this._$ghostItem = $itemElement.clone();\n\n    this._$ghostItem.addClass(REOREDERING_ITEM_GHOST_CLASS).appendTo(this._list.itemsContainer());\n\n    this._startGhostPosition = this._getDraggingElementPosition() - this._$ghostItem.position().top;\n    translator.move(this._$ghostItem, {\n      top: this._startGhostPosition\n    });\n  },\n  _dragHandler: function _dragHandler($itemElement, e) {\n    this._topOffset = e.offset.y;\n\n    this._updateItemPositions();\n\n    var pointerPosition = this._getPointerPosition();\n\n    this._toggleScroll(pointerPosition);\n  },\n  _getPointerPosition: function _getPointerPosition() {\n    return this._getDraggingElementPosition() + this._startPointerOffset + this._scrollOffset + this._topOffset;\n  },\n  _toggleScroll: function _toggleScroll(pointerPosition) {\n    if (this._scrollHeight <= this._clientHeight) {\n      return;\n    }\n\n    var minOffset = .7 * this._elementHeight,\n        topOffset = this._clientHeight - (pointerPosition - this._scrollTop()),\n        topOffsetRatio = topOffset / minOffset,\n        bottomOffset = pointerPosition - this._scrollTop(),\n        bottomOffsetRatio = bottomOffset / minOffset;\n\n    if (topOffsetRatio < 1) {\n      this._stepSize = this._adjustRationIntoRange(topOffsetRatio);\n\n      this._startAnimator();\n    } else {\n      if (bottomOffsetRatio < 1) {\n        this._stepSize = -this._adjustRationIntoRange(bottomOffsetRatio);\n\n        this._startAnimator();\n      } else {\n        this._stopAnimator();\n      }\n    }\n  },\n  _adjustRationIntoRange: function _adjustRationIntoRange(ratio) {\n    return mathUtils.fitIntoRange(Math.round(7 * Math.abs(ratio - 1)), 1, 7);\n  },\n  _updateItemPositions: function _updateItemPositions() {\n    this._updateGhostPosition();\n\n    this._updateOthersPositions();\n  },\n  _updateGhostPosition: function _updateGhostPosition() {\n    if (!this._$ghostItem) {\n      return;\n    }\n\n    translator.move(this._$ghostItem, {\n      top: this._startGhostPosition + this._scrollOffset + this._topOffset\n    });\n  },\n  _updateOthersPositions: function _updateOthersPositions() {\n    var currentIndex = this._findItemIndexByPosition(this._getPointerPosition());\n\n    if (this._lastIndex === currentIndex || this._groupedEnabled && !this._sameParent(currentIndex)) {\n      return;\n    }\n\n    var currentIndexOffset = currentIndex - this._startIndex,\n        currentDirection = mathUtils.sign(currentIndexOffset),\n        minIndex = Math.min(currentIndex, this._lastIndex),\n        maxIndex = Math.max(currentIndex, this._lastIndex);\n\n    for (var itemIndex = minIndex; itemIndex <= maxIndex; itemIndex++) {\n      if (itemIndex === this._startIndex) {\n        continue;\n      }\n\n      var $item = this._list.getItemElementByFlatIndex(itemIndex),\n          itemIndexOffset = itemIndex - this._startIndex,\n          itemDirection = mathUtils.sign(itemIndexOffset),\n          offsetsDifference = Math.abs(itemIndexOffset) <= Math.abs(currentIndexOffset),\n          sameDirections = currentDirection === itemDirection,\n          setupPosition = offsetsDifference && sameDirections,\n          resetPosition = !offsetsDifference || !sameDirections;\n\n      fx.stop($item);\n\n      if (setupPosition) {\n        fx.animate($item, {\n          type: \"slide\",\n          to: {\n            top: this._elementHeight * -currentDirection\n          },\n          duration: 300\n        });\n      }\n\n      if (resetPosition) {\n        fx.animate($item, {\n          type: \"slide\",\n          to: {\n            top: 0\n          },\n          duration: 300\n        });\n      }\n    }\n\n    this._lastIndex = currentIndex;\n  },\n  _sameParent: function _sameParent(index) {\n    var $dragging = this._list.getItemElementByFlatIndex(this._startIndex),\n        $over = this._list.getItemElementByFlatIndex(index);\n\n    return $over.parent().get(0) === $dragging.parent().get(0);\n  },\n  scrollByStep: function scrollByStep() {\n    this._scrollOffset += this._stepSize;\n\n    this._list.scrollBy(this._stepSize);\n\n    this._updateItemPositions();\n  },\n  scrollFinished: function scrollFinished() {\n    var scrollTop = this._scrollTop(),\n        rejectScrollTop = scrollTop <= 0 && this._stepSize < 0,\n        rejectScrollBottom = scrollTop >= this._scrollHeight - this._clientHeight && this._stepSize > 0;\n\n    return rejectScrollTop || rejectScrollBottom;\n  },\n  _dragEndHandler: function _dragEndHandler($itemElement) {\n    this._scrollAnimator.stop();\n\n    fx.animate(this._$ghostItem, {\n      type: \"slide\",\n      to: {\n        top: this._startGhostPosition + this._getLastElementPosition() - this._getDraggingElementPosition()\n      },\n      duration: 300\n    }).done(function () {\n      $itemElement.removeClass(REOREDERING_ITEM_CLASS);\n\n      this._resetPositions();\n\n      this._list.reorderItem($itemElement, this._list.getItemElementByFlatIndex(this._lastIndex));\n\n      this._deleteGhost();\n    }.bind(this));\n  },\n  _deleteGhost: function _deleteGhost() {\n    if (!this._$ghostItem) {\n      return;\n    }\n\n    this._$ghostItem.remove();\n  },\n  _resetPositions: function _resetPositions() {\n    var minIndex = Math.min(this._startIndex, this._lastIndex),\n        maxIndex = Math.max(this._startIndex, this._lastIndex);\n\n    for (var itemIndex = minIndex; itemIndex <= maxIndex; itemIndex++) {\n      var $item = this._list.getItemElementByFlatIndex(itemIndex);\n\n      translator.resetPosition($item);\n    }\n  },\n  _getDragRange: function _getDragRange(draggableIndex) {\n    var items = this._list.itemElements();\n\n    if (!this._groupedEnabled) {\n      return {\n        maxIndex: items.length - 1,\n        minIndex: 0\n      };\n    }\n\n    var oneGroupItems = function oneGroupItems(item1, item2) {\n      return item1.parent().is(item2.parent());\n    };\n\n    var draggableElement = items.eq(draggableIndex);\n    var startGroupIndex = null;\n    var endGroupIndex = null;\n    each(items, function (i) {\n      var inGroup = oneGroupItems(items.eq(i), draggableElement);\n\n      if (null === startGroupIndex && inGroup) {\n        startGroupIndex = i;\n      } else {\n        if (null === endGroupIndex && null !== startGroupIndex && !inGroup) {\n          endGroupIndex = i;\n        }\n      }\n    });\n    return {\n      maxIndex: endGroupIndex || items.length - 1,\n      minIndex: startGroupIndex\n    };\n  },\n  _findItemIndexByPosition: function _findItemIndexByPosition(position) {\n    var _dragRange = this._dragRange,\n        minIndex = _dragRange.minIndex,\n        maxIndex = _dragRange.maxIndex;\n    var currentIndex;\n    var currentPosition;\n\n    while (minIndex <= maxIndex) {\n      currentIndex = (minIndex + maxIndex) / 2 | 0;\n      currentPosition = this._itemPositions[currentIndex]();\n\n      if (currentPosition < position) {\n        minIndex = currentIndex + 1;\n      } else {\n        if (currentPosition > position) {\n          maxIndex = currentIndex - 1;\n        } else {\n          return currentIndex;\n        }\n      }\n    }\n\n    return mathUtils.fitIntoRange(minIndex, 0, Math.max(maxIndex, 0));\n  },\n  getExcludedSelectors: function getExcludedSelectors(selectors) {\n    selectors.push(\".\" + REOREDERING_ITEM_GHOST_CLASS);\n  },\n  dispose: function dispose() {\n    clearTimeout(this._createGhostTimeout);\n    this.callBase.apply(this, arguments);\n  }\n}));","map":null,"metadata":{},"sourceType":"script"}