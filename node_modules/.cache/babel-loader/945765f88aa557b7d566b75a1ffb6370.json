{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/workspaces/ui.scheduler.work_space.js)\r\n * Version: 19.1.6 (build 19263-1729)\r\n * Build date: Fri Sep 20 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../../../core/renderer\"),\n    domAdapter = require(\"../../../core/dom_adapter\"),\n    eventsEngine = require(\"../../../events/core/events_engine\"),\n    dataUtils = require(\"../../../core/element_data\"),\n    dateUtils = require(\"../../../core/utils/date\"),\n    typeUtils = require(\"../../../core/utils/type\"),\n    windowUtils = require(\"../../../core/utils/window\"),\n    getPublicElement = require(\"../../../core/utils/dom\").getPublicElement,\n    extend = require(\"../../../core/utils/extend\").extend,\n    each = require(\"../../../core/utils/iterator\").each,\n    messageLocalization = require(\"../../../localization/message\"),\n    dateLocalization = require(\"../../../localization/date\"),\n    toMs = dateUtils.dateToMilliseconds,\n    Widget = require(\"../../widget/ui.widget\"),\n    abstract = Widget.abstract,\n    noop = require(\"../../../core/utils/common\").noop,\n    isDefined = require(\"../../../core/utils/type\").isDefined,\n    publisherMixin = require(\"../ui.scheduler.publisher_mixin\"),\n    eventUtils = require(\"../../../events/utils\"),\n    pointerEvents = require(\"../../../events/pointer\"),\n    errors = require(\"../../widget/ui.errors\"),\n    clickEvent = require(\"../../../events/click\"),\n    contextMenuEvent = require(\"../../../events/contextmenu\"),\n    dragEvents = require(\"../../../events/drag\"),\n    Scrollable = require(\"../../scroll_view/ui.scrollable\"),\n    HorizontalGroupedStrategy = require(\"./ui.scheduler.work_space.grouped.strategy.horizontal\"),\n    VerticalGroupedStrategy = require(\"./ui.scheduler.work_space.grouped.strategy.vertical\"),\n    tableCreator = require(\"../ui.scheduler.table_creator\"),\n    VerticalShader = require(\"../shaders/ui.scheduler.current_time_shader.vertical\");\n\nvar COMPONENT_CLASS = \"dx-scheduler-work-space\",\n    GROUPED_WORKSPACE_CLASS = \"dx-scheduler-work-space-grouped\",\n    VERTICAL_GROUPED_WORKSPACE_CLASS = \"dx-scheduler-work-space-vertical-grouped\",\n    WORKSPACE_VERTICAL_GROUP_TABLE_CLASS = \"dx-scheduler-work-space-vertical-group-table\",\n    WORKSPACE_WITH_BOTH_SCROLLS_CLASS = \"dx-scheduler-work-space-both-scrollbar\",\n    WORKSPACE_WITH_COUNT_CLASS = \"dx-scheduler-work-space-count\",\n    WORKSPACE_WITH_GROUP_BY_DATE_CLASS = \"dx-scheduler-work-space-group-by-date\",\n    WORKSPACE_WITH_ODD_CELLS_CLASS = \"dx-scheduler-work-space-odd-cells\",\n    WORKSPACE_WITH_OVERLAPPING_CLASS = \"dx-scheduler-work-space-overlapping\",\n    TIME_PANEL_CLASS = \"dx-scheduler-time-panel\",\n    TIME_PANEL_CELL_CLASS = \"dx-scheduler-time-panel-cell\",\n    TIME_PANEL_ROW_CLASS = \"dx-scheduler-time-panel-row\",\n    ALL_DAY_PANEL_CLASS = \"dx-scheduler-all-day-panel\",\n    ALL_DAY_TABLE_CLASS = \"dx-scheduler-all-day-table\",\n    FIXED_CONTAINER_CLASS = \"dx-scheduler-fixed-appointments\",\n    ALL_DAY_CONTAINER_CLASS = \"dx-scheduler-all-day-appointments\",\n    ALL_DAY_TITLE_CLASS = \"dx-scheduler-all-day-title\",\n    ALL_DAY_TITLE_HIDDEN_CLASS = \"dx-scheduler-all-day-title-hidden\",\n    ALL_DAY_TABLE_CELL_CLASS = \"dx-scheduler-all-day-table-cell\",\n    ALL_DAY_TABLE_ROW_CLASS = \"dx-scheduler-all-day-table-row\",\n    WORKSPACE_WITH_ALL_DAY_CLASS = \"dx-scheduler-work-space-all-day\",\n    WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS = \"dx-scheduler-work-space-all-day-collapsed\",\n    WORKSPACE_WITH_MOUSE_SELECTION_CLASS = \"dx-scheduler-work-space-mouse-selection\",\n    HORIZONTAL_SIZES_CLASS = \"dx-scheduler-cell-sizes-horizontal\",\n    VERTICAL_SIZES_CLASS = \"dx-scheduler-cell-sizes-vertical\",\n    HEADER_PANEL_CLASS = \"dx-scheduler-header-panel\",\n    HEADER_PANEL_CELL_CLASS = \"dx-scheduler-header-panel-cell\",\n    HEADER_ROW_CLASS = \"dx-scheduler-header-row\",\n    GROUP_ROW_CLASS = \"dx-scheduler-group-row\",\n    GROUP_HEADER_CLASS = \"dx-scheduler-group-header\",\n    GROUP_HEADER_CONTENT_CLASS = \"dx-scheduler-group-header-content\",\n    DATE_TABLE_CLASS = \"dx-scheduler-date-table\",\n    DATE_TABLE_CELL_CLASS = \"dx-scheduler-date-table-cell\",\n    DATE_TABLE_ROW_CLASS = \"dx-scheduler-date-table-row\",\n    DATE_TABLE_FOCUSED_CELL_CLASS = \"dx-scheduler-focused-cell\",\n    DATE_TABLE_DROPPABLE_CELL_CLASS = \"dx-scheduler-date-table-droppable-cell\",\n    SCHEDULER_HEADER_SCROLLABLE_CLASS = \"dx-scheduler-header-scrollable\",\n    SCHEDULER_SIDEBAR_SCROLLABLE_CLASS = \"dx-scheduler-sidebar-scrollable\",\n    SCHEDULER_DATE_TABLE_SCROLLABLE_CLASS = \"dx-scheduler-date-table-scrollable\",\n    SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME = eventUtils.addNamespace(pointerEvents.down, \"dxSchedulerWorkSpace\"),\n    SCHEDULER_CELL_DXDRAGENTER_EVENT_NAME = eventUtils.addNamespace(dragEvents.enter, \"dxSchedulerDateTable\"),\n    SCHEDULER_CELL_DXDROP_EVENT_NAME = eventUtils.addNamespace(dragEvents.drop, \"dxSchedulerDateTable\"),\n    SCHEDULER_CELL_DXCLICK_EVENT_NAME = eventUtils.addNamespace(clickEvent.name, \"dxSchedulerDateTable\"),\n    SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME = eventUtils.addNamespace(pointerEvents.down, \"dxSchedulerDateTable\"),\n    SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME = eventUtils.addNamespace(pointerEvents.up, \"dxSchedulerDateTable\"),\n    SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME = eventUtils.addNamespace(pointerEvents.move, \"dxSchedulerDateTable\"),\n    CELL_DATA = \"dxCellData\",\n    DATE_TABLE_CELL_BORDER = 1,\n    DATE_TABLE_MIN_CELL_WIDTH = 75,\n    DAY_MS = toMs(\"day\"),\n    HOUR_MS = toMs(\"hour\");\n\nvar formatWeekday = function formatWeekday(date) {\n  return dateLocalization.getDayNames(\"abbreviated\")[date.getDay()];\n};\n\nvar SchedulerWorkSpace = Widget.inherit({\n  _supportedKeys: function _supportedKeys() {\n    var clickHandler = function clickHandler(e) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (this._focusedCells && this._focusedCells.length) {\n        var $itemElement = $(this.option(\"focusedElement\")),\n            $cellElement = $itemElement.length ? $itemElement : this._focusedCells;\n        e.target = this._focusedCells;\n        this._showPopup = true;\n\n        this._cellClickAction({\n          event: e,\n          cellElement: $(this._focusedCells),\n          cellData: this.getCellData($cellElement)\n        });\n      }\n    },\n        arrowPressHandler = function arrowPressHandler(e, cell) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      this._moveToCell(cell, e.shiftKey);\n    };\n\n    return extend(this.callBase(), {\n      enter: clickHandler,\n      space: clickHandler,\n      downArrow: function downArrow(e) {\n        var $cell = this._getCellFromNextRow(\"next\", e.shiftKey);\n\n        arrowPressHandler.call(this, e, $cell);\n      },\n      upArrow: function upArrow(e) {\n        var $cell = this._getCellFromNextRow(\"prev\", e.shiftKey);\n\n        arrowPressHandler.call(this, e, $cell);\n      },\n      rightArrow: function rightArrow(e) {\n        var $rightCell = this._getRightCell(e.shiftKey);\n\n        arrowPressHandler.call(this, e, $rightCell);\n      },\n      leftArrow: function leftArrow(e) {\n        var $leftCell = this._getLeftCell(e.shiftKey);\n\n        arrowPressHandler.call(this, e, $leftCell);\n      }\n    });\n  },\n  _isRTL: function _isRTL() {\n    return this.option(\"rtlEnabled\");\n  },\n  _getFocusedCell: function _getFocusedCell() {\n    return this._$focusedCell || this._$dateTable.find(\".\" + DATE_TABLE_CELL_CLASS).eq(0);\n  },\n  _getAllFocusedCells: function _getAllFocusedCells() {\n    return this._focusedCells || this._$dateTable.find(\".\" + DATE_TABLE_CELL_CLASS).eq(0);\n  },\n  _getCellFromNextRow: function _getCellFromNextRow(direction) {\n    var $currentCell = this._$focusedCell;\n\n    if (isDefined($currentCell)) {\n      var cellIndex = $currentCell.index(),\n          $row = $currentCell.parent(),\n          $cell = $row[direction]().children().eq(cellIndex);\n      $cell = this._checkForViewBounds($cell);\n      return $cell;\n    }\n  },\n  _checkForViewBounds: function _checkForViewBounds($item) {\n    if (!$item.length) {\n      $item = this._$focusedCell;\n    }\n\n    return $item;\n  },\n  _getRightCell: function _getRightCell(isMultiSelection) {\n    if (!isDefined(this._$focusedCell)) {\n      return;\n    }\n\n    var $rightCell,\n        $focusedCell = this._$focusedCell,\n        groupCount = this._getGroupCount(),\n        rowCellCount = isMultiSelection ? this._getCellCount() : this._getTotalCellCount(groupCount),\n        lastIndexInRow = rowCellCount - 1,\n        edgeCellIndex = this._isRTL() ? 0 : lastIndexInRow,\n        currentIndex = $focusedCell.index(),\n        direction = this._isRTL() ? \"prev\" : \"next\";\n\n    if (currentIndex === edgeCellIndex || isMultiSelection && this._isGroupEndCell($focusedCell)) {\n      var $row = $focusedCell.parent(),\n          sign = this._isRTL() ? 1 : -1;\n      $rightCell = $row[direction]().children().eq(currentIndex + sign * lastIndexInRow);\n      $rightCell = this._checkForViewBounds($rightCell);\n    } else {\n      $rightCell = $focusedCell[direction]();\n    }\n\n    return $rightCell;\n  },\n  _isGroupEndCell: function _isGroupEndCell($cell) {\n    var cellsInRow = this._getCellCount(),\n        currentCellIndex = $cell.index(),\n        result = currentCellIndex % cellsInRow;\n\n    return this._isRTL() ? 0 === result : result === cellsInRow - 1;\n  },\n  _getLeftCell: function _getLeftCell(isMultiSelection) {\n    if (!isDefined(this._$focusedCell)) {\n      return;\n    }\n\n    var $leftCell,\n        $focusedCell = this._$focusedCell,\n        groupCount = this._getGroupCount(),\n        rowCellCount = isMultiSelection ? this._getCellCount() : this._getTotalCellCount(groupCount),\n        lastIndexInRow = rowCellCount - 1,\n        edgeCellIndex = this._isRTL() ? lastIndexInRow : 0,\n        currentIndex = $focusedCell.index(),\n        direction = this._isRTL() ? \"next\" : \"prev\";\n\n    if (currentIndex === edgeCellIndex || isMultiSelection && this._isGroupStartCell($focusedCell)) {\n      var $row = $focusedCell.parent(),\n          sign = this._isRTL() ? -1 : 1;\n      $leftCell = $row[direction]().children().eq(currentIndex + sign * lastIndexInRow);\n      $leftCell = this._checkForViewBounds($leftCell);\n    } else {\n      $leftCell = $focusedCell[direction]();\n    }\n\n    return $leftCell;\n  },\n  _isGroupStartCell: function _isGroupStartCell($cell) {\n    var cellsInRow = this._getCellCount(),\n        currentCellIndex = $cell.index(),\n        result = currentCellIndex % cellsInRow;\n\n    return this._isRTL() ? result === cellsInRow - 1 : 0 === result;\n  },\n  _moveToCell: function _moveToCell($cell, isMultiSelection) {\n    isMultiSelection = isMultiSelection && this.option(\"allowMultipleCellSelection\");\n\n    this._setFocusedCell($cell, isMultiSelection);\n\n    this._dateTableScrollable.scrollToElement($cell);\n  },\n  _setFocusedCell: function _setFocusedCell($cell, isMultiSelection) {\n    if (!isDefined($cell) || !$cell.length) {\n      return;\n    }\n\n    this._releaseFocusedCell();\n\n    this._focusedCells = [];\n\n    if (isMultiSelection) {\n      $cell = this._correctCellForGroup($cell);\n      var orientation = \"day\" === this.option(\"type\") && (!this.option(\"groups\").length || \"vertical\" === this.option(\"groupOrientation\")) ? \"vertical\" : \"horizontal\";\n\n      var $targetCells = this._getCellsBetween($cell, this._$prevCell, orientation);\n\n      this._focusedCells = $targetCells.toArray();\n    } else {\n      this._focusedCells = [$cell.get(0)];\n      this._$prevCell = $cell;\n    }\n\n    var $focusedCells = $(this._focusedCells);\n\n    this._toggleFocusClass(true, $focusedCells);\n\n    this.setAria(\"label\", \"Add appointment\", $focusedCells);\n\n    this._toggleFocusedCellClass(true, $cell);\n\n    this._$focusedCell = $cell;\n    var selectedCellData = this.getFocusedCellData();\n    this.option(\"selectedCellData\", selectedCellData);\n\n    this._selectionChangedAction({\n      selectedCellData: selectedCellData\n    });\n  },\n  _correctCellForGroup: function _correctCellForGroup($cell) {\n    var $focusedCell = this._$focusedCell,\n        cellGroupIndex = this._getGroupIndexByCell($cell),\n        focusedCellGroupIndex = this._getGroupIndexByCell($focusedCell),\n        isDifferentTables = this._hasAllDayClass($cell) !== this._hasAllDayClass($focusedCell);\n\n    return focusedCellGroupIndex !== cellGroupIndex || isDifferentTables ? $focusedCell : $cell;\n  },\n  _getCellsBetween: function _getCellsBetween($first, $last, direction) {\n    var isAllDayTable = this._hasAllDayClass($last),\n        $cells = this._getCells(isAllDayTable, direction),\n        firstIndex = $cells.index($first),\n        lastIndex = $cells.index($last);\n\n    if (firstIndex > lastIndex) {\n      var buffer = firstIndex;\n      firstIndex = lastIndex;\n      lastIndex = buffer;\n    }\n\n    $cells = $cells.slice(firstIndex, lastIndex + 1);\n\n    if (this._getGroupCount() > 1) {\n      var result = [],\n          focusedGroupIndex = this._getGroupIndexByCell($first);\n\n      each($cells, function (_, cell) {\n        var groupIndex = this._getGroupIndexByCell($(cell));\n\n        if (focusedGroupIndex === groupIndex) {\n          result.push(cell);\n        }\n      }.bind(this));\n      $cells = $(result);\n    }\n\n    return $cells;\n  },\n  _hasAllDayClass: function _hasAllDayClass($cell) {\n    return $cell.hasClass(ALL_DAY_TABLE_CELL_CLASS);\n  },\n  _getGroupIndexByCell: function _getGroupIndexByCell($cell) {\n    var cellsInRow = this._getCellCount(),\n        currentCellIndex = $cell.index() + 1,\n        groupIndex = Math.ceil(currentCellIndex / cellsInRow);\n\n    return groupIndex;\n  },\n  _toggleFocusedCellClass: function _toggleFocusedCellClass(isFocused, $element) {\n    var $focusTarget = $element && $element.length ? $element : this._focusTarget();\n    $focusTarget.toggleClass(DATE_TABLE_FOCUSED_CELL_CLASS, isFocused);\n  },\n  _releaseFocusedCell: function _releaseFocusedCell($cell) {\n    $cell = $cell || $(this._focusedCells);\n\n    if (isDefined($cell) && $cell.length) {\n      this._toggleFocusClass(false, $cell);\n\n      this._toggleFocusedCellClass(false, $cell);\n\n      this.setAria(\"label\", void 0, $cell);\n    }\n\n    this.option(\"selectedCellData\", []);\n  },\n  _focusInHandler: function _focusInHandler(e) {\n    if ($(e.target).is(this._focusTarget()) && false !== this._isCellClick) {\n      delete this._isCellClick;\n      delete this._contextMenuHandled;\n      this.callBase.apply(this, arguments);\n\n      var $cell = this._getFocusedCell();\n\n      this._setFocusedCell($cell);\n    }\n  },\n  _focusOutHandler: function _focusOutHandler() {\n    this.callBase.apply(this, arguments);\n\n    if (!this._contextMenuHandled) {\n      this._releaseFocusedCell();\n    }\n  },\n  _focusTarget: function _focusTarget() {\n    return this.$element();\n  },\n  _activeStateUnit: \".\" + DATE_TABLE_CELL_CLASS + \", .\" + ALL_DAY_TABLE_CELL_CLASS,\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      currentDate: new Date(),\n      intervalCount: 1,\n      startDate: null,\n      firstDayOfWeek: void 0,\n      startDayHour: 0,\n      endDayHour: 24,\n      hoursInterval: .5,\n      activeStateEnabled: true,\n      hoverStateEnabled: true,\n      groups: [],\n      showAllDayPanel: true,\n      allDayExpanded: false,\n      onCellClick: null,\n      crossScrollingEnabled: false,\n      dataCellTemplate: null,\n      timeCellTemplate: null,\n      resourceCellTemplate: null,\n      dateCellTemplate: null,\n      allowMultipleCellSelection: true,\n      indicatorTime: new Date(),\n      indicatorUpdateInterval: 5 * toMs(\"minute\"),\n      shadeUntilCurrentTime: true,\n      groupOrientation: \"horizontal\",\n      selectedCellData: [],\n      groupByDate: false\n    });\n  },\n  _optionChanged: function _optionChanged(args) {\n    switch (args.name) {\n      case \"dateCellTemplate\":\n      case \"resourceCellTemplate\":\n      case \"dataCellTemplate\":\n      case \"timeCellTemplate\":\n      case \"startDayHour\":\n      case \"endDayHour\":\n      case \"hoursInterval\":\n      case \"firstDayOfWeek\":\n      case \"currentDate\":\n      case \"startDate\":\n        this._cleanWorkSpace();\n\n        break;\n\n      case \"groups\":\n        this._cleanView();\n\n        this._removeAllDayElements();\n\n        this._initGrouping();\n\n        this.repaint();\n        break;\n\n      case \"groupOrientation\":\n        this._initGroupedStrategy();\n\n        this._createAllDayPanelElements();\n\n        this._removeAllDayElements();\n\n        this._cleanWorkSpace();\n\n        this._toggleGroupByDateClass();\n\n        break;\n\n      case \"showAllDayPanel\":\n        if (this._isVerticalGroupedWorkSpace()) {\n          this._cleanView();\n\n          this._removeAllDayElements();\n\n          this._initGrouping();\n\n          this.repaint();\n        } else {\n          this._toggleAllDayVisibility();\n        }\n\n        break;\n\n      case \"allDayExpanded\":\n        this._changeAllDayVisibility();\n\n        this.notifyObserver(\"allDayPanelToggled\");\n\n        this._attachTablesEvents();\n\n        this.headerPanelOffsetRecalculate();\n\n        this._updateScrollable();\n\n        break;\n\n      case \"onSelectionChanged\":\n        this._createSelectionChangedAction();\n\n        break;\n\n      case \"onCellClick\":\n        this._createCellClickAction();\n\n        break;\n\n      case \"onCellContextMenu\":\n        this._attachContextMenuEvent();\n\n        break;\n\n      case \"intervalCount\":\n        this._cleanWorkSpace();\n\n        this._toggleWorkSpaceCountClass();\n\n        this._toggleFixedScrollableClass();\n\n        break;\n\n      case \"groupByDate\":\n        this._cleanWorkSpace();\n\n        this._toggleGroupByDateClass();\n\n        break;\n\n      case \"crossScrollingEnabled\":\n        this._toggleHorizontalScrollClass();\n\n        this._dateTableScrollable.option(this._dateTableScrollableConfig());\n\n        break;\n\n      case \"width\":\n        this.callBase(args);\n\n        this._dimensionChanged();\n\n        break;\n\n      case \"allowMultipleCellSelection\":\n        break;\n\n      case \"selectedCellData\":\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  _cleanWorkSpace: function _cleanWorkSpace() {\n    this._cleanView();\n\n    this._toggleGroupedClass();\n\n    this._toggleWorkSpaceWithOddCells();\n\n    this._renderView();\n  },\n  _init: function _init() {\n    this.callBase();\n\n    this._initGrouping();\n\n    this._toggleHorizontalScrollClass();\n\n    this._toggleWorkSpaceCountClass();\n\n    this._toggleGroupByDateClass();\n\n    this._toggleWorkSpaceWithOddCells();\n\n    this._toggleWorkSpaceOverlappingClass();\n\n    this.$element().addClass(COMPONENT_CLASS).addClass(this._getElementClass());\n  },\n  _initGrouping: function _initGrouping() {\n    this._initGroupedStrategy();\n\n    this._toggleGroupingDirectionClass();\n\n    this._toggleGroupByDateClass();\n  },\n  _initGroupedStrategy: function _initGroupedStrategy() {\n    var strategyName = this.option(\"groups\").length ? this.option(\"groupOrientation\") : this._getDefaultGroupStrategy();\n    var Strategy = \"vertical\" === strategyName ? VerticalGroupedStrategy : HorizontalGroupedStrategy;\n    this._groupedStrategy = new Strategy(this);\n  },\n  _getDefaultGroupStrategy: function _getDefaultGroupStrategy() {\n    return \"horizontal\";\n  },\n  _isVerticalGroupedWorkSpace: function _isVerticalGroupedWorkSpace() {\n    return !!this.option(\"groups\").length && \"vertical\" === this.option(\"groupOrientation\");\n  },\n  _isHorizontalGroupedWorkSpace: function _isHorizontalGroupedWorkSpace() {\n    return !!this.option(\"groups\").length && \"horizontal\" === this.option(\"groupOrientation\");\n  },\n  _toggleHorizontalScrollClass: function _toggleHorizontalScrollClass() {\n    this.$element().toggleClass(WORKSPACE_WITH_BOTH_SCROLLS_CLASS, this.option(\"crossScrollingEnabled\"));\n  },\n  _toggleGroupByDateClass: function _toggleGroupByDateClass() {\n    this.$element().toggleClass(WORKSPACE_WITH_GROUP_BY_DATE_CLASS, this.isGroupedByDate());\n  },\n  _toggleWorkSpaceCountClass: function _toggleWorkSpaceCountClass() {\n    this.$element().toggleClass(WORKSPACE_WITH_COUNT_CLASS, this._isWorkSpaceWithCount());\n  },\n  _isWorkSpaceWithCount: function _isWorkSpaceWithCount() {\n    return this.option(\"intervalCount\") > 1;\n  },\n  _toggleWorkSpaceWithOddCells: function _toggleWorkSpaceWithOddCells() {\n    this.$element().toggleClass(WORKSPACE_WITH_ODD_CELLS_CLASS, this._isWorkspaceWithOddCells());\n  },\n  _isWorkspaceWithOddCells: function _isWorkspaceWithOddCells() {\n    return .5 === this.option(\"hoursInterval\");\n  },\n  _toggleWorkSpaceOverlappingClass: function _toggleWorkSpaceOverlappingClass() {\n    this.$element().toggleClass(WORKSPACE_WITH_OVERLAPPING_CLASS, this._isWorkSpaceWithOverlapping());\n  },\n  _isWorkSpaceWithOverlapping: function _isWorkSpaceWithOverlapping() {\n    return null !== this.invoke(\"getMaxAppointmentsPerCell\");\n  },\n  _toggleGroupingDirectionClass: function _toggleGroupingDirectionClass() {\n    this.$element().toggleClass(VERTICAL_GROUPED_WORKSPACE_CLASS, this._isVerticalGroupedWorkSpace());\n  },\n  _getRealGroupOrientation: function _getRealGroupOrientation() {\n    return this._isVerticalGroupedWorkSpace() ? \"vertical\" : \"horizontal\";\n  },\n  _getTimePanelClass: function _getTimePanelClass() {\n    return TIME_PANEL_CLASS;\n  },\n  _getDateTableClass: function _getDateTableClass() {\n    return DATE_TABLE_CLASS;\n  },\n  _getDateTableRowClass: function _getDateTableRowClass() {\n    return DATE_TABLE_ROW_CLASS;\n  },\n  _getDateTableCellClass: function _getDateTableCellClass(i, j) {\n    var cellClass = DATE_TABLE_CELL_CLASS + \" \" + HORIZONTAL_SIZES_CLASS + \" \" + VERTICAL_SIZES_CLASS;\n    return this._needApplyLastGroupCellClass() ? this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, j + 1, i, j) : cellClass;\n  },\n  _needApplyLastGroupCellClass: function _needApplyLastGroupCellClass() {\n    return true;\n  },\n  _getGroupRowClass: function _getGroupRowClass() {\n    return GROUP_ROW_CLASS;\n  },\n  _getGroupHeaderClass: function _getGroupHeaderClass(i) {\n    var cellClass = GROUP_HEADER_CLASS;\n    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i + 1);\n  },\n  _getGroupHeaderContentClass: function _getGroupHeaderContentClass() {\n    return GROUP_HEADER_CONTENT_CLASS;\n  },\n  _initWorkSpaceUnits: function _initWorkSpaceUnits() {\n    this._$headerPanel = $(\"<table>\");\n    this._$thead = $(\"<thead>\").appendTo(this._$headerPanel);\n    this._$fixedContainer = $(\"<div>\").addClass(FIXED_CONTAINER_CLASS);\n    this._$allDayContainer = $(\"<div>\").addClass(ALL_DAY_CONTAINER_CLASS);\n\n    this._initAllDayPanelElements();\n\n    this._createAllDayPanelElements();\n\n    this._$timePanel = $(\"<table>\").addClass(this._getTimePanelClass());\n    this._$dateTable = $(\"<table>\");\n    this._$groupTable = $(\"<table>\").addClass(WORKSPACE_VERTICAL_GROUP_TABLE_CLASS);\n  },\n  _initAllDayPanelElements: function _initAllDayPanelElements() {\n    this._allDayTitles = [];\n    this._allDayTables = [];\n    this._allDayPanels = [];\n  },\n  _createAllDayPanelElements: function _createAllDayPanelElements() {\n    var groupCount = this._getGroupCount();\n\n    if (this._isVerticalGroupedWorkSpace() && 0 !== groupCount) {\n      for (var i = 0; i < groupCount; i++) {\n        var $allDayTitle = $(\"<div>\").addClass(ALL_DAY_TITLE_CLASS).text(messageLocalization.format(\"dxScheduler-allDay\"));\n\n        this._allDayTitles.push($allDayTitle);\n\n        this._$allDayTable = $(\"<table>\");\n\n        this._allDayTables.push(this._$allDayTable);\n\n        this._$allDayPanel = $(\"<div>\").addClass(ALL_DAY_PANEL_CLASS).append(this._$allDayTable);\n\n        this._allDayPanels.push(this._$allDayPanel);\n      }\n    } else {\n      this._$allDayTitle = $(\"<div>\").addClass(ALL_DAY_TITLE_CLASS).text(messageLocalization.format(\"dxScheduler-allDay\")).appendTo(this.$element());\n      this._$allDayTable = $(\"<table>\");\n      this._$allDayPanel = $(\"<div>\").addClass(ALL_DAY_PANEL_CLASS).append(this._$allDayTable);\n    }\n  },\n  _initDateTableScrollable: function _initDateTableScrollable() {\n    var $dateTableScrollable = $(\"<div>\").addClass(SCHEDULER_DATE_TABLE_SCROLLABLE_CLASS);\n    this._dateTableScrollable = this._createComponent($dateTableScrollable, Scrollable, this._dateTableScrollableConfig());\n  },\n  _dateTableScrollableConfig: function _dateTableScrollableConfig() {\n    var config = {\n      useKeyboard: false,\n      useNative: false,\n      bounceEnabled: false,\n      updateManually: true,\n      pushBackValue: 0\n    };\n\n    if (this._needCreateCrossScrolling()) {\n      config = extend(config, this._createCrossScrollingConfig());\n    }\n\n    return config;\n  },\n  _createCrossScrollingConfig: function _createCrossScrollingConfig() {\n    var headerScrollableOnScroll,\n        sidebarScrollableOnScroll,\n        config = {};\n    config.direction = \"both\";\n\n    config.onStart = function (e) {\n      if (this._headerScrollable) {\n        headerScrollableOnScroll = this._headerScrollable.option(\"onScroll\");\n\n        this._headerScrollable.option(\"onScroll\", void 0);\n      }\n\n      if (this._sidebarScrollable) {\n        sidebarScrollableOnScroll = this._sidebarScrollable.option(\"onScroll\");\n\n        this._sidebarScrollable.option(\"onScroll\", void 0);\n      }\n    }.bind(this);\n\n    config.onScroll = function (e) {\n      this._sidebarScrollable && this._sidebarScrollable.scrollTo({\n        top: e.scrollOffset.top\n      });\n      this._headerScrollable && this._headerScrollable.scrollTo({\n        left: e.scrollOffset.left\n      });\n    }.bind(this);\n\n    config.onEnd = function () {\n      this.notifyObserver(\"updateResizableArea\", {});\n      this._headerScrollable && this._headerScrollable.option(\"onScroll\", headerScrollableOnScroll);\n      this._sidebarScrollable && this._sidebarScrollable.option(\"onScroll\", sidebarScrollableOnScroll);\n    }.bind(this);\n\n    return config;\n  },\n  _createWorkSpaceElements: function _createWorkSpaceElements() {\n    if (this.option(\"crossScrollingEnabled\")) {\n      this._createWorkSpaceScrollableElements();\n    } else {\n      this._createWorkSpaceStaticElements();\n    }\n  },\n  _createWorkSpaceStaticElements: function _createWorkSpaceStaticElements() {\n    if (this._isVerticalGroupedWorkSpace()) {\n      this._dateTableScrollable.$content().append(this._$allDayContainer, this._$groupTable, this._$timePanel, this._$dateTable);\n\n      this.$element().append(this._$fixedContainer, this._$headerPanel, this._dateTableScrollable.$element());\n    } else {\n      this._dateTableScrollable.$content().append(this._$timePanel, this._$dateTable);\n\n      this.$element().append(this._$fixedContainer, this._$headerPanel, this._$allDayContainer, this._$allDayPanel, this._dateTableScrollable.$element());\n    }\n  },\n  _createWorkSpaceScrollableElements: function _createWorkSpaceScrollableElements() {\n    this.$element().append(this._$fixedContainer);\n\n    this._createHeaderScrollable();\n\n    this._createSidebarScrollable();\n\n    this.$element().append(this._dateTableScrollable.$element());\n\n    this._headerScrollable.$content().append(this._$headerPanel);\n\n    this._dateTableScrollable.$content().append(this._$dateTable);\n\n    if (this._isVerticalGroupedWorkSpace()) {\n      this._dateTableScrollable.$content().prepend(this._$allDayContainer);\n\n      this._sidebarScrollable.$content().append(this._$groupTable, this._$timePanel);\n    } else {\n      this._headerScrollable.$content().append(this._$allDayContainer, this._$allDayPanel);\n    }\n\n    this._sidebarScrollable.$content().append(this._$timePanel);\n  },\n  _createHeaderScrollable: function _createHeaderScrollable() {\n    var $headerScrollable = $(\"<div>\").addClass(SCHEDULER_HEADER_SCROLLABLE_CLASS).appendTo(this.$element());\n    this._headerScrollable = this._createComponent($headerScrollable, Scrollable, this._headerScrollableConfig());\n  },\n  _headerScrollableConfig: function _headerScrollableConfig() {\n    var dateTableScrollableOnScroll;\n    var config = {\n      useKeyboard: false,\n      showScrollbar: false,\n      direction: \"horizontal\",\n      useNative: false,\n      updateManually: true,\n      bounceEnabled: false,\n      pushBackValue: 0,\n      onStart: function (e) {\n        dateTableScrollableOnScroll = this._dateTableScrollable.option(\"onScroll\");\n\n        this._dateTableScrollable.option(\"onScroll\", void 0);\n      }.bind(this),\n      onScroll: function (e) {\n        this._dateTableScrollable.scrollTo({\n          left: e.scrollOffset.left\n        });\n      }.bind(this),\n      onEnd: function (e) {\n        this._dateTableScrollable.option(\"onScroll\", dateTableScrollableOnScroll);\n      }.bind(this)\n    };\n    return config;\n  },\n  _createSidebarScrollable: function _createSidebarScrollable() {\n    var dateTableScrollableOnScroll,\n        $timePanelScrollable = $(\"<div>\").addClass(SCHEDULER_SIDEBAR_SCROLLABLE_CLASS).appendTo(this.$element());\n    this._sidebarScrollable = this._createComponent($timePanelScrollable, Scrollable, {\n      useKeyboard: false,\n      showScrollbar: false,\n      direction: \"vertical\",\n      useNative: false,\n      updateManually: true,\n      bounceEnabled: false,\n      pushBackValue: 0,\n      onStart: function (e) {\n        dateTableScrollableOnScroll = this._dateTableScrollable.option(\"onScroll\");\n\n        this._dateTableScrollable.option(\"onScroll\", void 0);\n      }.bind(this),\n      onScroll: function (e) {\n        this._dateTableScrollable.scrollTo({\n          top: e.scrollOffset.top\n        });\n      }.bind(this),\n      onEnd: function (e) {\n        this._dateTableScrollable.option(\"onScroll\", dateTableScrollableOnScroll);\n      }.bind(this)\n    });\n  },\n  _visibilityChanged: function _visibilityChanged(visible) {\n    if (visible && this._isVerticalGroupedWorkSpace()) {\n      this._setHorizontalGroupHeaderCellsHeight();\n    }\n\n    if (visible && this._needCreateCrossScrolling()) {\n      this._setTableSizes();\n    }\n  },\n  _attachTableClasses: function _attachTableClasses() {\n    this._addTableClass(this._$dateTable, this._getDateTableClass());\n\n    if (this._isVerticalGroupedWorkSpace()) {\n      var groupCount = this._getGroupCount();\n\n      for (var i = 0; i < groupCount; i++) {\n        this._addTableClass(this._allDayTables[i], ALL_DAY_TABLE_CLASS);\n      }\n    } else {\n      this._addTableClass(this._$allDayTable, ALL_DAY_TABLE_CLASS);\n    }\n  },\n  _attachHeaderTableClasses: function _attachHeaderTableClasses() {\n    this._addTableClass(this._$headerPanel, HEADER_PANEL_CLASS);\n  },\n  _addTableClass: function _addTableClass($el, className) {\n    $el && !$el.hasClass(className) && $el.addClass(className);\n  },\n  _setTableSizes: function _setTableSizes() {\n    this._attachTableClasses();\n\n    var cellWidth = this.getCellWidth();\n\n    if (cellWidth < this.getCellMinWidth()) {\n      cellWidth = this.getCellMinWidth();\n    }\n\n    var minWidth = this.getWorkSpaceMinWidth(),\n        $headerCells = this._$headerPanel.find(\"tr\").last().find(\"th\");\n\n    var width = cellWidth * $headerCells.length;\n\n    if (width < minWidth) {\n      width = minWidth;\n    }\n\n    this._$headerPanel.width(width);\n\n    this._$dateTable.width(width);\n\n    this._$allDayTable && this._$allDayTable.width(width);\n\n    this._attachHeaderTableClasses();\n\n    if (this._isVerticalGroupedWorkSpace()) {\n      this._setHorizontalGroupHeaderCellsHeight();\n    }\n  },\n  getWorkSpaceMinWidth: function getWorkSpaceMinWidth() {\n    return this._groupedStrategy.getWorkSpaceMinWidth();\n  },\n  _dimensionChanged: function _dimensionChanged() {\n    if (this.option(\"crossScrollingEnabled\")) {\n      this._setTableSizes();\n    }\n\n    this.headerPanelOffsetRecalculate();\n\n    this._cleanCellDataCache();\n\n    this._cleanAllowedPositions();\n  },\n  _needCreateCrossScrolling: function _needCreateCrossScrolling() {\n    return this.option(\"crossScrollingEnabled\");\n  },\n  _getElementClass: noop,\n  _getRowCount: noop,\n  _getCellCount: noop,\n  _initMarkup: function _initMarkup() {\n    this._initWorkSpaceUnits();\n\n    this._initDateTableScrollable();\n\n    this._createWorkSpaceElements();\n\n    this.callBase();\n\n    if (!this.option(\"crossScrollingEnabled\")) {\n      this._attachTableClasses();\n\n      this._attachHeaderTableClasses();\n    }\n\n    this._toggleGroupedClass();\n\n    this._toggleFixedScrollableClass();\n\n    this._renderView();\n\n    this._attachEvents();\n\n    this._setFocusOnCellByOption(this.option(\"selectedCellData\"));\n  },\n  _render: function _render() {\n    this.callBase();\n\n    this._renderDateTimeIndication();\n\n    this._setIndicationUpdateInterval();\n  },\n  _toggleGroupedClass: function _toggleGroupedClass() {\n    this.$element().toggleClass(GROUPED_WORKSPACE_CLASS, this._getGroupCount() > 0);\n  },\n  _toggleFixedScrollableClass: noop,\n  _renderView: function _renderView() {\n    this._setFirstViewDate();\n\n    this._applyCellTemplates(this._renderGroupHeader());\n\n    this._renderDateHeader();\n\n    this._renderTimePanel();\n\n    if (this._isVerticalGroupedWorkSpace()) {\n      var groupCount = this._getGroupCount();\n\n      for (var i = 0; i < groupCount; i++) {\n        this._renderAllDayPanel(i);\n      }\n    }\n\n    this._renderDateTable();\n\n    this._renderAllDayPanel();\n\n    this._updateGroupTableHeight();\n\n    this._shader = new VerticalShader();\n  },\n  _updateGroupTableHeight: function _updateGroupTableHeight() {\n    if (this._isVerticalGroupedWorkSpace() && windowUtils.hasWindow()) {\n      this._setHorizontalGroupHeaderCellsHeight();\n    }\n  },\n  _renderDateTimeIndication: noop,\n  _setIndicationUpdateInterval: noop,\n  _refreshDateTimeIndication: noop,\n  _setFocusOnCellByOption: function _setFocusOnCellByOption(data) {\n    var cells = [];\n\n    this._releaseFocusedCell();\n\n    for (var i = 0; i < data.length; i++) {\n      var groups = data[i].groups,\n          groupIndex = this.option(\"groups\").length && groups ? this._getGroupIndexByResourceId(groups) : 0,\n          allDay = !!data[i].allDay,\n          coordinates = this.getCoordinatesByDate(data[i].startDate, groupIndex, allDay),\n          $cell = this._getCellByCoordinates(coordinates, groupIndex);\n\n      if (isDefined($cell)) {\n        this._toggleFocusClass(true, $cell);\n\n        cells.push($cell.get(0));\n      }\n    }\n\n    this._focusedCells = cells;\n  },\n  _getGroupIndexByResourceId: function _getGroupIndexByResourceId(id) {\n    var groups = this.option(\"groups\"),\n        groupKey = Object.keys(id)[0],\n        groupValue = id[groupKey],\n        tree = this.invoke(\"createResourcesTree\", groups),\n        index = 0;\n\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i].name === groupKey && tree[i].value === groupValue) {\n        index = tree[i].leafIndex;\n      }\n    }\n\n    return index;\n  },\n  _setFirstViewDate: function _setFirstViewDate() {\n    var firstDayOfWeek = isDefined(this._firstDayOfWeek()) ? this._firstDayOfWeek() : dateLocalization.firstDayOfWeekIndex();\n    this._firstViewDate = dateUtils.getFirstWeekDate(this._getViewStartByOptions(), firstDayOfWeek);\n\n    this._setStartDayHour(this._firstViewDate);\n  },\n  _getViewStartByOptions: function _getViewStartByOptions() {\n    if (!this.option(\"startDate\")) {\n      return this.option(\"currentDate\");\n    } else {\n      var startDate = dateUtils.trimTime(this._getStartViewDate()),\n          currentDate = this.option(\"currentDate\"),\n          diff = startDate.getTime() <= currentDate.getTime() ? 1 : -1,\n          endDate = new Date(startDate.getTime() + this._getIntervalDuration() * diff);\n\n      while (!this._dateInRange(currentDate, startDate, endDate, diff)) {\n        startDate = endDate;\n        endDate = new Date(startDate.getTime() + this._getIntervalDuration() * diff);\n      }\n\n      return diff > 0 ? startDate : endDate;\n    }\n  },\n  _getHeaderDate: function _getHeaderDate() {\n    return this.getStartViewDate();\n  },\n  _getStartViewDate: function _getStartViewDate() {\n    return this.option(\"startDate\");\n  },\n  _dateInRange: function _dateInRange(date, startDate, endDate, diff) {\n    return diff > 0 ? dateUtils.dateInRange(date, startDate, new Date(endDate.getTime() - 1)) : dateUtils.dateInRange(date, endDate, startDate, \"date\");\n  },\n  _getIntervalDuration: function _getIntervalDuration() {\n    return toMs(\"day\") * this.option(\"intervalCount\");\n  },\n  _setStartDayHour: function _setStartDayHour(date) {\n    var startDayHour = this.option(\"startDayHour\");\n\n    if (isDefined(startDayHour)) {\n      date.setHours(startDayHour, startDayHour % 1 * 60, 0, 0);\n    }\n  },\n  _firstDayOfWeek: function _firstDayOfWeek() {\n    return this.option(\"firstDayOfWeek\");\n  },\n  _attachEvents: function _attachEvents() {\n    this._createSelectionChangedAction();\n\n    this._attachClickEvent();\n\n    this._attachContextMenuEvent();\n  },\n  _attachClickEvent: function _attachClickEvent() {\n    var that = this;\n\n    var pointerDownAction = this._createAction(function (e) {\n      that._pointerDownHandler(e.event);\n    });\n\n    this._createCellClickAction();\n\n    var cellSelector = \".\" + DATE_TABLE_CELL_CLASS + \",.\" + ALL_DAY_TABLE_CELL_CLASS;\n    var $element = this.$element();\n    eventsEngine.off($element, SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME);\n    eventsEngine.off($element, SCHEDULER_CELL_DXCLICK_EVENT_NAME);\n    eventsEngine.on($element, SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME, function (e) {\n      if (eventUtils.isMouseEvent(e) && e.which > 1) {\n        e.preventDefault();\n        return;\n      }\n\n      pointerDownAction({\n        event: e\n      });\n    });\n    eventsEngine.on($element, SCHEDULER_CELL_DXCLICK_EVENT_NAME, cellSelector, function (e) {\n      var $cell = $(e.target);\n\n      that._cellClickAction({\n        event: e,\n        cellElement: getPublicElement($cell),\n        cellData: that.getCellData($cell)\n      });\n    });\n  },\n  _createCellClickAction: function _createCellClickAction() {\n    var that = this;\n    this._cellClickAction = this._createActionByOption(\"onCellClick\", {\n      afterExecute: function afterExecute(e) {\n        that._moveToClosestNonStub(e.args[0].event);\n      }\n    });\n  },\n  _createSelectionChangedAction: function _createSelectionChangedAction() {\n    this._selectionChangedAction = this._createActionByOption(\"onSelectionChanged\");\n  },\n  _moveToClosestNonStub: function _moveToClosestNonStub(e) {\n    var $target = $(e.target);\n\n    if (this._showPopup && this._hasFocusClass($target)) {\n      delete this._showPopup;\n\n      this._showAddAppointmentPopup($target);\n    }\n  },\n  _pointerDownHandler: function _pointerDownHandler(e) {\n    var $target = $(e.target);\n\n    if (!$target.hasClass(DATE_TABLE_CELL_CLASS) && !$target.hasClass(ALL_DAY_TABLE_CELL_CLASS)) {\n      this._isCellClick = false;\n      return;\n    }\n\n    this._isCellClick = true;\n\n    if ($target.hasClass(DATE_TABLE_FOCUSED_CELL_CLASS)) {\n      this._showPopup = true;\n    } else {\n      this._setFocusedCell($target);\n    }\n  },\n  _showAddAppointmentPopup: function _showAddAppointmentPopup($cell) {\n    var firstCellData = this.getCellData($cell.first()),\n        lastCellData = this.getCellData($cell.last());\n    var args = {\n      startDate: firstCellData.startDate,\n      endDate: lastCellData.endDate\n    };\n\n    if (isDefined(lastCellData.allDay)) {\n      args.allDay = lastCellData.allDay;\n    }\n\n    extend(args, lastCellData.groups);\n    this.notifyObserver(\"showAddAppointmentPopup\", args);\n  },\n  _attachContextMenuEvent: function _attachContextMenuEvent() {\n    this._createContextMenuAction();\n\n    var cellSelector = \".\" + DATE_TABLE_CELL_CLASS + \",.\" + ALL_DAY_TABLE_CELL_CLASS,\n        $element = this.$element(),\n        eventName = eventUtils.addNamespace(contextMenuEvent.name, this.NAME);\n    eventsEngine.off($element, eventName, cellSelector);\n    eventsEngine.on($element, eventName, cellSelector, this._contextMenuHandler.bind(this));\n  },\n  _contextMenuHandler: function _contextMenuHandler(e) {\n    var $cell = $(e.target);\n\n    this._contextMenuAction({\n      event: e,\n      cellElement: getPublicElement($cell),\n      cellData: this.getCellData($cell)\n    });\n\n    this._contextMenuHandled = true;\n  },\n  _createContextMenuAction: function _createContextMenuAction() {\n    this._contextMenuAction = this._createActionByOption(\"onCellContextMenu\");\n  },\n  _getGroupHeaderContainer: function _getGroupHeaderContainer() {\n    if (this._isVerticalGroupedWorkSpace()) {\n      return this._$groupTable;\n    }\n\n    return this._$thead;\n  },\n  _getDateHeaderContainer: function _getDateHeaderContainer() {\n    return this._$thead;\n  },\n  _renderGroupHeader: function _renderGroupHeader() {\n    var $container = this._getGroupHeaderContainer(),\n        groupCount = this._getGroupCount(),\n        cellTemplates = [];\n\n    if (groupCount) {\n      var groupRows = this._makeGroupRows(this.option(\"groups\"), this.option(\"groupByDate\"));\n\n      this._attachGroupCountAttr(groupCount, groupRows);\n\n      $container.append(groupRows.elements);\n      cellTemplates = groupRows.cellTemplates;\n    } else {\n      this._detachGroupCountAttr();\n    }\n\n    return cellTemplates;\n  },\n  _applyCellTemplates: function _applyCellTemplates(templates) {\n    templates.forEach(function (template) {\n      template();\n    });\n  },\n  _detachGroupCountAttr: function _detachGroupCountAttr() {\n    var groupedAttr = this._groupedStrategy.getGroupCountAttr();\n\n    this.$element().removeAttr(groupedAttr.attr);\n  },\n  _attachGroupCountAttr: function _attachGroupCountAttr(groupRowCount, groupRows) {\n    var groupedAttr = this._groupedStrategy.getGroupCountAttr(groupRowCount, groupRows);\n\n    this.$element().attr(groupedAttr.attr, groupedAttr.count);\n  },\n  headerPanelOffsetRecalculate: function headerPanelOffsetRecalculate() {\n    if (!this.option(\"resourceCellTemplate\") && !this.option(\"dateCellTemplate\")) {\n      return;\n    }\n\n    var headerPanelHeight = this.getHeaderPanelHeight(),\n        headerHeight = this.invoke(\"getHeaderHeight\"),\n        allDayPanelHeight = this.supportAllDayRow() && this.option(\"showAllDayPanel\") ? this._groupedStrategy.getAllDayTableHeight() : 0;\n    headerPanelHeight && this._headerScrollable && this._headerScrollable.$element().height(headerPanelHeight + allDayPanelHeight);\n    headerPanelHeight && this._dateTableScrollable.$element().css({\n      paddingBottom: allDayPanelHeight + headerPanelHeight + \"px\",\n      marginBottom: -1 * (parseInt(headerPanelHeight, 10) + allDayPanelHeight) + \"px\"\n    });\n    headerPanelHeight && this._sidebarScrollable && this._sidebarScrollable.$element().css({\n      paddingBottom: allDayPanelHeight + headerPanelHeight + \"px\",\n      marginBottom: -1 * (parseInt(headerPanelHeight, 10) + allDayPanelHeight) + \"px\"\n    });\n    this._$allDayTitle && this._$allDayTitle.css(\"top\", headerHeight + headerPanelHeight + \"px\");\n  },\n  _makeGroupRows: function _makeGroupRows(groups, groupByDate) {\n    var tableCreatorStrategy = this._isVerticalGroupedWorkSpace() ? tableCreator.VERTICAL : tableCreator.HORIZONTAL;\n    return tableCreator.makeGroupedTable(tableCreatorStrategy, groups, {\n      groupHeaderRowClass: this._getGroupRowClass(),\n      groupRowClass: this._getGroupRowClass(),\n      groupHeaderClass: this._getGroupHeaderClass.bind(this),\n      groupHeaderContentClass: this._getGroupHeaderContentClass()\n    }, this._getCellCount() || 1, this.option(\"resourceCellTemplate\"), this._getGroupCount(), groupByDate);\n  },\n  _getDateHeaderTemplate: function _getDateHeaderTemplate() {\n    return this.option(\"dateCellTemplate\");\n  },\n  _renderDateHeader: function _renderDateHeader() {\n    var i,\n        j,\n        $container = this._getDateHeaderContainer(),\n        $headerRow = $(\"<tr>\").addClass(HEADER_ROW_CLASS),\n        count = this._getCellCount(),\n        cellTemplate = this._getDateHeaderTemplate(),\n        repeatCount = this._calculateHeaderCellRepeatCount(),\n        templateCallbacks = [],\n        colspan = this.option(\"groupByDate\") ? this._getGroupCount() : 1,\n        groupByDate = this.option(\"groupByDate\");\n\n    if (!groupByDate) {\n      for (j = 0; j < repeatCount; j++) {\n        for (i = 0; i < count; i++) {\n          this._renderDateHeaderTemplate($headerRow, i, j * repeatCount + i, cellTemplate, templateCallbacks);\n        }\n      }\n\n      $container.append($headerRow);\n    } else {\n      for (i = 0; i < count; i++) {\n        var $cell = this._renderDateHeaderTemplate($headerRow, i, i * repeatCount, cellTemplate, templateCallbacks);\n\n        $cell.attr(\"colSpan\", colspan);\n      }\n\n      $container.prepend($headerRow);\n    }\n\n    this._applyCellTemplates(templateCallbacks);\n\n    return $headerRow;\n  },\n  _renderDateHeaderTemplate: function _renderDateHeaderTemplate($container, i, calculatedIndex, cellTemplate, templateCallbacks) {\n    var text = this._getHeaderText(i),\n        $cell = $(\"<th>\").addClass(this._getHeaderPanelCellClass(i)).attr(\"title\", text);\n\n    if (cellTemplate && cellTemplate.render) {\n      templateCallbacks.push(cellTemplate.render.bind(cellTemplate, {\n        model: {\n          text: text,\n          date: this._getDateByIndex(i)\n        },\n        index: calculatedIndex,\n        container: getPublicElement($cell)\n      }));\n    } else {\n      $cell.text(text);\n    }\n\n    $container.append($cell);\n    return $cell;\n  },\n  _getHeaderPanelCellClass: function _getHeaderPanelCellClass(i) {\n    var cellClass = HEADER_PANEL_CELL_CLASS + \" \" + HORIZONTAL_SIZES_CLASS;\n    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i + 1);\n  },\n  _calculateHeaderCellRepeatCount: function _calculateHeaderCellRepeatCount() {\n    return this._groupedStrategy.calculateHeaderCellRepeatCount();\n  },\n  _renderAllDayPanel: function _renderAllDayPanel(index) {\n    var cellCount = this._getCellCount();\n\n    if (!this._isVerticalGroupedWorkSpace()) {\n      cellCount *= this._getGroupCount() || 1;\n    }\n\n    var cellTemplates = this._renderTableBody({\n      container: this._allDayPanels.length ? getPublicElement(this._allDayTables[index]) : getPublicElement(this._$allDayTable),\n      rowCount: 1,\n      cellCount: cellCount,\n      cellClass: this._getAllDayPanelCellClass.bind(this),\n      rowClass: ALL_DAY_TABLE_ROW_CLASS,\n      cellTemplate: this.option(\"dataCellTemplate\"),\n      getCellData: this._getAllDayCellData.bind(this),\n      groupIndex: index\n    }, true);\n\n    this._toggleAllDayVisibility();\n\n    this._applyCellTemplates(cellTemplates);\n  },\n  _getAllDayPanelCellClass: function _getAllDayPanelCellClass(i, j) {\n    var cellClass = ALL_DAY_TABLE_CELL_CLASS + \" \" + HORIZONTAL_SIZES_CLASS;\n    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, j + 1);\n  },\n  _getAllDayCellData: function _getAllDayCellData(cell, rowIndex, cellIndex, groupIndex) {\n    var startDate = this._getDateByCellIndexes(rowIndex, cellIndex);\n\n    startDate = dateUtils.trimTime(startDate);\n    var data = {\n      startDate: startDate,\n      endDate: new Date(startDate.getTime() + DAY_MS),\n      allDay: true\n    };\n\n    var groups = this._getCellGroups(groupIndex || this._getGroupIndex(rowIndex, cellIndex));\n\n    if (groups.length) {\n      data.groups = {};\n    }\n\n    for (var i = 0; i < groups.length; i++) {\n      data.groups[groups[i].name] = groups[i].id;\n    }\n\n    return {\n      key: CELL_DATA,\n      value: data\n    };\n  },\n  _toggleAllDayVisibility: function _toggleAllDayVisibility() {\n    var showAllDayPanel = this.option(\"showAllDayPanel\");\n\n    this._$allDayPanel.toggle(showAllDayPanel);\n\n    this._$allDayTitle && this._$allDayTitle.toggleClass(ALL_DAY_TITLE_HIDDEN_CLASS, !showAllDayPanel);\n    this.$element().toggleClass(WORKSPACE_WITH_ALL_DAY_CLASS, showAllDayPanel);\n\n    this._changeAllDayVisibility();\n\n    this._updateScrollable();\n  },\n  _changeAllDayVisibility: function _changeAllDayVisibility() {\n    this.$element().toggleClass(WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS, !this.option(\"allDayExpanded\") && this.option(\"showAllDayPanel\"));\n  },\n  _updateScrollable: function _updateScrollable() {\n    this._dateTableScrollable.update();\n\n    this._headerScrollable && this._headerScrollable.update();\n    this._sidebarScrollable && this._sidebarScrollable.update();\n  },\n  _renderTimePanel: function _renderTimePanel() {\n    var repeatCount = this._groupedStrategy.calculateTimeCellRepeatCount();\n\n    this._renderTableBody({\n      container: getPublicElement(this._$timePanel),\n      rowCount: this._getTimePanelRowCount() * repeatCount,\n      cellCount: 1,\n      cellClass: this._getTimeCellClass.bind(this),\n      rowClass: TIME_PANEL_ROW_CLASS,\n      cellTemplate: this.option(\"timeCellTemplate\"),\n      getCellText: this._getTimeText.bind(this),\n      getCellDate: this._getTimeCellDate.bind(this),\n      groupCount: this._getGroupCount(),\n      allDayElements: this._insertAllDayRowsIntoDateTable() ? this._allDayTitles : void 0\n    });\n  },\n  _getTimePanelRowCount: function _getTimePanelRowCount() {\n    return this._getCellCountInDay();\n  },\n  _getCellCountInDay: function _getCellCountInDay() {\n    return Math.ceil(this._calculateDayDuration() / this.option(\"hoursInterval\"));\n  },\n  _calculateDayDuration: function _calculateDayDuration() {\n    return this.option(\"endDayHour\") - this.option(\"startDayHour\");\n  },\n  _getTimeCellClass: function _getTimeCellClass(i) {\n    var cellClass = TIME_PANEL_CELL_CLASS + \" \" + VERTICAL_SIZES_CLASS;\n    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i, i);\n  },\n  _getTimeText: function _getTimeText(i) {\n    var startViewDate = this._getTimeCellDate(i),\n        index = i % this._getRowCount();\n\n    if (index % 2 === 0) {\n      return dateLocalization.format(startViewDate, \"shorttime\");\n    }\n\n    return \"\";\n  },\n  _getTimeCellDate: function _getTimeCellDate(i) {\n    var startViewDate = new Date(this.getStartViewDate()),\n        timeCellDuration = Math.round(this.getCellDuration()),\n        lastCellInDay = this._calculateDayDuration() / this.option(\"hoursInterval\");\n    startViewDate.setMilliseconds(startViewDate.getMilliseconds() + timeCellDuration * (i % lastCellInDay));\n    return startViewDate;\n  },\n  _renderDateTable: function _renderDateTable() {\n    var groupCount = this._getGroupCount();\n\n    this._renderTableBody({\n      container: getPublicElement(this._$dateTable),\n      rowCount: this._getTotalRowCount(groupCount),\n      cellCount: this._getTotalCellCount(groupCount),\n      cellClass: this._getDateTableCellClass.bind(this),\n      rowClass: this._getDateTableRowClass(),\n      cellTemplate: this.option(\"dataCellTemplate\"),\n      getCellData: this._getCellData.bind(this),\n      allDayElements: this._insertAllDayRowsIntoDateTable() ? this._allDayPanels : void 0,\n      groupCount: groupCount,\n      groupByDate: this.option(\"groupByDate\")\n    });\n\n    this._attachTablesEvents();\n  },\n  _insertAllDayRowsIntoDateTable: function _insertAllDayRowsIntoDateTable() {\n    return this._groupedStrategy.insertAllDayRowsIntoDateTable();\n  },\n  _getTotalCellCount: function _getTotalCellCount(groupCount) {\n    return this._groupedStrategy.getTotalCellCount(groupCount);\n  },\n  _getTotalRowCount: function _getTotalRowCount() {\n    return this._groupedStrategy.getTotalRowCount();\n  },\n  _getCellData: function _getCellData(cell, rowIndex, cellIndex) {\n    var data = this._prepareCellData(rowIndex, cellIndex, cell);\n\n    return {\n      key: CELL_DATA,\n      value: data\n    };\n  },\n  _prepareCellData: function _prepareCellData(rowIndex, cellIndex) {\n    var startDate = this._getDateByCellIndexes(rowIndex, cellIndex),\n        endDate = this.calculateEndDate(startDate),\n        data = {\n      startDate: startDate,\n      endDate: endDate,\n      allDay: this._getTableAllDay()\n    },\n        groups = this._getCellGroups(this._getGroupIndex(rowIndex, cellIndex));\n\n    if (groups.length) {\n      data.groups = {};\n    }\n\n    for (var i = 0; i < groups.length; i++) {\n      data.groups[groups[i].name] = groups[i].id;\n    }\n\n    return data;\n  },\n  _getGroupIndex: function _getGroupIndex(rowIndex, cellIndex) {\n    return this._groupedStrategy.getGroupIndex(rowIndex, cellIndex);\n  },\n  _getTableAllDay: function _getTableAllDay() {\n    return false;\n  },\n  calculateEndDate: function calculateEndDate(startDate) {\n    var result = new Date(startDate);\n    result.setMilliseconds(result.getMilliseconds() + Math.round(this._getInterval()));\n    return result;\n  },\n  _getGroupCount: function _getGroupCount() {\n    var groups = this.option(\"groups\"),\n        result = 0;\n\n    for (var i = 0, len = groups.length; i < len; i++) {\n      if (!i) {\n        result = groups[i].items.length;\n      } else {\n        result *= groups[i].items.length;\n      }\n    }\n\n    return result;\n  },\n  _getPathToLeaf: function _getPathToLeaf(leafIndex) {\n    var tree = this.invoke(\"createResourcesTree\", this.option(\"groups\"));\n\n    function findLeafByIndex(data, index) {\n      for (var i = 0; i < data.length; i++) {\n        if (data[i].leafIndex === index) {\n          return data[i];\n        } else {\n          var leaf = findLeafByIndex(data[i].children, index);\n\n          if (leaf) {\n            return leaf;\n          }\n        }\n      }\n    }\n\n    function makeBranch(leaf, result) {\n      result = result || [];\n      result.push(leaf.value);\n\n      if (leaf.parent) {\n        makeBranch(leaf.parent, result);\n      }\n\n      return result;\n    }\n\n    var leaf = findLeafByIndex(tree, leafIndex);\n    return makeBranch(leaf).reverse();\n  },\n  _getCellGroups: function _getCellGroups(groupIndex) {\n    var result = [];\n\n    if (this._getGroupCount()) {\n      var groups = this.option(\"groups\");\n\n      if (groupIndex < 0) {\n        return;\n      }\n\n      var path = this._getPathToLeaf(groupIndex);\n\n      for (var i = 0; i < groups.length; i++) {\n        result.push({\n          name: groups[i].name,\n          id: path[i]\n        });\n      }\n    }\n\n    return result;\n  },\n  _attachTablesEvents: function _attachTablesEvents() {\n    this._attachTableEvents(this._getDateTable());\n\n    this._attachTableEvents(this._getAllDayTable());\n  },\n  _attachTableEvents: function _attachTableEvents($table) {\n    var cellHeight,\n        cellWidth,\n        that = this,\n        isPointerDown = false;\n    eventsEngine.off($table, SCHEDULER_CELL_DXDRAGENTER_EVENT_NAME);\n    eventsEngine.off($table, SCHEDULER_CELL_DXDROP_EVENT_NAME);\n    eventsEngine.off($table, SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME);\n    eventsEngine.off($table, SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME);\n    eventsEngine.on($table, SCHEDULER_CELL_DXDRAGENTER_EVENT_NAME, \"td\", {\n      itemSizeFunc: function itemSizeFunc($element) {\n        if (!cellHeight) {\n          cellHeight = $element.get(0).getBoundingClientRect().height;\n        }\n\n        if (!cellWidth) {\n          cellWidth = $element.get(0).getBoundingClientRect().width;\n        }\n\n        return {\n          width: cellWidth,\n          height: cellHeight\n        };\n      }\n    }, function (e) {\n      if (that._$currentTableTarget) {\n        that._$currentTableTarget.removeClass(DATE_TABLE_DROPPABLE_CELL_CLASS);\n      }\n\n      that._$currentTableTarget = $(e.target);\n\n      that._$currentTableTarget.addClass(DATE_TABLE_DROPPABLE_CELL_CLASS);\n    });\n    eventsEngine.on($table, SCHEDULER_CELL_DXDROP_EVENT_NAME, \"td\", function (e) {\n      $(e.target).removeClass(DATE_TABLE_DROPPABLE_CELL_CLASS);\n      cellHeight = 0;\n      cellWidth = 0;\n    });\n    eventsEngine.on($table, SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME, \"td\", function (e) {\n      if (eventUtils.isMouseEvent(e) && 1 === e.which) {\n        isPointerDown = true;\n        that.$element().addClass(WORKSPACE_WITH_MOUSE_SELECTION_CLASS);\n        eventsEngine.off(domAdapter.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME);\n        eventsEngine.on(domAdapter.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME, function () {\n          isPointerDown = false;\n          that.$element().removeClass(WORKSPACE_WITH_MOUSE_SELECTION_CLASS);\n        });\n      }\n    });\n    eventsEngine.on($table, SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME, \"td\", function (e) {\n      if (isPointerDown && that._dateTableScrollable && !that._dateTableScrollable.option(\"scrollByContent\")) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        that._moveToCell($(e.target), true);\n      }\n    });\n  },\n  _getDateTables: function _getDateTables() {\n    return this._$dateTable.add(this._$allDayTable);\n  },\n  _getDateTable: function _getDateTable() {\n    return this._$dateTable;\n  },\n  _getAllDayTable: function _getAllDayTable() {\n    return this._$allDayTable;\n  },\n  _getInterval: function _getInterval() {\n    if (void 0 === this._interval) {\n      this._interval = this.option(\"hoursInterval\") * HOUR_MS;\n    }\n\n    return this._interval;\n  },\n  _getHeaderText: function _getHeaderText(headerIndex) {\n    return dateLocalization.format(this._getDateByIndex(headerIndex), this._getFormat());\n  },\n  _getDateByIndex: abstract,\n  _getFormat: abstract,\n  _calculateCellIndex: function _calculateCellIndex(rowIndex, cellIndex) {\n    return this._groupedStrategy.calculateCellIndex(rowIndex, cellIndex);\n  },\n  _renderTableBody: function _renderTableBody(options, delayCellTemplateRendering) {\n    var result = [];\n\n    if (!delayCellTemplateRendering) {\n      this._applyCellTemplates(tableCreator.makeTable(options));\n    } else {\n      result = tableCreator.makeTable(options);\n    }\n\n    return result;\n  },\n  _removeAllDayElements: function _removeAllDayElements() {\n    this._$allDayTable && this._$allDayTable.remove();\n    this._$allDayTitle && this._$allDayTitle.remove();\n  },\n  _cleanView: function _cleanView() {\n    this._cleanCellDataCache();\n\n    this._cleanAllowedPositions();\n\n    this._$thead.empty();\n\n    this._$dateTable.empty();\n\n    this._shader && this._shader.clean();\n\n    this._$timePanel.empty();\n\n    this._$allDayTable && this._$allDayTable.empty();\n\n    this._$groupTable.empty();\n\n    delete this._hiddenInterval;\n    delete this._interval;\n  },\n  _clean: function _clean() {\n    eventsEngine.off(domAdapter.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME);\n    this.callBase();\n  },\n  getWorkArea: function getWorkArea() {\n    return this._dateTableScrollable.$content();\n  },\n  getScrollable: function getScrollable() {\n    return this._dateTableScrollable;\n  },\n  getScrollableScrollTop: function getScrollableScrollTop() {\n    return this._dateTableScrollable.scrollTop();\n  },\n  getGroupedScrollableScrollTop: function getGroupedScrollableScrollTop(allDay) {\n    return this._groupedStrategy.getScrollableScrollTop(allDay);\n  },\n  getScrollableScrollLeft: function getScrollableScrollLeft() {\n    return this._dateTableScrollable.scrollLeft();\n  },\n  getScrollableOuterWidth: function getScrollableOuterWidth() {\n    return this._dateTableScrollable.scrollWidth();\n  },\n  getScrollableContainer: function getScrollableContainer() {\n    return this._dateTableScrollable._container();\n  },\n  getHeaderPanelHeight: function getHeaderPanelHeight() {\n    return this._$headerPanel && this._$headerPanel.outerHeight(true);\n  },\n  getTimePanelWidth: function getTimePanelWidth() {\n    return this._$timePanel && this._$timePanel.get(0).getBoundingClientRect().width;\n  },\n  getGroupTableWidth: function getGroupTableWidth() {\n    return this._$groupTable ? this._$groupTable.outerWidth() : 0;\n  },\n  getWorkSpaceLeftOffset: function getWorkSpaceLeftOffset() {\n    return this._groupedStrategy.getLeftOffset();\n  },\n  getGroupedStrategy: function getGroupedStrategy() {\n    return this._groupedStrategy;\n  },\n  _getCellCoordinatesByIndex: function _getCellCoordinatesByIndex(index) {\n    var cellIndex = Math.floor(index / this._getRowCount()),\n        rowIndex = index - this._getRowCount() * cellIndex;\n    return {\n      cellIndex: cellIndex,\n      rowIndex: rowIndex\n    };\n  },\n  _getDateByCellIndexes: function _getDateByCellIndexes(rowIndex, cellIndex, patchedIndexes) {\n    cellIndex = !patchedIndexes ? this._patchCellIndex(cellIndex) : cellIndex;\n    var firstViewDate = this.getStartViewDate(),\n        currentDate = new Date(firstViewDate.getTime() + this._getMillisecondsOffset(rowIndex, cellIndex) + this._getOffsetByCount(cellIndex));\n    currentDate.setTime(currentDate.getTime() + dateUtils.getTimezonesDifference(firstViewDate, currentDate));\n    return currentDate;\n  },\n  _patchCellIndex: function _patchCellIndex(cellIndex) {\n    if (this.isGroupedByDate()) {\n      cellIndex = Math.floor(cellIndex / this._getGroupCount());\n    }\n\n    return cellIndex;\n  },\n  _getOffsetByCount: function _getOffsetByCount() {\n    return 0;\n  },\n  _getMillisecondsOffset: function _getMillisecondsOffset(rowIndex, cellIndex) {\n    return this._getInterval() * this._calculateCellIndex(rowIndex, cellIndex) + this._calculateHiddenInterval(rowIndex, cellIndex);\n  },\n  _calculateHiddenInterval: function _calculateHiddenInterval(rowIndex, cellIndex) {\n    var dayCount = cellIndex % this._getCellCount();\n\n    return dayCount * this._getHiddenInterval();\n  },\n  _getHiddenInterval: function _getHiddenInterval() {\n    if (void 0 === this._hiddenInterval) {\n      this._hiddenInterval = DAY_MS - this.getVisibleDayDuration();\n    }\n\n    return this._hiddenInterval;\n  },\n  _getIntervalBetween: function _getIntervalBetween(currentDate, allDay) {\n    var firstViewDate = this.getStartViewDate();\n\n    var startDayTime = this.option(\"startDayHour\") * HOUR_MS,\n        timeZoneOffset = dateUtils.getTimezonesDifference(firstViewDate, currentDate),\n        fullInterval = currentDate.getTime() - firstViewDate.getTime() - timeZoneOffset,\n        days = this._getDaysOfInterval(fullInterval, startDayTime),\n        weekendsCount = this._getWeekendsCount(days),\n        result = (days - weekendsCount) * DAY_MS;\n\n    if (!allDay) {\n      result = fullInterval - days * this._getHiddenInterval() - weekendsCount * this.getVisibleDayDuration();\n    }\n\n    return result;\n  },\n  _getWeekendsCount: function _getWeekendsCount() {\n    return 0;\n  },\n  _getDaysOfInterval: function _getDaysOfInterval(fullInterval, startDayTime) {\n    return Math.floor((fullInterval + startDayTime) / DAY_MS);\n  },\n  _getGroupIndexes: function _getGroupIndexes(appointmentResources) {\n    var result = [];\n\n    if (appointmentResources && this.option(\"groups\").length) {\n      var tree = this.invoke(\"createResourcesTree\", this.option(\"groups\"));\n      result = this.invoke(\"getResourceTreeLeaves\", tree, appointmentResources);\n    }\n\n    return result;\n  },\n  _updateIndex: function _updateIndex(index) {\n    return index * this._getRowCount();\n  },\n  _getDroppableCell: function _getDroppableCell() {\n    return this._getDateTables().find(\".\" + DATE_TABLE_DROPPABLE_CELL_CLASS);\n  },\n  _getWorkSpaceWidth: function _getWorkSpaceWidth() {\n    if (this._needCreateCrossScrolling()) {\n      return this._$dateTable.get(0).getBoundingClientRect().width;\n    }\n\n    return this.$element().get(0).getBoundingClientRect().width - this.getTimePanelWidth();\n  },\n  _getCellPositionByIndex: function _getCellPositionByIndex(index, groupIndex, inAllDayRow) {\n    var cellCoordinates = this._getCellCoordinatesByIndex(index),\n        $cell = this._getCellByCoordinates(cellCoordinates, groupIndex, inAllDayRow),\n        result = this._getCellPosition($cell);\n\n    this.setCellDataCache(cellCoordinates, groupIndex, $cell);\n\n    if (result) {\n      result.rowIndex = cellCoordinates.rowIndex;\n      result.cellIndex = cellCoordinates.cellIndex;\n    }\n\n    return result;\n  },\n  _getCellPosition: function _getCellPosition($cell) {\n    var position = $cell.position();\n\n    if (this.option(\"rtlEnabled\")) {\n      position.left += $cell.get(0).getBoundingClientRect().width;\n    }\n\n    return position;\n  },\n  _getCellByCoordinates: function _getCellByCoordinates(cellCoordinates, groupIndex, inAllDayRow) {\n    var indexes = this._groupedStrategy.prepareCellIndexes(cellCoordinates, groupIndex, inAllDayRow);\n\n    return this._$dateTable.find(\"tr\").eq(indexes.rowIndex).find(\"td\").eq(indexes.cellIndex);\n  },\n  _getCells: function _getCells(allDay, direction) {\n    var cellClass = allDay ? ALL_DAY_TABLE_CELL_CLASS : DATE_TABLE_CELL_CLASS;\n\n    if (\"vertical\" === direction) {\n      var result = [];\n\n      for (var i = 1;; i++) {\n        var cells = this.$element().find(\"tr .\" + cellClass + \":nth-child(\" + i + \")\");\n\n        if (!cells.length) {\n          break;\n        }\n\n        result = result.concat(cells.toArray());\n      }\n\n      return $(result);\n    } else {\n      return this.$element().find(\".\" + cellClass);\n    }\n  },\n  _setHorizontalGroupHeaderCellsHeight: function _setHorizontalGroupHeaderCellsHeight() {\n    var height = this._$dateTable.get(0).getBoundingClientRect().height;\n\n    this._$groupTable.outerHeight(height);\n  },\n  _getDateTableBorder: function _getDateTableBorder() {\n    return DATE_TABLE_CELL_BORDER;\n  },\n  _getDateTableBorderOffset: function _getDateTableBorderOffset() {\n    return 2 * this._getDateTableBorder();\n  },\n  _getGroupHeaderCellsContent: function _getGroupHeaderCellsContent() {\n    return this.$element().find(\".\" + GROUP_HEADER_CONTENT_CLASS);\n  },\n  _getGroupHeaderCells: function _getGroupHeaderCells() {\n    return this.$element().find(\".\" + GROUP_HEADER_CLASS);\n  },\n  _getScrollCoordinates: function _getScrollCoordinates(hours, minutes, date) {\n    var currentDate = date || new Date(this.option(\"currentDate\")),\n        startDayHour = this.option(\"startDayHour\"),\n        endDayHour = this.option(\"endDayHour\");\n\n    if (hours < startDayHour) {\n      hours = startDayHour;\n    }\n\n    if (hours >= endDayHour) {\n      hours = endDayHour - 1;\n    }\n\n    currentDate.setHours(hours, minutes, 0, 0);\n    return this.getCoordinatesByDate(currentDate);\n  },\n  setCellDataCache: function setCellDataCache(cellCoordinates, groupIndex, $cell) {\n    var cache = this.getCellDataCache(),\n        data = this.getCellData($cell);\n    var key = JSON.stringify({\n      rowIndex: cellCoordinates.rowIndex,\n      cellIndex: cellCoordinates.cellIndex,\n      groupIndex: groupIndex\n    });\n    cache[key] = data;\n  },\n  setCellDataCacheAlias: function setCellDataCacheAlias(appointment, geometry) {\n    var key = JSON.stringify({\n      rowIndex: appointment.rowIndex,\n      cellIndex: appointment.cellIndex,\n      groupIndex: appointment.groupIndex\n    }),\n        aliasKey = JSON.stringify({\n      top: geometry.top,\n      left: geometry.left\n    }),\n        cache = this.getCellDataCache();\n\n    if (cache[key]) {\n      cache[aliasKey] = cache[key];\n    }\n  },\n  getCellDataCache: function getCellDataCache(key) {\n    if (!this._cache) {\n      this._cache = {};\n    }\n\n    return key ? this._cache[key] : this._cache;\n  },\n  _cleanCellDataCache: function _cleanCellDataCache() {\n    delete this._cache;\n  },\n  _cleanAllowedPositions: function _cleanAllowedPositions() {\n    delete this._maxAllowedVerticalPosition;\n    delete this._maxAllowedPosition;\n  },\n  supportAllDayRow: function supportAllDayRow() {\n    return true;\n  },\n  keepOriginalHours: function keepOriginalHours() {\n    return false;\n  },\n  getFocusedCellData: function getFocusedCellData() {\n    var $focusedCells = this._getAllFocusedCells(),\n        result = [];\n\n    if ($focusedCells.length > 1) {\n      result = this._getMultipleCellsData($focusedCells);\n    } else {\n      var data = this.getCellData($focusedCells);\n      data && result.push(data);\n    }\n\n    return result;\n  },\n  _getMultipleCellsData: function _getMultipleCellsData($cells) {\n    var data = [];\n\n    for (var i = 0; i < $cells.length; i++) {\n      data.push(dataUtils.data($cells[i], CELL_DATA));\n    }\n\n    return data;\n  },\n  getCellData: function getCellData($cell) {\n    var data = $cell[0] ? dataUtils.data($cell[0], CELL_DATA) : void 0;\n    return extend(true, {}, data);\n  },\n  _getHorizontalMax: function _getHorizontalMax(groupIndex) {\n    groupIndex = this.option(\"groupByDate\") ? this._getGroupCount() - 1 : groupIndex;\n    return this._groupedStrategy.getHorizontalMax(groupIndex);\n  },\n  getCoordinatesByDate: function getCoordinatesByDate(date, groupIndex, inAllDayRow) {\n    groupIndex = groupIndex || 0;\n\n    var index = this.getCellIndexByDate(date, inAllDayRow),\n        position = this._getCellPositionByIndex(index, groupIndex, inAllDayRow),\n        shift = this.getPositionShift(inAllDayRow ? 0 : this.getTimeShift(date)),\n        horizontalHMax = this._getHorizontalMax(groupIndex, date);\n\n    if (!position) {\n      throw errors.Error(\"E1039\");\n    }\n\n    var coordinates = {\n      cellPosition: position.left + shift.cellPosition,\n      top: position.top + shift.top,\n      left: position.left + shift.left,\n      rowIndex: position.rowIndex,\n      cellIndex: position.cellIndex,\n      hMax: horizontalHMax,\n      vMax: this.getVerticalMax(groupIndex),\n      groupIndex: groupIndex\n    };\n    return coordinates;\n  },\n  getVerticalMax: function getVerticalMax(groupIndex) {\n    return this._groupedStrategy.getVerticalMax(groupIndex);\n  },\n  _getOffsetByAllDayPanel: function _getOffsetByAllDayPanel(groupIndex) {\n    return this._groupedStrategy._getOffsetByAllDayPanel(groupIndex);\n  },\n  _getGroupTop: function _getGroupTop(groupIndex) {\n    return this._groupedStrategy._getGroupTop(groupIndex);\n  },\n  isGroupedByDate: function isGroupedByDate() {\n    return this.option(\"groupByDate\") && this._isHorizontalGroupedWorkSpace() && this._getGroupCount() > 0;\n  },\n  getCellIndexByDate: function getCellIndexByDate(date, inAllDayRow) {\n    var timeInterval = inAllDayRow ? 864e5 : this._getInterval(),\n        dateTimeStamp = this._getIntervalBetween(date, inAllDayRow);\n\n    var index = Math.floor(dateTimeStamp / timeInterval);\n\n    if (inAllDayRow) {\n      index = this._updateIndex(index);\n    }\n\n    if (index < 0) {\n      index = 0;\n    }\n\n    return index;\n  },\n  getPositionShift: function getPositionShift(timeShift) {\n    return {\n      top: timeShift * this.getCellHeight(),\n      left: 0,\n      cellPosition: 0\n    };\n  },\n  getTimeShift: function getTimeShift(date) {\n    var cellDuration = this.getCellDuration(),\n        currentDayStart = new Date(date);\n    currentDayStart.setHours(this.option(\"startDayHour\"), 0, 0, 0);\n\n    var currentDateTime = date.getTime(),\n        currentDayStartTime = currentDayStart.getTime(),\n        minTime = this._firstViewDate.getTime();\n\n    return currentDateTime > minTime ? (currentDateTime - currentDayStartTime) % cellDuration / cellDuration : 0;\n  },\n  getCoordinatesByDateInGroup: function getCoordinatesByDateInGroup(date, appointmentResources, inAllDayRow) {\n    var indexes = this._getGroupIndexes(appointmentResources),\n        result = [];\n\n    if (indexes.length) {\n      for (var i = 0; i < indexes.length; i++) {\n        result.push(this.getCoordinatesByDate(date, indexes[i], inAllDayRow));\n      }\n    } else {\n      result.push(this.getCoordinatesByDate(date, 0, inAllDayRow));\n    }\n\n    return result;\n  },\n  getDroppableCellIndex: function getDroppableCellIndex() {\n    var $droppableCell = this._getDroppableCell(),\n        $row = $droppableCell.parent(),\n        rowIndex = $row.index();\n\n    return rowIndex * $row.find(\"td\").length + $droppableCell.index();\n  },\n  getDataByDroppableCell: function getDataByDroppableCell() {\n    var cellData = this.getCellData(this._getDroppableCell());\n    return {\n      date: cellData.startDate,\n      allDay: cellData.allDay,\n      groups: cellData.groups\n    };\n  },\n  getDateRange: function getDateRange() {\n    return [this.getStartViewDate(), this.getEndViewDate()];\n  },\n  getCellWidth: function getCellWidth() {\n    var cell = this._getCells().first().get(0);\n\n    return cell && cell.getBoundingClientRect().width;\n  },\n  getCellMinWidth: function getCellMinWidth() {\n    return DATE_TABLE_MIN_CELL_WIDTH;\n  },\n  getRoundedCellWidth: function getRoundedCellWidth(groupIndex, startIndex, cellCount) {\n    if (groupIndex < 0) {\n      return 0;\n    }\n\n    var $row = this.$element().find(\".\" + this._getDateTableRowClass()).eq(0),\n        width = 0,\n        $cells = $row.find(\".\" + DATE_TABLE_CELL_CLASS),\n        totalCellCount = this._getCellCount() * groupIndex;\n    cellCount = cellCount || this._getCellCount();\n\n    if (!typeUtils.isDefined(startIndex)) {\n      startIndex = totalCellCount;\n    }\n\n    for (var i = startIndex; i < totalCellCount + cellCount; i++) {\n      width += $($cells).eq(i).get(0).getBoundingClientRect().width;\n    }\n\n    return width / (totalCellCount + cellCount - startIndex);\n  },\n  getCellHeight: function getCellHeight() {\n    var cell = this._getCells().first().get(0);\n\n    return cell && cell.getBoundingClientRect().height;\n  },\n  getAllDayHeight: function getAllDayHeight() {\n    var cell = this._getCells(true).first().get(0);\n\n    return this.option(\"showAllDayPanel\") ? cell && cell.getBoundingClientRect().height || 0 : 0;\n  },\n  getAllDayOffset: function getAllDayOffset() {\n    return this._groupedStrategy.getAllDayOffset();\n  },\n  getMaxAllowedPosition: function getMaxAllowedPosition() {\n    if (!this._maxAllowedPosition) {\n      var isRtl = this.option(\"rtlEnabled\");\n      this._maxAllowedPosition = [];\n\n      this._$dateTable.find(\"tr\").first().find(\"td:nth-child(\" + this._getCellCount() + \"n)\").each(function (_, cell) {\n        var maxPosition = $(cell).position().left;\n\n        if (!isRtl) {\n          maxPosition += $(cell).get(0).getBoundingClientRect().width;\n        }\n\n        this._maxAllowedPosition.push(Math.round(maxPosition));\n      }.bind(this));\n    }\n\n    return this._maxAllowedPosition;\n  },\n  getMaxAllowedVerticalPosition: function getMaxAllowedVerticalPosition() {\n    if (!this._maxAllowedVerticalPosition) {\n      var that = this;\n      this._maxAllowedVerticalPosition = [];\n\n      var rows = this._getRowCount();\n\n      this._$dateTable.find(\"tr:nth-child(\" + rows + \"n)\").each(function (_, row) {\n        var maxPosition = $(row).position().top + $(row).get(0).getBoundingClientRect().height;\n\n        that._maxAllowedVerticalPosition.push(Math.round(maxPosition));\n      });\n    }\n\n    return this._maxAllowedVerticalPosition;\n  },\n  getFixedContainer: function getFixedContainer() {\n    return this._$fixedContainer;\n  },\n  getAllDayContainer: function getAllDayContainer() {\n    return this._$allDayContainer;\n  },\n  getCellIndexByCoordinates: function getCellIndexByCoordinates(coordinates, allDay) {\n    var cellCount = this._getTotalCellCount(this._getGroupCount()),\n        cellWidth = Math.floor(this._getWorkSpaceWidth() / cellCount),\n        cellHeight = allDay ? this.getAllDayHeight() : this.getCellHeight(),\n        leftOffset = this._isRTL() || this.option(\"crossScrollingEnabled\") ? 0 : this.getWorkSpaceLeftOffset(),\n        topIndex = Math.floor(coordinates.top / cellHeight),\n        leftIndex = Math.floor((coordinates.left + 5 - leftOffset) / cellWidth);\n\n    if (this._isRTL()) {\n      leftIndex = cellCount - leftIndex - 1;\n    }\n\n    return cellCount * topIndex + leftIndex;\n  },\n  getStartViewDate: function getStartViewDate() {\n    return this._firstViewDate;\n  },\n  getEndViewDate: function getEndViewDate() {\n    var dateOfLastViewCell = this.getDateOfLastViewCell(),\n        endDateOfLastViewCell = this.calculateEndViewDate(dateOfLastViewCell);\n    return this._adjustEndViewDateByDaylightDiff(dateOfLastViewCell, endDateOfLastViewCell);\n  },\n  calculateEndViewDate: function calculateEndViewDate(dateOfLastViewCell) {\n    return new Date(dateOfLastViewCell.getTime() + this.getCellDuration());\n  },\n  _adjustEndViewDateByDaylightDiff: function _adjustEndViewDateByDaylightDiff(startDate, endDate) {\n    var daylightDiff = this.invoke(\"getDaylightOffset\", startDate, endDate) * toMs(\"minute\") || 0;\n    var endDateOfLastViewCell = new Date(endDate.getTime() - daylightDiff);\n    return new Date(endDateOfLastViewCell.getTime() - toMs(\"minute\"));\n  },\n  getDateOfLastViewCell: function getDateOfLastViewCell() {\n    var rowIndex = this._getRowCount() - 1,\n        cellIndex = this._getCellCount();\n\n    if (this.option(\"groupByDate\")) {\n      cellIndex = cellIndex * this._getGroupCount() - 1;\n    } else {\n      cellIndex -= 1;\n    }\n\n    return this._getDateByCellIndexes(rowIndex, cellIndex, true);\n  },\n  getCellDuration: function getCellDuration() {\n    return 36e5 * this.option(\"hoursInterval\");\n  },\n  getIntervalDuration: function getIntervalDuration(allDay) {\n    return allDay ? toMs(\"day\") : this.getCellDuration();\n  },\n  getVisibleDayDuration: function getVisibleDayDuration() {\n    return this.option(\"hoursInterval\") * this._getCellCountInDay() * HOUR_MS;\n  },\n  getGroupBounds: function getGroupBounds(coordinates) {\n    var cellCount = this._getCellCount(),\n        $cells = this._getCells(),\n        cellWidth = this.getCellWidth(),\n        result = this._groupedStrategy.getGroupBoundsOffset(cellCount, $cells, cellWidth, coordinates);\n\n    if (this._isRTL()) {\n      var startOffset = result.left;\n      result.left = result.right - 2 * cellWidth;\n      result.right = startOffset + 2 * cellWidth;\n    }\n\n    return result;\n  },\n  needRecalculateResizableArea: function needRecalculateResizableArea() {\n    return this._isVerticalGroupedWorkSpace() && 0 !== this.getScrollable().scrollTop();\n  },\n  getCellDataByCoordinates: function getCellDataByCoordinates(coordinates, allDay) {\n    var key = JSON.stringify({\n      top: coordinates.top,\n      left: coordinates.left\n    }),\n        data = this.getCellDataCache(key);\n\n    if (data) {\n      return data;\n    }\n\n    var $cells = this._getCells(allDay),\n        cellIndex = this.getCellIndexByCoordinates(coordinates, allDay),\n        $cell = $cells.eq(cellIndex);\n\n    return this.getCellData($cell);\n  },\n  getVisibleBounds: function getVisibleBounds() {\n    var result = {},\n        $scrollable = this.getScrollable().$element(),\n        cellHeight = this.getCellHeight(),\n        scrolledCellCount = this.getScrollableScrollTop() / cellHeight,\n        totalCellCount = scrolledCellCount + $scrollable.height() / cellHeight;\n    result.top = {\n      hours: Math.floor(scrolledCellCount * this.option(\"hoursInterval\")) + this.option(\"startDayHour\"),\n      minutes: scrolledCellCount % 2 ? 30 : 0\n    };\n    result.bottom = {\n      hours: Math.floor(totalCellCount * this.option(\"hoursInterval\")) + this.option(\"startDayHour\"),\n      minutes: Math.floor(totalCellCount) % 2 ? 30 : 0\n    };\n    return result;\n  },\n  updateScrollPosition: function updateScrollPosition(date) {\n    date = this.invoke(\"convertDateByTimezone\", date);\n    var bounds = this.getVisibleBounds(),\n        startDateHour = date.getHours(),\n        startDateMinutes = date.getMinutes();\n\n    if (this.needUpdateScrollPosition(startDateHour, startDateMinutes, bounds, date)) {\n      this.scrollToTime(startDateHour, startDateMinutes, date);\n    }\n  },\n  needUpdateScrollPosition: function needUpdateScrollPosition(hours, minutes, bounds) {\n    var isUpdateNeeded = false;\n\n    if (hours < bounds.top.hours || hours > bounds.bottom.hours) {\n      isUpdateNeeded = true;\n    }\n\n    if (hours === bounds.top.hours && minutes < bounds.top.minutes) {\n      isUpdateNeeded = true;\n    }\n\n    if (hours === bounds.bottom.hours && minutes > bounds.top.minutes) {\n      isUpdateNeeded = true;\n    }\n\n    return isUpdateNeeded;\n  },\n  getGroupWidth: function getGroupWidth(groupIndex) {\n    var result = this._getCellCount() * this.getCellWidth(),\n        position = this.getMaxAllowedPosition(),\n        currentPosition = position[groupIndex];\n\n    if (position.length && currentPosition) {\n      if (this._isRTL()) {\n        result = currentPosition - position[groupIndex + 1];\n      } else {\n        if (0 === groupIndex) {\n          result = currentPosition;\n        } else {\n          result = currentPosition - position[groupIndex - 1];\n        }\n      }\n    }\n\n    return result;\n  },\n  restoreScrollTop: function restoreScrollTop() {\n    this.$element().scrollTop(0);\n  },\n  scrollToTime: function scrollToTime(hours, minutes, date) {\n    var min = this.getStartViewDate(),\n        max = this.getEndViewDate();\n\n    if (date < min || date > max) {\n      errors.log(\"W1008\", date);\n      return;\n    }\n\n    var coordinates = this._getScrollCoordinates(hours, minutes, date),\n        scrollable = this.getScrollable();\n\n    scrollable.scrollBy({\n      top: coordinates.top - scrollable.scrollTop(),\n      left: 0\n    });\n  },\n  getDistanceBetweenCells: function getDistanceBetweenCells(startIndex, endIndex) {\n    var result = 0;\n    this.$element().find(\".\" + this._getDateTableRowClass()).first().find(\".\" + DATE_TABLE_CELL_CLASS).each(function (index) {\n      if (index < startIndex || index > endIndex) {\n        return true;\n      }\n\n      result += $(this).get(0).getBoundingClientRect().width;\n    });\n    return result;\n  },\n  needApplyCollectorOffset: function needApplyCollectorOffset() {\n    return false;\n  },\n  _supportCompactDropDownAppointments: function _supportCompactDropDownAppointments() {\n    return true;\n  },\n  _formatWeekday: function _formatWeekday(date) {\n    return formatWeekday(date);\n  },\n  _formatWeekdayAndDay: function _formatWeekdayAndDay(date) {\n    return formatWeekday(date) + \" \" + dateLocalization.format(date, \"day\");\n  }\n}).include(publisherMixin);\nmodule.exports = SchedulerWorkSpace;","map":null,"metadata":{},"sourceType":"script"}