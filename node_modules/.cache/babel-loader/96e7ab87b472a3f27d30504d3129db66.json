{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/rendering_strategies/ui.scheduler.appointments.strategy.base.js)\r\n * Version: 19.1.6 (build 19263-1729)\r\n * Build date: Fri Sep 20 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n\n      if (\"value\" in descriptor) {\n        descriptor.writable = true;\n      }\n\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) {\n      defineProperties(Constructor.prototype, protoProps);\n    }\n\n    if (staticProps) {\n      defineProperties(Constructor, staticProps);\n    }\n\n    return Constructor;\n  };\n}();\n\nvar _uiSchedulerAppointmentsPositioningStrategy = require(\"./ui.scheduler.appointmentsPositioning.strategy.base\");\n\nvar _uiSchedulerAppointmentsPositioningStrategy2 = _interopRequireDefault(_uiSchedulerAppointmentsPositioningStrategy);\n\nvar _uiSchedulerAppointmentsPositioningStrategy3 = require(\"./ui.scheduler.appointmentsPositioning.strategy.adaptive\");\n\nvar _uiSchedulerAppointmentsPositioningStrategy4 = _interopRequireDefault(_uiSchedulerAppointmentsPositioningStrategy3);\n\nvar _extend = require(\"../../../core/utils/extend\");\n\nvar _ui = require(\"../../widget/ui.errors\");\n\nvar _ui2 = _interopRequireDefault(_ui);\n\nvar _date = require(\"../../../core/utils/date\");\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _type = require(\"../../../core/utils/type\");\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _themes = require(\"../../themes\");\n\nvar _themes2 = _interopRequireDefault(_themes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar toMs = _date2.default.dateToMilliseconds;\nvar APPOINTMENT_MIN_SIZE = 2,\n    COMPACT_APPOINTMENT_DEFAULT_WIDTH = 15,\n    APPOINTMENT_DEFAULT_HEIGHT = 20,\n    COMPACT_THEME_APPOINTMENT_DEFAULT_HEIGHT = 18,\n    DROP_DOWN_BUTTON_ADAPTIVE_SIZE = 28;\n\nvar BaseRenderingStrategy = function () {\n  function BaseRenderingStrategy(instance) {\n    _classCallCheck(this, BaseRenderingStrategy);\n\n    this.instance = instance;\n\n    this._initPositioningStrategy();\n  }\n\n  _createClass(BaseRenderingStrategy, [{\n    key: \"_initPositioningStrategy\",\n    value: function value() {\n      this._positioningStrategy = this.instance.fire(\"isAdaptive\") ? new _uiSchedulerAppointmentsPositioningStrategy4.default(this) : new _uiSchedulerAppointmentsPositioningStrategy2.default(this);\n    }\n  }, {\n    key: \"getPositioningStrategy\",\n    value: function value() {\n      return this._positioningStrategy;\n    }\n  }, {\n    key: \"getAppointmentMinSize\",\n    value: function value() {\n      return APPOINTMENT_MIN_SIZE;\n    }\n  }, {\n    key: \"keepAppointmentSettings\",\n    value: function value() {\n      return false;\n    }\n  }, {\n    key: \"getDeltaTime\",\n    value: function value() {}\n  }, {\n    key: \"getAppointmentGeometry\",\n    value: function value(coordinates) {\n      return coordinates;\n    }\n  }, {\n    key: \"needCorrectAppointmentDates\",\n    value: function value() {\n      return true;\n    }\n  }, {\n    key: \"getDirection\",\n    value: function value() {\n      return \"horizontal\";\n    }\n  }, {\n    key: \"createTaskPositionMap\",\n    value: function value(items) {\n      delete this._maxAppointmentCountPerCell;\n      var length = items && items.length;\n\n      if (!length) {\n        return;\n      }\n\n      this._defaultWidth = this.instance._cellWidth;\n      this._defaultHeight = this.instance._cellHeight;\n      this._allDayHeight = this.instance._allDayCellHeight;\n      var map = [];\n\n      for (var i = 0; i < length; i++) {\n        var coordinates = this._getItemPosition(items[i]);\n\n        if (this._isRtl()) {\n          coordinates = this._correctRtlCoordinates(coordinates);\n        }\n\n        map.push(coordinates);\n      }\n\n      var positionArray = this._getSortedPositions(map),\n          resultPositions = this._getResultPositions(positionArray);\n\n      return this._getExtendedPositionMap(map, resultPositions);\n    }\n  }, {\n    key: \"_getDeltaWidth\",\n    value: function value(args, initialSize) {\n      var intervalWidth = this.instance.fire(\"getResizableStep\") || this.getAppointmentMinSize(),\n          initialWidth = initialSize.width;\n      return Math.round((args.width - initialWidth) / intervalWidth);\n    }\n  }, {\n    key: \"_correctRtlCoordinates\",\n    value: function value(coordinates) {\n      var width = coordinates[0].width || this._getAppointmentMaxWidth();\n\n      if (!coordinates[0].appointmentReduced) {\n        coordinates[0].left -= width;\n      }\n\n      this._correctRtlCoordinatesParts(coordinates, width);\n\n      return coordinates;\n    }\n  }, {\n    key: \"_correctRtlCoordinatesParts\",\n    value: function value() {}\n  }, {\n    key: \"_getAppointmentMaxWidth\",\n    value: function value() {\n      return this.getDefaultCellWidth();\n    }\n  }, {\n    key: \"_getItemPosition\",\n    value: function value(item) {\n      var position = this._getAppointmentCoordinates(item),\n          allDay = this.isAllDay(item),\n          result = [],\n          startDate = new Date(this.instance.fire(\"getField\", \"startDate\", item)),\n          isRecurring = !!this.instance.fire(\"getField\", \"recurrenceRule\", item);\n\n      for (var j = 0; j < position.length; j++) {\n        var height = this.calculateAppointmentHeight(item, position[j], isRecurring),\n            width = this.calculateAppointmentWidth(item, position[j], isRecurring),\n            resultWidth = width,\n            appointmentReduced = null,\n            multiWeekAppointmentParts = [],\n            initialRowIndex = position[j].rowIndex,\n            initialCellIndex = position[j].cellIndex;\n\n        if (this._needVerifyItemSize() || allDay) {\n          var currentMaxAllowedPosition = position[j].hMax;\n\n          if (this.isAppointmentGreaterThan(currentMaxAllowedPosition, {\n            left: position[j].left,\n            width: width\n          })) {\n            appointmentReduced = \"head\";\n            initialRowIndex = position[j].rowIndex;\n            initialCellIndex = position[j].cellIndex;\n            resultWidth = this._reduceMultiWeekAppointment(width, {\n              left: position[j].left,\n              right: currentMaxAllowedPosition\n            });\n            multiWeekAppointmentParts = this._getAppointmentParts({\n              sourceAppointmentWidth: width,\n              reducedWidth: resultWidth,\n              height: height\n            }, position[j], startDate);\n\n            if (this._isRtl()) {\n              position[j].left = currentMaxAllowedPosition;\n            }\n          }\n        }\n\n        (0, _extend.extend)(position[j], {\n          height: height,\n          width: resultWidth,\n          allDay: allDay,\n          rowIndex: initialRowIndex,\n          cellIndex: initialCellIndex,\n          appointmentReduced: appointmentReduced\n        });\n        result = this._getAppointmentPartsPosition(multiWeekAppointmentParts, position[j], result);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getAppointmentPartsPosition\",\n    value: function value(appointmentParts, position, result) {\n      if (appointmentParts.length) {\n        appointmentParts.unshift(position);\n        result = result.concat(appointmentParts);\n      } else {\n        result.push(position);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getAppointmentCoordinates\",\n    value: function value(itemData) {\n      var coordinates = [{\n        top: 0,\n        left: 0\n      }];\n      this.instance.fire(\"needCoordinates\", {\n        startDate: this.startDate(itemData),\n        originalStartDate: this.startDate(itemData, true),\n        appointmentData: itemData,\n        callback: function callback(value) {\n          coordinates = value;\n        }\n      });\n      return coordinates;\n    }\n  }, {\n    key: \"_isRtl\",\n    value: function value() {\n      return this.instance.option(\"rtlEnabled\");\n    }\n  }, {\n    key: \"_getAppointmentParts\",\n    value: function value() {\n      return [];\n    }\n  }, {\n    key: \"_getCompactAppointmentParts\",\n    value: function value(appointmentWidth) {\n      var cellWidth = this.getDefaultCellWidth() || this.getAppointmentMinSize();\n      return Math.round(appointmentWidth / cellWidth);\n    }\n  }, {\n    key: \"_reduceMultiWeekAppointment\",\n    value: function value(sourceAppointmentWidth, bound) {\n      if (this._isRtl()) {\n        sourceAppointmentWidth = Math.floor(bound.left - bound.right);\n      } else {\n        sourceAppointmentWidth = bound.right - Math.floor(bound.left);\n      }\n\n      return sourceAppointmentWidth;\n    }\n  }, {\n    key: \"calculateAppointmentHeight\",\n    value: function value() {\n      return 0;\n    }\n  }, {\n    key: \"calculateAppointmentWidth\",\n    value: function value() {\n      return 0;\n    }\n  }, {\n    key: \"isAppointmentGreaterThan\",\n    value: function value(etalon, comparisonParameters) {\n      var result = comparisonParameters.left + comparisonParameters.width - etalon;\n\n      if (this._isRtl()) {\n        result = etalon + comparisonParameters.width - comparisonParameters.left;\n      }\n\n      return result > this.getDefaultCellWidth() / 2;\n    }\n  }, {\n    key: \"isAllDay\",\n    value: function value() {\n      return false;\n    }\n  }, {\n    key: \"cropAppointmentWidth\",\n    value: function value(width, cellWidth) {\n      if (this.instance.fire(\"isGroupedByDate\")) {\n        width = cellWidth;\n      }\n\n      return width;\n    }\n  }, {\n    key: \"_getSortedPositions\",\n    value: function value(positionList) {\n      var _this = this;\n\n      var result = [];\n\n      var round = function round(value) {\n        return Math.round(100 * value) / 100;\n      };\n\n      var createSortedItem = function createSortedItem(rowIndex, cellIndex, top, left, position, isStart, allDay, tmpIndex) {\n        return {\n          i: rowIndex,\n          j: cellIndex,\n          top: round(top),\n          left: round(left),\n          cellPosition: position,\n          isStart: isStart,\n          allDay: allDay,\n          __tmpIndex: tmpIndex\n        };\n      };\n\n      var tmpIndex = 0;\n\n      for (var rowIndex = 0, rowCount = positionList.length; rowIndex < rowCount; rowIndex++) {\n        for (var cellIndex = 0, cellCount = positionList[rowIndex].length; cellIndex < cellCount; cellIndex++) {\n          var _positionList$rowInde = positionList[rowIndex][cellIndex],\n              top = _positionList$rowInde.top,\n              left = _positionList$rowInde.left,\n              height = _positionList$rowInde.height,\n              width = _positionList$rowInde.width,\n              cellPosition = _positionList$rowInde.cellPosition,\n              allDay = _positionList$rowInde.allDay;\n          var start = createSortedItem(rowIndex, cellIndex, top, left, cellPosition, true, allDay, tmpIndex);\n          tmpIndex++;\n          var end = createSortedItem(rowIndex, cellIndex, top + height, left + width, cellPosition, false, allDay, tmpIndex);\n          tmpIndex++;\n          result.push(start, end);\n        }\n      }\n\n      return result.sort(function (a, b) {\n        return _this._sortCondition(a, b);\n      });\n    }\n  }, {\n    key: \"_fixUnstableSorting\",\n    value: function value(comparisonResult, a, b) {\n      if (0 === comparisonResult) {\n        if (a.__tmpIndex < b.__tmpIndex) {\n          return -1;\n        }\n\n        if (a.__tmpIndex > b.__tmpIndex) {\n          return 1;\n        }\n      }\n\n      return comparisonResult;\n    }\n  }, {\n    key: \"_sortCondition\",\n    value: function value() {}\n  }, {\n    key: \"_rowCondition\",\n    value: function value(a, b) {\n      var isSomeEdge = this._isSomeEdge(a, b);\n\n      var columnCondition = this._normalizeCondition(a.left, b.left, isSomeEdge),\n          rowCondition = this._normalizeCondition(a.top, b.top, isSomeEdge);\n\n      return columnCondition ? columnCondition : rowCondition ? rowCondition : a.isStart - b.isStart;\n    }\n  }, {\n    key: \"_columnCondition\",\n    value: function value(a, b) {\n      var isSomeEdge = this._isSomeEdge(a, b);\n\n      var columnCondition = this._normalizeCondition(a.left, b.left, isSomeEdge),\n          rowCondition = this._normalizeCondition(a.top, b.top, isSomeEdge);\n\n      return rowCondition ? rowCondition : columnCondition ? columnCondition : a.isStart - b.isStart;\n    }\n  }, {\n    key: \"_isSomeEdge\",\n    value: function value(a, b) {\n      return a.i === b.i && a.j === b.j;\n    }\n  }, {\n    key: \"_normalizeCondition\",\n    value: function value(first, second, isSomeEdge) {\n      var result = first - second;\n      return isSomeEdge || Math.abs(result) > 1 ? result : 0;\n    }\n  }, {\n    key: \"_getResultPositions\",\n    value: function value(sortedArray) {\n      var position,\n          stack = [],\n          indexes = [],\n          result = [],\n          intersectPositions = [],\n          intersectPositionCount = 0,\n          sortedIndex = 0;\n\n      for (var i = 0; i < sortedArray.length; i++) {\n        var j,\n            current = sortedArray[i];\n\n        if (current.isStart) {\n          position = void 0;\n\n          for (j = 0; j < indexes.length; j++) {\n            if (!indexes[j]) {\n              position = j;\n              indexes[j] = true;\n              break;\n            }\n          }\n\n          if (void 0 === position) {\n            position = indexes.length;\n            indexes.push(true);\n\n            for (j = 0; j < stack.length; j++) {\n              stack[j].count++;\n            }\n          }\n\n          stack.push({\n            index: position,\n            count: indexes.length,\n            i: current.i,\n            j: current.j,\n            sortedIndex: this._skipSortedIndex(position) ? null : sortedIndex++\n          });\n\n          if (intersectPositionCount < indexes.length) {\n            intersectPositionCount = indexes.length;\n          }\n        } else {\n          var removeIndex = this._findIndexByKey(stack, \"i\", \"j\", current.i, current.j),\n              resultItem = stack[removeIndex];\n\n          stack.splice(removeIndex, 1);\n          indexes[resultItem.index] = false;\n          intersectPositions.push(resultItem);\n\n          if (!stack.length) {\n            indexes = [];\n\n            for (var k = 0; k < intersectPositions.length; k++) {\n              intersectPositions[k].count = intersectPositionCount;\n            }\n\n            intersectPositions = [];\n            intersectPositionCount = 0;\n          }\n\n          result.push(resultItem);\n        }\n      }\n\n      return result.sort(function (a, b) {\n        var columnCondition = a.j - b.j,\n            rowCondition = a.i - b.i;\n        return rowCondition ? rowCondition : columnCondition;\n      });\n    }\n  }, {\n    key: \"_skipSortedIndex\",\n    value: function value(index) {\n      return this.instance.fire(\"getMaxAppointmentsPerCell\") && index > this._getMaxAppointmentCountPerCell() - 1;\n    }\n  }, {\n    key: \"_findIndexByKey\",\n    value: function value(arr, iKey, jKey, iValue, jValue) {\n      var result = 0;\n\n      for (var i = 0, len = arr.length; i < len; i++) {\n        if (arr[i][iKey] === iValue && arr[i][jKey] === jValue) {\n          result = i;\n          break;\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getExtendedPositionMap\",\n    value: function value(map, positions) {\n      var positionCounter = 0,\n          result = [];\n\n      for (var i = 0, mapLength = map.length; i < mapLength; i++) {\n        var resultString = [];\n\n        for (var j = 0, itemLength = map[i].length; j < itemLength; j++) {\n          map[i][j].index = positions[positionCounter].index;\n          map[i][j].sortedIndex = positions[positionCounter].sortedIndex;\n          map[i][j].count = positions[positionCounter++].count;\n          resultString.push(map[i][j]);\n\n          this._checkLongCompactAppointment(map[i][j], resultString);\n        }\n\n        result.push(resultString);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_checkLongCompactAppointment\",\n    value: function value() {}\n  }, {\n    key: \"_splitLongCompactAppointment\",\n    value: function value(item, result) {\n      var appointmentCountPerCell = this._getMaxAppointmentCountPerCellByType(item.allDay);\n\n      var compactCount = 0;\n\n      if (void 0 !== appointmentCountPerCell && item.index > appointmentCountPerCell - 1) {\n        item.isCompact = true;\n        compactCount = this._getCompactAppointmentParts(item.width);\n\n        for (var k = 1; k < compactCount; k++) {\n          var compactPart = (0, _extend.extend)(true, {}, item);\n          compactPart.left = this._getCompactLeftCoordinate(item.left, k);\n          compactPart.cellIndex = compactPart.cellIndex + k;\n          compactPart.sortedIndex = null;\n          result.push(compactPart);\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"startDate\",\n    value: function startDate(appointment, skipNormalize, position) {\n      var startDate = position && position.startDate,\n          rangeStartDate = this.instance._getStartDate(appointment, skipNormalize),\n          text = this.instance.fire(\"getField\", \"text\", appointment);\n\n      if (startDate && rangeStartDate > startDate || !startDate) {\n        startDate = rangeStartDate;\n      }\n\n      if (isNaN(startDate.getTime())) {\n        throw _ui2.default.Error(\"E1032\", text);\n      }\n\n      return startDate;\n    }\n  }, {\n    key: \"endDate\",\n    value: function endDate(appointment, position, isRecurring) {\n      var endDate = this.instance._getEndDate(appointment),\n          realStartDate = this.startDate(appointment, true),\n          viewStartDate = this.startDate(appointment, false, position);\n\n      if (viewStartDate.getTime() > endDate.getTime() || isRecurring) {\n        var recurrencePartStartDate = position ? position.initialStartDate || position.startDate : realStartDate,\n            recurrencePartCroppedByViewStartDate = position ? position.startDate : realStartDate,\n            fullDuration = endDate.getTime() - realStartDate.getTime();\n        fullDuration = this._adjustDurationByDaylightDiff(fullDuration, realStartDate, endDate);\n        endDate = new Date(viewStartDate.getTime() >= recurrencePartStartDate.getTime() ? recurrencePartStartDate.getTime() : viewStartDate.getTime());\n\n        if (isRecurring) {\n          endDate = new Date(endDate.getTime() + fullDuration);\n        }\n\n        if (!_date2.default.sameDate(realStartDate, endDate) && recurrencePartCroppedByViewStartDate.getTime() < viewStartDate.getTime()) {\n          var headDuration = _date2.default.trimTime(endDate).getTime() - recurrencePartCroppedByViewStartDate.getTime(),\n              tailDuration = fullDuration - headDuration || fullDuration;\n          endDate = new Date(_date2.default.trimTime(viewStartDate).getTime() + tailDuration);\n        }\n      }\n\n      if (!this.isAllDay(appointment)) {\n        var viewEndDate = _date2.default.roundToHour(this.instance.fire(\"getEndViewDate\"));\n\n        if (endDate > viewEndDate) {\n          endDate = viewEndDate;\n        }\n      }\n\n      return endDate;\n    }\n  }, {\n    key: \"_adjustDurationByDaylightDiff\",\n    value: function value(duration, startDate, endDate) {\n      var daylightDiff = this.instance.fire(\"getDaylightOffset\", startDate, endDate);\n      return this._needAdjustDuration(daylightDiff) ? this._calculateDurationByDaylightDiff(duration, daylightDiff) : duration;\n    }\n  }, {\n    key: \"_needAdjustDuration\",\n    value: function value(diff) {\n      return 0 !== diff;\n    }\n  }, {\n    key: \"_calculateDurationByDaylightDiff\",\n    value: function value(duration, diff) {\n      return duration + diff * toMs(\"minute\");\n    }\n  }, {\n    key: \"_getAppointmentDurationInMs\",\n    value: function value(startDate, endDate, allDay) {\n      var result;\n      this.instance.fire(\"getAppointmentDurationInMs\", {\n        startDate: startDate,\n        endDate: endDate,\n        allDay: allDay,\n        callback: function callback(duration) {\n          result = duration;\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"_getMaxNeighborAppointmentCount\",\n    value: function value() {\n      var overlappingMode = this.instance.fire(\"getMaxAppointmentsPerCell\");\n\n      if (!overlappingMode) {\n        var outerAppointmentWidth = this.getCompactAppointmentDefaultWidth() + this.getCompactAppointmentLeftOffset();\n        return Math.floor(this.getDropDownAppointmentWidth() / outerAppointmentWidth);\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: \"_markAppointmentAsVirtual\",\n    value: function value(coordinates, isAllDay) {\n      var countFullWidthAppointmentInCell = this._getMaxAppointmentCountPerCellByType(isAllDay);\n\n      if (coordinates.count - countFullWidthAppointmentInCell > this._getMaxNeighborAppointmentCount()) {\n        coordinates.virtual = {\n          top: coordinates.top,\n          left: coordinates.left,\n          index: coordinates.groupIndex + \"-\" + coordinates.rowIndex + \"-\" + coordinates.cellIndex,\n          isAllDay: isAllDay\n        };\n      }\n    }\n  }, {\n    key: \"_getMaxAppointmentCountPerCellByType\",\n    value: function value(isAllDay) {\n      var appointmentCountPerCell = this._getMaxAppointmentCountPerCell();\n\n      if (_type2.default.isObject(appointmentCountPerCell)) {\n        return isAllDay ? this._getMaxAppointmentCountPerCell().allDay : this._getMaxAppointmentCountPerCell().simple;\n      } else {\n        return appointmentCountPerCell;\n      }\n    }\n  }, {\n    key: \"getDropDownAppointmentWidth\",\n    value: function value(intervalCount, isAllDay) {\n      return this.getPositioningStrategy().getDropDownAppointmentWidth(intervalCount, isAllDay);\n    }\n  }, {\n    key: \"getDropDownAppointmentHeight\",\n    value: function value() {\n      return this.getPositioningStrategy().getDropDownAppointmentHeight();\n    }\n  }, {\n    key: \"getDropDownButtonAdaptiveSize\",\n    value: function value() {\n      return DROP_DOWN_BUTTON_ADAPTIVE_SIZE;\n    }\n  }, {\n    key: \"getDefaultCellWidth\",\n    value: function value() {\n      return this._defaultWidth;\n    }\n  }, {\n    key: \"getDefaultCellHeight\",\n    value: function value() {\n      return this._defaultHeight;\n    }\n  }, {\n    key: \"getDefaultAllDayCellHeight\",\n    value: function value() {\n      return this._allDayHeight;\n    }\n  }, {\n    key: \"getCompactAppointmentDefaultWidth\",\n    value: function value() {\n      return COMPACT_APPOINTMENT_DEFAULT_WIDTH;\n    }\n  }, {\n    key: \"getCompactAppointmentTopOffset\",\n    value: function value(allDay) {\n      return this.getPositioningStrategy().getCompactAppointmentTopOffset(allDay);\n    }\n  }, {\n    key: \"getCompactAppointmentLeftOffset\",\n    value: function value() {\n      return this.getPositioningStrategy().getCompactAppointmentLeftOffset();\n    }\n  }, {\n    key: \"getAppointmentDataCalculator\",\n    value: function value() {}\n  }, {\n    key: \"_customizeCoordinates\",\n    value: function value(coordinates, height, appointmentCountPerCell, topOffset, isAllDay) {\n      var compactAppointmentDefaultSize,\n          compactAppointmentLeftOffset,\n          index = coordinates.index,\n          appointmentHeight = height / appointmentCountPerCell,\n          appointmentTop = coordinates.top + index * appointmentHeight,\n          top = appointmentTop + topOffset,\n          width = coordinates.width,\n          left = coordinates.left,\n          compactAppointmentTopOffset = this.getCompactAppointmentTopOffset(isAllDay);\n\n      if (coordinates.isCompact) {\n        compactAppointmentDefaultSize = this.getCompactAppointmentDefaultWidth();\n        compactAppointmentLeftOffset = this.getCompactAppointmentLeftOffset();\n        top = coordinates.top + compactAppointmentTopOffset;\n        left = coordinates.left + (index - appointmentCountPerCell) * (compactAppointmentDefaultSize + compactAppointmentLeftOffset) + compactAppointmentLeftOffset;\n\n        if (this.instance.fire(\"isAdaptive\")) {\n          coordinates.top = top;\n          coordinates.left = coordinates.left + compactAppointmentLeftOffset;\n        }\n\n        appointmentHeight = compactAppointmentDefaultSize;\n        width = compactAppointmentDefaultSize;\n\n        this._markAppointmentAsVirtual(coordinates, isAllDay);\n      }\n\n      return {\n        height: appointmentHeight,\n        width: width,\n        top: top,\n        left: left,\n        empty: this._isAppointmentEmpty(height, width)\n      };\n    }\n  }, {\n    key: \"_isAppointmentEmpty\",\n    value: function value(height, width) {\n      return height < this._getAppointmentMinHeight() || width < this._getAppointmentMinWidth();\n    }\n  }, {\n    key: \"_calculateGeometryConfig\",\n    value: function value(coordinates) {\n      var overlappingMode = this.instance.fire(\"getMaxAppointmentsPerCell\"),\n          offsets = this._getOffsets(),\n          appointmentDefaultOffset = this._getAppointmentDefaultOffset();\n\n      var appointmentCountPerCell = this._getAppointmentCount(overlappingMode, coordinates);\n\n      var ratio = this._getDefaultRatio(coordinates, appointmentCountPerCell);\n\n      var maxHeight = this._getMaxHeight();\n\n      if (!(0, _type.isNumeric)(appointmentCountPerCell)) {\n        appointmentCountPerCell = coordinates.count;\n        ratio = (maxHeight - offsets.unlimited) / maxHeight;\n      }\n\n      var topOffset = (1 - ratio) * maxHeight;\n\n      if (\"auto\" === overlappingMode || (0, _type.isNumeric)(overlappingMode)) {\n        ratio = 1;\n        maxHeight -= appointmentDefaultOffset;\n        topOffset = appointmentDefaultOffset;\n      }\n\n      return {\n        height: ratio * maxHeight,\n        appointmentCountPerCell: appointmentCountPerCell,\n        offset: topOffset\n      };\n    }\n  }, {\n    key: \"_getAppointmentCount\",\n    value: function value() {}\n  }, {\n    key: \"_getDefaultRatio\",\n    value: function value() {}\n  }, {\n    key: \"_getOffsets\",\n    value: function value() {}\n  }, {\n    key: \"_getMaxHeight\",\n    value: function value() {}\n  }, {\n    key: \"_needVerifyItemSize\",\n    value: function value() {\n      return false;\n    }\n  }, {\n    key: \"needSeparateAppointment\",\n    value: function value(allDay) {\n      return this.instance.fire(\"isGroupedByDate\") && allDay;\n    }\n  }, {\n    key: \"_getMaxAppointmentCountPerCell\",\n    value: function value() {\n      if (!this._maxAppointmentCountPerCell) {\n        var appointmentCountPerCell,\n            overlappingMode = this.instance.fire(\"getMaxAppointmentsPerCell\");\n\n        if (!overlappingMode) {\n          appointmentCountPerCell = 2;\n        }\n\n        if ((0, _type.isNumeric)(overlappingMode)) {\n          appointmentCountPerCell = overlappingMode;\n        }\n\n        if (\"auto\" === overlappingMode) {\n          appointmentCountPerCell = this._getDynamicAppointmentCountPerCell();\n        }\n\n        if (\"unlimited\" === overlappingMode) {\n          appointmentCountPerCell = void 0;\n        }\n\n        this._maxAppointmentCountPerCell = appointmentCountPerCell;\n      }\n\n      return this._maxAppointmentCountPerCell;\n    }\n  }, {\n    key: \"_getDynamicAppointmentCountPerCell\",\n    value: function value() {\n      return this.getPositioningStrategy().getDynamicAppointmentCountPerCell();\n    }\n  }, {\n    key: \"hasAllDayAppointments\",\n    value: function value() {\n      return false;\n    }\n  }, {\n    key: \"_isCompactTheme\",\n    value: function value() {\n      return \"compact\" === (_themes2.default.current() || \"\").split(\".\").pop();\n    }\n  }, {\n    key: \"_getAppointmentDefaultOffset\",\n    value: function value() {\n      return this.getPositioningStrategy().getAppointmentDefaultOffset();\n    }\n  }, {\n    key: \"_getAppointmentDefaultHeight\",\n    value: function value() {\n      return this._getAppointmentHeightByTheme();\n    }\n  }, {\n    key: \"_getAppointmentMinHeight\",\n    value: function value() {\n      return this._getAppointmentDefaultHeight();\n    }\n  }, {\n    key: \"_getAppointmentHeightByTheme\",\n    value: function value() {\n      return this._isCompactTheme() ? COMPACT_THEME_APPOINTMENT_DEFAULT_HEIGHT : APPOINTMENT_DEFAULT_HEIGHT;\n    }\n  }, {\n    key: \"_getAppointmentDefaultWidth\",\n    value: function value() {\n      return this.getPositioningStrategy()._getAppointmentDefaultWidth();\n    }\n  }, {\n    key: \"_getAppointmentMinWidth\",\n    value: function value() {\n      return this._getAppointmentDefaultWidth();\n    }\n  }, {\n    key: \"_needVerticalGroupBounds\",\n    value: function value() {\n      return false;\n    }\n  }, {\n    key: \"_needHorizontalGroupBounds\",\n    value: function value() {\n      return false;\n    }\n  }]);\n\n  return BaseRenderingStrategy;\n}();\n\nmodule.exports = BaseRenderingStrategy;","map":null,"metadata":{},"sourceType":"script"}