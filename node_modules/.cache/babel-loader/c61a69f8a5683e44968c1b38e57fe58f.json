{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/utils.recurrence.js)\r\n * Version: 19.1.6 (build 19263-1729)\r\n * Build date: Fri Sep 20 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar errors = require(\"../../core/errors\"),\n    extend = require(\"../../core/utils/extend\").extend,\n    each = require(\"../../core/utils/iterator\").each,\n    inArray = require(\"../../core/utils/array\").inArray,\n    dateUtils = require(\"../../core/utils/date\");\n\nvar toMs = dateUtils.dateToMilliseconds;\nvar leastDaysInWeek = 4;\nvar intervalMap = {\n  secondly: \"seconds\",\n  minutely: \"minutes\",\n  hourly: \"hours\",\n  daily: \"days\",\n  weekly: \"weeks\",\n  monthly: \"months\",\n  yearly: \"years\"\n};\nvar dateSetterMap = {\n  bysecond: function bysecond(date, value) {\n    date.setSeconds(value);\n  },\n  byminute: function byminute(date, value) {\n    date.setMinutes(value);\n  },\n  byhour: function byhour(date, value) {\n    date.setHours(value);\n  },\n  bymonth: function bymonth(date, value) {\n    date.setMonth(value);\n  },\n  bymonthday: function bymonthday(date, value) {\n    if (value < 0) {\n      var initialDate = new Date(date);\n      setDateByNegativeValue(initialDate, 1, -1);\n      var daysInMonth = initialDate.getDate();\n\n      if (daysInMonth >= Math.abs(value)) {\n        setDateByNegativeValue(date, 1, value);\n      } else {\n        setDateByNegativeValue(date, 2, value);\n      }\n    } else {\n      date.setDate(value);\n      correctDate(date, value);\n    }\n  },\n  byday: function byday(date, byDay, appointmentWeekStart, frequency, firstDayOfWeek) {\n    var dayOfWeek = byDay;\n\n    if ((\"DAILY\" === frequency || \"WEEKLY\" === frequency) && (firstDayOfWeek && 0 !== byDay || !firstDayOfWeek && 0 === byDay)) {\n      dayOfWeek = 7;\n    }\n\n    byDay += days[appointmentWeekStart] > dayOfWeek ? 7 : 0;\n    date.setDate(date.getDate() - date.getDay() + byDay);\n  },\n  byweekno: function byweekno(date, weekNumber, weekStart) {\n    var initialDate = new Date(date),\n        firstYearDate = new Date(initialDate.setMonth(0, 1)),\n        dayShift = firstYearDate.getDay() - days[weekStart],\n        firstDayOfYear = firstYearDate.getTime() - dayShift * toMs(\"day\"),\n        newFirstYearDate = dayShift + 1;\n\n    if (newFirstYearDate > leastDaysInWeek) {\n      date.setTime(firstDayOfYear + 7 * weekNumber * toMs(\"day\"));\n    } else {\n      date.setTime(firstDayOfYear + 7 * (weekNumber - 1) * toMs(\"day\"));\n    }\n\n    var timezoneDiff = (date.getTimezoneOffset() - firstYearDate.getTimezoneOffset()) * toMs(\"minute\");\n    timezoneDiff && date.setTime(date.getTime() + timezoneDiff);\n  },\n  byyearday: function byyearday(date, dayOfYear) {\n    date.setMonth(0, 1);\n    date.setDate(dayOfYear);\n  }\n};\n\nvar setDateByNegativeValue = function setDateByNegativeValue(date, month, value) {\n  var initialDate = new Date(date);\n  date.setMonth(date.getMonth() + month);\n\n  if (date.getMonth() - initialDate.getMonth() > month) {\n    date.setDate(value + 1);\n  }\n\n  date.setDate(value + 1);\n};\n\nvar dateGetterMap = {\n  bysecond: function bysecond(date) {\n    return date.getSeconds();\n  },\n  byminute: function byminute(date) {\n    return date.getMinutes();\n  },\n  byhour: function byhour(date) {\n    return date.getHours();\n  },\n  bymonth: function bymonth(date) {\n    return date.getMonth();\n  },\n  bymonthday: function bymonthday(date) {\n    return date.getDate();\n  },\n  byday: function byday(date) {\n    return date.getDay();\n  },\n  byweekno: function byweekno(date, weekStart) {\n    var daysFromYearStart,\n        current = new Date(date),\n        diff = leastDaysInWeek - current.getDay() + days[weekStart] - 1,\n        dayInMilliseconds = toMs(\"day\");\n\n    if (date.getDay() < days[weekStart]) {\n      diff -= 7;\n    }\n\n    current.setHours(0, 0, 0);\n    current.setDate(current.getDate() + diff);\n    var yearStart = new Date(current.getFullYear(), 0, 1),\n        timezoneDiff = (yearStart.getTimezoneOffset() - current.getTimezoneOffset()) * toMs(\"minute\");\n    daysFromYearStart = 1 + (current - yearStart + timezoneDiff) / dayInMilliseconds;\n    return Math.ceil(daysFromYearStart / 7);\n  },\n  byyearday: function byyearday(date) {\n    var yearStart = new Date(date.getFullYear(), 0, 0),\n        timezoneDiff = date.getTimezoneOffset() - yearStart.getTimezoneOffset(),\n        diff = date - yearStart - timezoneDiff * toMs(\"minute\"),\n        dayLength = toMs(\"day\");\n    return Math.floor(diff / dayLength);\n  }\n};\nvar ruleNames = [\"freq\", \"interval\", \"byday\", \"byweekno\", \"byyearday\", \"bymonth\", \"bymonthday\", \"count\", \"until\", \"byhour\", \"byminute\", \"bysecond\", \"bysetpos\", \"wkst\"],\n    freqNames = [\"DAILY\", \"WEEKLY\", \"MONTHLY\", \"YEARLY\", \"SECONDLY\", \"MINUTELY\", \"HOURLY\"],\n    days = {\n  SU: 0,\n  MO: 1,\n  TU: 2,\n  WE: 3,\n  TH: 4,\n  FR: 5,\n  SA: 6\n},\n    daysNames = {\n  0: \"SU\",\n  1: \"MO\",\n  2: \"TU\",\n  3: \"WE\",\n  4: \"TH\",\n  5: \"FR\",\n  6: \"SA\"\n};\n\nvar getTimeZoneOffset = function getTimeZoneOffset() {\n  return new Date().getTimezoneOffset();\n};\n\nvar dateInRecurrenceRange = function dateInRecurrenceRange(options) {\n  var result = [];\n\n  if (options.rule) {\n    result = getDatesByRecurrence(options);\n  }\n\n  return !!result.length;\n};\n\nvar normalizeInterval = function normalizeInterval(rule) {\n  var interval = rule.interval,\n      freq = rule.freq,\n      intervalObject = {},\n      intervalField = intervalMap[freq.toLowerCase()];\n\n  if (\"MONTHLY\" === freq && rule.byday) {\n    intervalField = intervalMap.daily;\n  }\n\n  intervalObject[intervalField] = interval;\n  return intervalObject;\n};\n\nvar getDatesByRecurrenceException = function getDatesByRecurrenceException(ruleValues, date) {\n  var result = [];\n\n  for (var i = 0, len = ruleValues.length; i < len; i++) {\n    result[i] = getDateByAsciiString(ruleValues[i], date);\n  }\n\n  return result;\n};\n\nvar dateIsRecurrenceException = function dateIsRecurrenceException(date, recurrenceException) {\n  var result = false;\n\n  if (!recurrenceException) {\n    return result;\n  }\n\n  var splitDates = recurrenceException.split(\",\"),\n      exceptDates = getDatesByRecurrenceException(splitDates, date),\n      shortFormat = /\\d{8}$/;\n\n  for (var i = 0, len = exceptDates.length; i < len; i++) {\n    if (splitDates[i].match(shortFormat)) {\n      var diffs = getDatePartDiffs(date, exceptDates[i]);\n\n      if (0 === diffs.years && 0 === diffs.months && 0 === diffs.days) {\n        result = true;\n      }\n    } else {\n      if (date.getTime() === exceptDates[i].getTime()) {\n        result = true;\n      }\n    }\n  }\n\n  return result;\n};\n\nvar doNextIteration = function doNextIteration(date, startIntervalDate, endIntervalDate, recurrenceRule, iterationCount) {\n  var dateInInterval,\n      matchCountIsCorrect = true;\n  endIntervalDate = endIntervalDate.getTime();\n\n  if (recurrenceRule.until) {\n    if (recurrenceRule.until.getTime() < endIntervalDate) {\n      endIntervalDate = recurrenceRule.until.getTime();\n    }\n  }\n\n  if (recurrenceRule.count) {\n    if (iterationCount === recurrenceRule.count) {\n      matchCountIsCorrect = false;\n    }\n  }\n\n  dateInInterval = date.getTime() <= endIntervalDate;\n  return dateInInterval && matchCountIsCorrect;\n};\n\nvar getDatesByRecurrence = function getDatesByRecurrence(options) {\n  var dateRules,\n      result = [],\n      recurrenceRule = getRecurrenceRule(options.rule),\n      iterationResult = {},\n      rule = recurrenceRule.rule,\n      recurrenceStartDate = options.start;\n\n  if (!recurrenceRule.isValid || !rule.freq) {\n    return result;\n  }\n\n  rule.interval = normalizeInterval(rule);\n  dateRules = splitDateRules(rule, options.firstDayOfWeek);\n  var duration = options.end ? options.end.getTime() - options.start.getTime() : toMs(\"day\");\n  var config = {\n    exception: options.exception,\n    min: options.min,\n    dateRules: dateRules,\n    rule: rule,\n    recurrenceStartDate: recurrenceStartDate,\n    recurrenceEndDate: options.end,\n    duration: duration\n  };\n\n  if (dateRules.length && rule.count) {\n    var iteration = 0;\n    getDatesByCount(dateRules, new Date(recurrenceStartDate), new Date(recurrenceStartDate), rule).forEach(function (currentDate, i) {\n      if (currentDate < options.max) {\n        iteration++;\n        iterationResult = pushToResult(iteration, iterationResult, currentDate, i, config, true);\n      }\n    });\n  } else {\n    getDatesByRules(dateRules, new Date(recurrenceStartDate), rule).forEach(function (currentDate, i) {\n      var iteration = 0;\n\n      while (doNextIteration(currentDate, recurrenceStartDate, options.max, rule, iteration)) {\n        iteration++;\n        iterationResult = pushToResult(iteration, iterationResult, currentDate, i, config);\n        currentDate = incrementDate(currentDate, recurrenceStartDate, rule, i);\n      }\n    });\n  }\n\n  if (rule.bysetpos) {\n    each(iterationResult, function (iterationIndex, iterationDates) {\n      iterationResult[iterationIndex] = filterDatesBySetPos(iterationDates, rule.bysetpos);\n    });\n  }\n\n  each(iterationResult, function (_, iterationDates) {\n    result = result.concat(iterationDates);\n  });\n  result.sort(function (a, b) {\n    return a - b;\n  });\n  return result;\n};\n\nvar pushToResult = function pushToResult(iteration, iterationResult, currentDate, i, config, verifiedField) {\n  if (!iterationResult[iteration]) {\n    iterationResult[iteration] = [];\n  }\n\n  if (checkDate(currentDate, i, config, verifiedField)) {\n    iterationResult[iteration].push(currentDate);\n  }\n\n  return iterationResult;\n};\n\nvar checkDate = function checkDate(currentDate, i, config, verifiedField) {\n  if (!dateIsRecurrenceException(currentDate, config.exception)) {\n    var duration = dateUtils.sameDate(currentDate, config.recurrenceEndDate) && config.recurrenceEndDate.getTime() > currentDate.getTime() ? config.recurrenceEndDate.getTime() - currentDate.getTime() : config.duration;\n\n    if (currentDate.getTime() >= config.recurrenceStartDate.getTime() && currentDate.getTime() + duration > config.min.getTime()) {\n      return verifiedField || checkDateByRule(currentDate, [config.dateRules[i]], config.rule.wkst);\n    }\n  }\n\n  return false;\n};\n\nvar filterDatesBySetPos = function filterDatesBySetPos(dates, bySetPos) {\n  var resultArray = [];\n  bySetPos.split(\",\").forEach(function (index) {\n    index = Number(index);\n    var dateIndex = index > 0 ? index - 1 : dates.length + index;\n\n    if (dates[dateIndex]) {\n      resultArray.push(dates[dateIndex]);\n    }\n  });\n  return resultArray;\n};\n\nvar correctDate = function correctDate(originalDate, date) {\n  if (originalDate.getDate() !== date) {\n    originalDate.setDate(date);\n  }\n};\n\nvar incrementDate = function incrementDate(date, originalStartDate, rule, iterationStep) {\n  var initialDate = new Date(date),\n      needCorrect = true;\n  date = dateUtils.addInterval(date, rule.interval);\n\n  if (\"MONTHLY\" === rule.freq && !rule.byday) {\n    var expectedDate = originalStartDate.getDate();\n\n    if (rule.bymonthday) {\n      expectedDate = Number(rule.bymonthday.split(\",\")[iterationStep]);\n\n      if (expectedDate < 0) {\n        initialDate.setMonth(initialDate.getMonth() + 1, 1);\n        dateSetterMap.bymonthday(initialDate, expectedDate);\n        date = initialDate;\n        needCorrect = false;\n      }\n    }\n\n    needCorrect && correctDate(date, expectedDate);\n  }\n\n  if (\"YEARLY\" === rule.freq) {\n    if (rule.byyearday) {\n      var dayNumber = Number(rule.byyearday.split(\",\")[iterationStep]);\n      dateSetterMap.byyearday(date, dayNumber);\n    }\n\n    var dateRules = splitDateRules(rule);\n\n    for (var field in dateRules[iterationStep]) {\n      dateSetterMap[field] && dateSetterMap[field](date, dateRules[iterationStep][field], rule.wkst);\n    }\n  }\n\n  return date;\n};\n\nvar getDatePartDiffs = function getDatePartDiffs(date1, date2) {\n  return {\n    years: date1.getFullYear() - date2.getFullYear(),\n    months: date1.getMonth() - date2.getMonth(),\n    days: date1.getDate() - date2.getDate(),\n    hours: date1.getHours() - date2.getHours(),\n    minutes: date1.getMinutes() - date2.getMinutes(),\n    seconds: date1.getSeconds() - date2.getSeconds()\n  };\n};\n\nvar getRecurrenceRule = function getRecurrenceRule(recurrence) {\n  var result = {\n    rule: {},\n    isValid: false\n  };\n\n  if (recurrence) {\n    result.rule = parseRecurrenceRule(recurrence);\n    result.isValid = validateRRule(result.rule, recurrence);\n  }\n\n  return result;\n};\n\nvar loggedWarnings = [];\n\nvar validateRRule = function validateRRule(rule, recurrence) {\n  if (brokenRuleNameExists(rule) || inArray(rule.freq, freqNames) === -1 || wrongCountRule(rule) || wrongIntervalRule(rule) || wrongDayOfWeek(rule) || wrongByMonthDayRule(rule) || wrongByMonth(rule) || wrongUntilRule(rule)) {\n    logBrokenRule(recurrence);\n    return false;\n  }\n\n  return true;\n};\n\nvar wrongUntilRule = function wrongUntilRule(rule) {\n  var wrongUntil = false,\n      until = rule.until;\n\n  if (void 0 !== until && !(until instanceof Date)) {\n    wrongUntil = true;\n  }\n\n  return wrongUntil;\n};\n\nvar wrongCountRule = function wrongCountRule(rule) {\n  var wrongCount = false,\n      count = rule.count;\n\n  if (count && \"string\" === typeof count) {\n    wrongCount = true;\n  }\n\n  return wrongCount;\n};\n\nvar wrongByMonthDayRule = function wrongByMonthDayRule(rule) {\n  var wrongByMonthDay = false,\n      byMonthDay = rule.bymonthday;\n\n  if (byMonthDay && isNaN(parseInt(byMonthDay))) {\n    wrongByMonthDay = true;\n  }\n\n  return wrongByMonthDay;\n};\n\nvar wrongByMonth = function wrongByMonth(rule) {\n  var wrongByMonth = false,\n      byMonth = rule.bymonth;\n\n  if (byMonth && isNaN(parseInt(byMonth))) {\n    wrongByMonth = true;\n  }\n\n  return wrongByMonth;\n};\n\nvar wrongIntervalRule = function wrongIntervalRule(rule) {\n  var wrongInterval = false,\n      interval = rule.interval;\n\n  if (interval && \"string\" === typeof interval) {\n    wrongInterval = true;\n  }\n\n  return wrongInterval;\n};\n\nvar wrongDayOfWeek = function wrongDayOfWeek(rule) {\n  var daysByRule = daysFromByDayRule(rule),\n      brokenDaysExist = false;\n  each(daysByRule, function (_, day) {\n    if (!Object.prototype.hasOwnProperty.call(days, day)) {\n      brokenDaysExist = true;\n      return false;\n    }\n  });\n  return brokenDaysExist;\n};\n\nvar brokenRuleNameExists = function brokenRuleNameExists(rule) {\n  var brokenRuleExists = false;\n  each(rule, function (ruleName) {\n    if (inArray(ruleName, ruleNames) === -1) {\n      brokenRuleExists = true;\n      return false;\n    }\n  });\n  return brokenRuleExists;\n};\n\nvar logBrokenRule = function logBrokenRule(recurrence) {\n  if (inArray(recurrence, loggedWarnings) === -1) {\n    errors.log(\"W0006\", recurrence);\n    loggedWarnings.push(recurrence);\n  }\n};\n\nvar parseRecurrenceRule = function parseRecurrenceRule(recurrence) {\n  var ruleObject = {},\n      ruleParts = recurrence.split(\";\");\n\n  for (var i = 0, len = ruleParts.length; i < len; i++) {\n    var rule = ruleParts[i].split(\"=\"),\n        ruleName = rule[0].toLowerCase(),\n        ruleValue = rule[1];\n    ruleObject[ruleName] = ruleValue;\n  }\n\n  var count = parseInt(ruleObject.count);\n\n  if (!isNaN(count)) {\n    ruleObject.count = count;\n  }\n\n  if (ruleObject.interval) {\n    var interval = parseInt(ruleObject.interval);\n\n    if (!isNaN(interval)) {\n      ruleObject.interval = interval;\n    }\n  } else {\n    ruleObject.interval = 1;\n  }\n\n  if (ruleObject.freq && ruleObject.until) {\n    ruleObject.until = getDateByAsciiString(ruleObject.until);\n  }\n\n  return ruleObject;\n};\n\nvar getDateByAsciiString = function getDateByAsciiString(string, initialDate) {\n  if (\"string\" !== typeof string) {\n    return string;\n  }\n\n  var arrayDate = string.match(/(\\d{4})(\\d{2})(\\d{2})(T(\\d{2})(\\d{2})(\\d{2}))?(Z)?/);\n\n  if (!arrayDate) {\n    return null;\n  }\n\n  var isUTC = void 0 !== arrayDate[8],\n      currentOffset = initialDate ? initialDate.getTimezoneOffset() : resultUtils.getTimeZoneOffset(),\n      date = new (Function.prototype.bind.apply(Date, prepareDateArrayToParse(arrayDate)))();\n  currentOffset = 6e4 * currentOffset;\n\n  if (isUTC) {\n    date = new Date(date.getTime() - currentOffset);\n  }\n\n  return date;\n};\n\nvar prepareDateArrayToParse = function prepareDateArrayToParse(arrayDate) {\n  arrayDate.shift();\n\n  if (void 0 === arrayDate[3]) {\n    arrayDate.splice(3);\n  } else {\n    arrayDate.splice(3, 1);\n    arrayDate.splice(6);\n  }\n\n  arrayDate[1]--;\n  arrayDate.unshift(null);\n  return arrayDate;\n};\n\nvar daysFromByDayRule = function daysFromByDayRule(rule) {\n  var result = [];\n\n  if (rule.byday) {\n    if (Array.isArray(rule.byday)) {\n      result = rule.byday;\n    } else {\n      result = rule.byday.split(\",\");\n    }\n  }\n\n  return result;\n};\n\nvar getAsciiStringByDate = function getAsciiStringByDate(date) {\n  var currentOffset = 6e4 * resultUtils.getTimeZoneOffset();\n  date = new Date(date.getTime() + currentOffset);\n  return date.getFullYear() + (\"0\" + (date.getMonth() + 1)).slice(-2) + (\"0\" + date.getDate()).slice(-2) + \"T\" + (\"0\" + date.getHours()).slice(-2) + (\"0\" + date.getMinutes()).slice(-2) + (\"0\" + date.getSeconds()).slice(-2) + \"Z\";\n};\n\nvar splitDateRules = function splitDateRules(rule) {\n  var firstDayOfWeek = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n  var result = [];\n\n  if (firstDayOfWeek) {\n    rule.fdow = firstDayOfWeek;\n  }\n\n  if (!rule.wkst) {\n    if (firstDayOfWeek) {\n      rule.wkst = daysNames[firstDayOfWeek];\n    } else {\n      rule.wkst = \"MO\";\n    }\n  }\n\n  if (rule.byweekno && !rule.byday) {\n    var dayNames = Object.keys(days);\n\n    for (var i = 0; i < days[rule.wkst]; i++) {\n      dayNames.push(dayNames.shift());\n    }\n\n    rule.byday = dayNames.join(\",\");\n  }\n\n  for (var field in dateSetterMap) {\n    if (!rule[field]) {\n      continue;\n    }\n\n    var ruleFieldValues = rule[field].split(\",\"),\n        ruleArray = getDateRuleArray(field, ruleFieldValues);\n    result = result.length ? extendObjectArray(ruleArray, result) : ruleArray;\n  }\n\n  return result;\n};\n\nvar getDateRuleArray = function getDateRuleArray(field, values) {\n  var result = [];\n\n  for (var i = 0, length = values.length; i < length; i++) {\n    var dateRule = {};\n    dateRule[field] = handleRuleFieldValue(field, values[i]);\n    result.push(dateRule);\n  }\n\n  return result;\n};\n\nvar handleRuleFieldValue = function handleRuleFieldValue(field, value) {\n  var result = parseInt(value);\n\n  if (\"bymonth\" === field) {\n    result -= 1;\n  }\n\n  if (\"byday\" === field) {\n    result = days[value];\n  }\n\n  return result;\n};\n\nvar extendObjectArray = function extendObjectArray(firstArray, secondArray) {\n  var result = [];\n\n  for (var i = 0, firstArrayLength = firstArray.length; i < firstArrayLength; i++) {\n    for (var j = 0, secondArrayLength = secondArray.length; j < secondArrayLength; j++) {\n      result.push(extend({}, firstArray[i], secondArray[j]));\n    }\n  }\n\n  return result;\n};\n\nvar getDatesByRules = function getDatesByRules(dateRules, startDate, rule) {\n  var result = [];\n\n  for (var i = 0, len = dateRules.length; i < len; i++) {\n    var current = dateRules[i],\n        updatedDate = new Date(startDate);\n\n    for (var field in current) {\n      dateSetterMap[field] && dateSetterMap[field](updatedDate, current[field], rule.wkst, rule.freq, rule.fdow);\n    }\n\n    if (Array.isArray(updatedDate)) {\n      result = result.concat(updatedDate);\n    } else {\n      result.push(new Date(updatedDate));\n    }\n  }\n\n  if (!result.length) {\n    result.push(startDate);\n  }\n\n  return result;\n};\n\nvar getDatesByCount = function getDatesByCount(dateRules, startDate, recurrenceStartDate, rule) {\n  var result = [],\n      count = rule.count,\n      counter = 0,\n      date = prepareDate(startDate, dateRules);\n\n  while (counter < count) {\n    var dates = getDatesByRules(dateRules, date, rule);\n    var checkedDates = [];\n\n    for (var i = 0; i < dates.length; i++) {\n      if (dates[i].getTime() >= recurrenceStartDate.getTime()) {\n        checkedDates.push(dates[i]);\n      }\n    }\n\n    var length = checkedDates.length;\n    counter += length;\n    var delCount = counter - count;\n\n    if (counter > count) {\n      checkedDates.splice(length - delCount, delCount);\n    }\n\n    for (i = 0; i < checkedDates.length; i++) {\n      result.push(checkedDates[i]);\n    }\n\n    var interval = rule.interval;\n\n    if (\"days\" === Object.keys(interval)[0]) {\n      interval = {\n        weeks: 1\n      };\n    }\n\n    date = dateUtils.addInterval(date, interval);\n  }\n\n  return result;\n};\n\nvar prepareDate = function prepareDate(startDate, dateRules) {\n  var date = new Date(startDate);\n\n  if (dateRules.length && dateRules[0].byday) {\n    date.setDate(date.getDate() - date.getDay() + dateRules[0].byday);\n  } else {\n    date.setDate(1);\n  }\n\n  return date;\n};\n\nvar checkDateByRule = function checkDateByRule(date, rules, weekStart) {\n  var result = false;\n\n  for (var i = 0; i < rules.length; i++) {\n    var current = rules[i],\n        currentRuleResult = true;\n\n    for (var field in current) {\n      var processNegative = \"bymonthday\" === field && current[field] < 0;\n\n      if (dateGetterMap[field] && !processNegative && current[field] !== dateGetterMap[field](date, weekStart)) {\n        currentRuleResult = false;\n      }\n    }\n\n    result = result || currentRuleResult;\n  }\n\n  return result || !rules.length;\n};\n\nvar getRecurrenceString = function getRecurrenceString(object) {\n  if (!object || !object.freq) {\n    return;\n  }\n\n  var result = \"\";\n\n  for (var field in object) {\n    var value = object[field];\n\n    if (\"interval\" === field && value < 2) {\n      continue;\n    }\n\n    if (\"until\" === field) {\n      value = getAsciiStringByDate(value);\n    }\n\n    result += field + \"=\" + value + \";\";\n  }\n\n  result = result.substring(0, result.length - 1);\n  return result.toUpperCase();\n};\n\nvar resultUtils = {\n  getRecurrenceString: getRecurrenceString,\n  getRecurrenceRule: getRecurrenceRule,\n  getAsciiStringByDate: getAsciiStringByDate,\n  getDatesByRecurrence: getDatesByRecurrence,\n  dateInRecurrenceRange: dateInRecurrenceRange,\n  getDateByAsciiString: getDateByAsciiString,\n  daysFromByDayRule: daysFromByDayRule,\n  getTimeZoneOffset: getTimeZoneOffset\n};\nmodule.exports = resultUtils;","map":null,"metadata":{},"sourceType":"script"}