{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/rendering_strategies/ui.scheduler.appointments.strategy.agenda.js)\r\n * Version: 19.1.6 (build 19263-1729)\r\n * Build date: Fri Sep 20 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n\n      if (\"value\" in descriptor) {\n        descriptor.writable = true;\n      }\n\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) {\n      defineProperties(Constructor.prototype, protoProps);\n    }\n\n    if (staticProps) {\n      defineProperties(Constructor, staticProps);\n    }\n\n    return Constructor;\n  };\n}();\n\nvar _date = require(\"../../../core/utils/date\");\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _iterator = require(\"../../../core/utils/iterator\");\n\nvar _array = require(\"../../../core/utils/array\");\n\nvar _array2 = _interopRequireDefault(_array);\n\nvar _uiSchedulerAppointmentsStrategy = require(\"./ui.scheduler.appointments.strategy.base\");\n\nvar _uiSchedulerAppointmentsStrategy2 = _interopRequireDefault(_uiSchedulerAppointmentsStrategy);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (\"object\" === typeof call || \"function\" === typeof call) ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (\"function\" !== typeof superClass && null !== superClass) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (superClass) {\n    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n}\n\nvar AgendaRenderingStrategy = function (_BaseAppointmentsStra) {\n  _inherits(AgendaRenderingStrategy, _BaseAppointmentsStra);\n\n  function AgendaRenderingStrategy() {\n    _classCallCheck(this, AgendaRenderingStrategy);\n\n    return _possibleConstructorReturn(this, (AgendaRenderingStrategy.__proto__ || Object.getPrototypeOf(AgendaRenderingStrategy)).apply(this, arguments));\n  }\n\n  _createClass(AgendaRenderingStrategy, [{\n    key: \"getAppointmentMinSize\",\n    value: function value() {}\n  }, {\n    key: \"getDeltaTime\",\n    value: function value() {}\n  }, {\n    key: \"keepAppointmentSettings\",\n    value: function value() {\n      return true;\n    }\n  }, {\n    key: \"getAppointmentGeometry\",\n    value: function value(geometry) {\n      return geometry;\n    }\n  }, {\n    key: \"createTaskPositionMap\",\n    value: function value(appointments) {\n      if (appointments.length) {\n        var height = this.instance.fire(\"getAgendaVerticalStepHeight\"),\n            appointmentsByResources = this.instance.fire(\"groupAppointmentsByResources\", appointments),\n            groupedAppts = [];\n        (0, _iterator.each)(appointmentsByResources, function (i, appts) {\n          var additionalAppointments = [],\n              recurrentIndexes = [];\n          (0, _iterator.each)(appts, function (index, appointment) {\n            var recurrenceBatch = this.instance.getAppointmentsInstance()._processRecurrenceAppointment(appointment, index),\n                appointmentBatch = null;\n\n            if (!recurrenceBatch.indexes.length) {\n              appointmentBatch = {\n                parts: []\n              };\n              appointmentBatch = this.instance.getAppointmentsInstance()._processLongAppointment(appointment);\n              additionalAppointments = additionalAppointments.concat(appointmentBatch.parts);\n            }\n\n            additionalAppointments = additionalAppointments.concat(recurrenceBatch.parts);\n            recurrentIndexes = recurrentIndexes.concat(recurrenceBatch.indexes);\n          }.bind(this));\n\n          this.instance.getAppointmentsInstance()._reduceRecurrenceAppointments(recurrentIndexes, appts);\n\n          this.instance.getAppointmentsInstance()._combineAppointments(appts, additionalAppointments);\n\n          groupedAppts = groupedAppts.concat(appts);\n        }.bind(this));\n        Array.prototype.splice.apply(appointments, [0, appointments.length].concat(groupedAppts));\n      }\n\n      var result = [],\n          sortedIndex = 0;\n      appointments.forEach(function (appt, index) {\n        result.push([{\n          height: height,\n          width: \"100%\",\n          sortedIndex: sortedIndex++,\n          groupIndex: this._calculateGroupIndex(index, appointmentsByResources)\n        }]);\n      }.bind(this));\n      return result;\n    }\n  }, {\n    key: \"_calculateGroupIndex\",\n    value: function value(apptIndex, appointmentsByResources) {\n      var resultInd,\n          counter = 0;\n\n      for (var i in appointmentsByResources) {\n        var countApptInGroup = appointmentsByResources[i].length;\n\n        if (apptIndex >= counter && apptIndex < counter + countApptInGroup) {\n          resultInd = Number(i);\n          break;\n        }\n\n        counter += countApptInGroup;\n      }\n\n      return resultInd;\n    }\n  }, {\n    key: \"_getDeltaWidth\",\n    value: function value() {}\n  }, {\n    key: \"_correctRtlCoordinatesParts\",\n    value: function value() {}\n  }, {\n    key: \"_getAppointmentMaxWidth\",\n    value: function value() {\n      return this.getDefaultCellWidth();\n    }\n  }, {\n    key: \"_needVerifyItemSize\",\n    value: function value() {\n      return false;\n    }\n  }, {\n    key: \"_isRtl\",\n    value: function value() {\n      return this.instance.option(\"rtlEnabled\");\n    }\n  }, {\n    key: \"_getAppointmentParts\",\n    value: function value() {}\n  }, {\n    key: \"_reduceMultiWeekAppointment\",\n    value: function value() {}\n  }, {\n    key: \"calculateAppointmentHeight\",\n    value: function value() {\n      return 0;\n    }\n  }, {\n    key: \"calculateAppointmentWidth\",\n    value: function value() {\n      return 0;\n    }\n  }, {\n    key: \"isAppointmentGreaterThan\",\n    value: function value() {}\n  }, {\n    key: \"isAllDay\",\n    value: function value() {\n      return false;\n    }\n  }, {\n    key: \"_sortCondition\",\n    value: function value() {}\n  }, {\n    key: \"_rowCondition\",\n    value: function value() {}\n  }, {\n    key: \"_columnCondition\",\n    value: function value() {}\n  }, {\n    key: \"_findIndexByKey\",\n    value: function value() {}\n  }, {\n    key: \"_getMaxNeighborAppointmentCount\",\n    value: function value() {}\n  }, {\n    key: \"_markAppointmentAsVirtual\",\n    value: function value() {}\n  }, {\n    key: \"getDropDownAppointmentWidth\",\n    value: function value() {}\n  }, {\n    key: \"getDefaultCellWidth\",\n    value: function value() {\n      return this._defaultWidth;\n    }\n  }, {\n    key: \"getCompactAppointmentDefaultWidth\",\n    value: function value() {}\n  }, {\n    key: \"getCompactAppointmentLeftOffset\",\n    value: function value() {}\n  }, {\n    key: \"getCompactAppointmentTopOffset\",\n    value: function value() {}\n  }, {\n    key: \"calculateRows\",\n    value: function value(appointments, agendaDuration, currentDate, needClearSettings) {\n      this._rows = [];\n      var appts = {\n        indexes: [],\n        parts: []\n      };\n      var groupedAppointments = this.instance.fire(\"groupAppointmentsByResources\", appointments);\n      currentDate = _date2.default.trimTime(new Date(currentDate));\n      (0, _iterator.each)(groupedAppointments, function (groupIndex, currentAppointments) {\n        var groupResult = [];\n\n        if (!currentAppointments.length) {\n          this._rows.push([]);\n\n          return true;\n        }\n\n        (0, _iterator.each)(currentAppointments, function (index, appointment) {\n          var startDate = this.instance.fire(\"getField\", \"startDate\", appointment),\n              endDate = this.instance.fire(\"getField\", \"endDate\", appointment);\n          this.instance.fire(\"fixWrongEndDate\", appointment, startDate, endDate);\n          needClearSettings && delete appointment.settings;\n\n          var result = this.instance.getAppointmentsInstance()._processRecurrenceAppointment(appointment, index, false);\n\n          appts.parts = appts.parts.concat(result.parts);\n          appts.indexes = appts.indexes.concat(result.indexes);\n        }.bind(this));\n\n        this.instance.getAppointmentsInstance()._reduceRecurrenceAppointments(appts.indexes, currentAppointments);\n\n        _array2.default.merge(currentAppointments, appts.parts);\n\n        var appointmentCount = currentAppointments.length;\n\n        for (var i = 0; i < agendaDuration; i++) {\n          var day = new Date(currentDate);\n          day.setMilliseconds(day.getMilliseconds() + 864e5 * i);\n\n          if (void 0 === groupResult[i]) {\n            groupResult[i] = 0;\n          }\n\n          for (var j = 0; j < appointmentCount; j++) {\n            var appointmentData = currentAppointments[j].settings || currentAppointments[j],\n                appointmentIsLong = this.instance.fire(\"appointmentTakesSeveralDays\", currentAppointments[j]),\n                appointmentIsRecurrence = this.instance.fire(\"getField\", \"recurrenceRule\", currentAppointments[j]);\n\n            if (this.instance.fire(\"dayHasAppointment\", day, appointmentData, true) || !appointmentIsRecurrence && appointmentIsLong && this.instance.fire(\"dayHasAppointment\", day, currentAppointments[j], true)) {\n              groupResult[i] += 1;\n            }\n          }\n        }\n\n        this._rows.push(groupResult);\n      }.bind(this));\n      return this._rows;\n    }\n  }, {\n    key: \"_iterateRow\",\n    value: function value(row, obj, index) {\n      for (var i = 0; i < row.length; i++) {\n        obj.counter = obj.counter + row[i];\n\n        if (obj.counter >= index) {\n          obj.indexInRow = i;\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"getDateByIndex\",\n    value: function value(index, rows, startViewDate) {\n      var obj = {\n        counter: 0,\n        indexInRow: 0\n      };\n      index++;\n\n      for (var i = 0; i < rows.length; i++) {\n        this._iterateRow(rows[i], obj, index);\n\n        if (obj.indexInRow) {\n          break;\n        }\n      }\n\n      return new Date(new Date(startViewDate).setDate(startViewDate.getDate() + obj.indexInRow));\n    }\n  }, {\n    key: \"getAppointmentDataCalculator\",\n    value: function value() {\n      return function ($appointment, originalStartDate) {\n        var apptIndex = $appointment.index(),\n            startViewDate = this.instance.getStartViewDate(),\n            calculatedStartDate = this.getDateByIndex(apptIndex, this._rows, startViewDate),\n            wrappedOriginalStartDate = new Date(originalStartDate);\n        return {\n          startDate: new Date(calculatedStartDate.setHours(wrappedOriginalStartDate.getHours(), wrappedOriginalStartDate.getMinutes(), wrappedOriginalStartDate.getSeconds(), wrappedOriginalStartDate.getMilliseconds()))\n        };\n      }.bind(this);\n    }\n  }]);\n\n  return AgendaRenderingStrategy;\n}(_uiSchedulerAppointmentsStrategy2.default);\n\nmodule.exports = AgendaRenderingStrategy;","map":null,"metadata":{},"sourceType":"script"}