{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/rendering_strategies/ui.scheduler.appointments.strategy.vertical.js)\r\n * Version: 19.1.6 (build 19263-1729)\r\n * Build date: Fri Sep 20 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n\n      if (\"value\" in descriptor) {\n        descriptor.writable = true;\n      }\n\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) {\n      defineProperties(Constructor.prototype, protoProps);\n    }\n\n    if (staticProps) {\n      defineProperties(Constructor, staticProps);\n    }\n\n    return Constructor;\n  };\n}();\n\nvar _get = function get(object, property, receiver) {\n  if (null === object) {\n    object = Function.prototype;\n  }\n\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (void 0 === desc) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (null === parent) {\n      return;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else {\n    if (\"value\" in desc) {\n      return desc.value;\n    } else {\n      var getter = desc.get;\n\n      if (void 0 === getter) {\n        return;\n      }\n\n      return getter.call(receiver);\n    }\n  }\n};\n\nvar _uiSchedulerAppointmentsStrategy = require(\"./ui.scheduler.appointments.strategy.base\");\n\nvar _uiSchedulerAppointmentsStrategy2 = _interopRequireDefault(_uiSchedulerAppointmentsStrategy);\n\nvar _extend = require(\"../../../core/utils/extend\");\n\nvar _type = require(\"../../../core/utils/type\");\n\nvar _devices = require(\"../../../core/devices\");\n\nvar _devices2 = _interopRequireDefault(_devices);\n\nvar _date = require(\"../../../core/utils/date\");\n\nvar _date2 = _interopRequireDefault(_date);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (\"object\" === typeof call || \"function\" === typeof call) ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (\"function\" !== typeof superClass && null !== superClass) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (superClass) {\n    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n}\n\nvar WEEK_APPOINTMENT_DEFAULT_OFFSET = 25,\n    WEEK_APPOINTMENT_MOBILE_OFFSET = 50,\n    APPOINTMENT_MIN_WIDTH = 5,\n    ALLDAY_APPOINTMENT_MIN_VERTICAL_OFFSET = 5,\n    ALLDAY_APPOINTMENT_MAX_VERTICAL_OFFSET = 20;\nvar toMs = _date2.default.dateToMilliseconds;\n\nvar VerticalRenderingStrategy = function (_BaseAppointmentsStra) {\n  _inherits(VerticalRenderingStrategy, _BaseAppointmentsStra);\n\n  function VerticalRenderingStrategy() {\n    _classCallCheck(this, VerticalRenderingStrategy);\n\n    return _possibleConstructorReturn(this, (VerticalRenderingStrategy.__proto__ || Object.getPrototypeOf(VerticalRenderingStrategy)).apply(this, arguments));\n  }\n\n  _createClass(VerticalRenderingStrategy, [{\n    key: \"getDeltaTime\",\n    value: function value(args, initialSize, appointment) {\n      var deltaTime = 0;\n\n      if (this.isAllDay(appointment)) {\n        deltaTime = this._getDeltaWidth(args, initialSize) * toMs(\"day\");\n      } else {\n        var deltaHeight = args.height - initialSize.height;\n        deltaTime = toMs(\"minute\") * Math.round(deltaHeight / this.getDefaultCellHeight() * this.instance.getAppointmentDurationInMinutes());\n      }\n\n      return deltaTime;\n    }\n  }, {\n    key: \"getAppointmentGeometry\",\n    value: function value(coordinates) {\n      var result,\n          allDay = coordinates.allDay;\n\n      if (allDay) {\n        result = this._getAllDayAppointmentGeometry(coordinates);\n      } else {\n        result = this._getVerticalAppointmentGeometry(coordinates);\n      }\n\n      return _get(VerticalRenderingStrategy.prototype.__proto__ || Object.getPrototypeOf(VerticalRenderingStrategy.prototype), \"getAppointmentGeometry\", this).call(this, result);\n    }\n  }, {\n    key: \"_getItemPosition\",\n    value: function value(item) {\n      var allDay = this.isAllDay(item),\n          isRecurring = !!this.instance.fire(\"getField\", \"recurrenceRule\", item);\n\n      if (allDay) {\n        return _get(VerticalRenderingStrategy.prototype.__proto__ || Object.getPrototypeOf(VerticalRenderingStrategy.prototype), \"_getItemPosition\", this).call(this, item);\n      }\n\n      var position = this._getAppointmentCoordinates(item),\n          result = [];\n\n      for (var j = 0; j < position.length; j++) {\n        var height = this.calculateAppointmentHeight(item, position[j], isRecurring),\n            width = this.calculateAppointmentWidth(item, position[j], isRecurring),\n            resultHeight = height,\n            appointmentReduced = null,\n            multiDaysAppointmentParts = [],\n            currentMaxAllowedPosition = position[j].vMax;\n\n        if (this._isMultiDayAppointment(position[j], height)) {\n          appointmentReduced = \"head\";\n          resultHeight = this._reduceMultiDayAppointment(height, {\n            top: position[j].top,\n            bottom: currentMaxAllowedPosition\n          });\n          multiDaysAppointmentParts = this._getAppointmentParts({\n            sourceAppointmentHeight: height,\n            reducedHeight: resultHeight,\n            width: width\n          }, position[j]);\n        }\n\n        (0, _extend.extend)(position[j], {\n          height: resultHeight,\n          width: width,\n          allDay: allDay,\n          appointmentReduced: appointmentReduced\n        });\n        result = this._getAppointmentPartsPosition(multiDaysAppointmentParts, position[j], result);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_isMultiDayAppointment\",\n    value: function value(position, height) {\n      var maxTop = position.vMax,\n          result = height > maxTop - position.top;\n      return result;\n    }\n  }, {\n    key: \"_reduceMultiDayAppointment\",\n    value: function value(sourceAppointmentHeight, bound) {\n      sourceAppointmentHeight = bound.bottom - Math.floor(bound.top);\n      return sourceAppointmentHeight;\n    }\n  }, {\n    key: \"_getAppointmentParts\",\n    value: function value(appointmentGeometry, appointmentSettings) {\n      var tailHeight = appointmentGeometry.sourceAppointmentHeight - appointmentGeometry.reducedHeight,\n          width = appointmentGeometry.width,\n          result = [],\n          currentPartTop = this.instance.fire(\"getGroupTop\", appointmentSettings.groupIndex),\n          offset = this.instance.fire(\"isGroupedByDate\") ? this.getDefaultCellWidth() * this.instance.fire(\"getGroupCount\") : this.getDefaultCellWidth(),\n          left = appointmentSettings.left + offset;\n\n      if (tailHeight) {\n        var minHeight = this.getAppointmentMinSize();\n\n        if (tailHeight < minHeight) {\n          tailHeight = minHeight;\n        }\n\n        currentPartTop += this.instance.fire(\"getOffsetByAllDayPanel\", appointmentSettings.groupIndex);\n        result.push((0, _extend.extend)(true, {}, appointmentSettings, {\n          top: currentPartTop,\n          left: left,\n          height: tailHeight,\n          width: width,\n          appointmentReduced: \"tail\",\n          rowIndex: ++appointmentSettings.rowIndex\n        }));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getMinuteHeight\",\n    value: function value() {\n      return this.getDefaultCellHeight() / this.instance.getAppointmentDurationInMinutes();\n    }\n  }, {\n    key: \"_getCompactLeftCoordinate\",\n    value: function value(itemLeft, index) {\n      var cellBorderSize = 1,\n          cellWidth = this.getDefaultCellWidth() || this.getAppointmentMinSize();\n      return itemLeft + (cellBorderSize + cellWidth) * index;\n    }\n  }, {\n    key: \"_checkLongCompactAppointment\",\n    value: function value(item, result) {\n      this._splitLongCompactAppointment(item, result);\n\n      return result;\n    }\n  }, {\n    key: \"_getVerticalAppointmentGeometry\",\n    value: function value(coordinates) {\n      var overlappingMode = this.instance.fire(\"getMaxAppointmentsPerCell\");\n\n      if (overlappingMode) {\n        var config = this._calculateVerticalGeometryConfig(coordinates);\n\n        return this._customizeVerticalCoordinates(coordinates, config.width, config.appointmentCountPerCell, config.offset);\n      } else {\n        var width = this._getAppointmentMaxWidth() / coordinates.count,\n            height = coordinates.height,\n            top = coordinates.top,\n            left = coordinates.left + coordinates.index * width;\n\n        if (width < APPOINTMENT_MIN_WIDTH) {\n          width = APPOINTMENT_MIN_WIDTH;\n        }\n\n        return {\n          height: height,\n          width: width,\n          top: top,\n          left: left,\n          empty: this._isAppointmentEmpty(height, width)\n        };\n      }\n    }\n  }, {\n    key: \"_customizeVerticalCoordinates\",\n    value: function value(coordinates, width, appointmentCountPerCell, topOffset, isAllDay) {\n      var compactAppointmentDefaultSize,\n          compactAppointmentDefaultOffset,\n          index = coordinates.index,\n          appointmentWidth = Math.max(width / appointmentCountPerCell, width / coordinates.count),\n          height = coordinates.height,\n          appointmentLeft = coordinates.left + coordinates.index * appointmentWidth,\n          top = coordinates.top;\n\n      if (coordinates.isCompact) {\n        compactAppointmentDefaultSize = this.getCompactAppointmentDefaultWidth();\n        compactAppointmentDefaultOffset = this.getCompactAppointmentLeftOffset();\n        top = coordinates.top + compactAppointmentDefaultOffset;\n        appointmentLeft = coordinates.left + (index - appointmentCountPerCell) * (compactAppointmentDefaultSize + compactAppointmentDefaultOffset) + compactAppointmentDefaultOffset;\n        appointmentWidth = compactAppointmentDefaultSize;\n        width = compactAppointmentDefaultSize;\n\n        this._markAppointmentAsVirtual(coordinates, isAllDay);\n      }\n\n      return {\n        height: height,\n        width: appointmentWidth,\n        top: top,\n        left: appointmentLeft,\n        empty: this._isAppointmentEmpty(height, width)\n      };\n    }\n  }, {\n    key: \"_calculateVerticalGeometryConfig\",\n    value: function value(coordinates) {\n      var overlappingMode = this.instance.fire(\"getMaxAppointmentsPerCell\"),\n          offsets = this._getOffsets(),\n          appointmentDefaultOffset = this._getAppointmentDefaultOffset();\n\n      var appointmentCountPerCell = this._getAppointmentCount(overlappingMode, coordinates);\n\n      var ratio = this._getDefaultRatio(coordinates, appointmentCountPerCell);\n\n      var maxWidth = this._getMaxWidth();\n\n      if (!appointmentCountPerCell) {\n        appointmentCountPerCell = coordinates.count;\n        ratio = (maxWidth - offsets.unlimited) / maxWidth;\n      }\n\n      var topOffset = (1 - ratio) * maxWidth;\n\n      if (\"auto\" === overlappingMode || (0, _type.isNumeric)(overlappingMode)) {\n        ratio = 1;\n        maxWidth -= appointmentDefaultOffset;\n        topOffset = 0;\n      }\n\n      return {\n        width: ratio * maxWidth,\n        appointmentCountPerCell: appointmentCountPerCell,\n        offset: topOffset\n      };\n    }\n  }, {\n    key: \"_getMaxWidth\",\n    value: function value() {\n      return this.getDefaultCellWidth() || this.invoke(\"getCellWidth\");\n    }\n  }, {\n    key: \"isAllDay\",\n    value: function value(appointmentData) {\n      var allDay = this.instance.fire(\"getField\", \"allDay\", appointmentData);\n\n      if (allDay) {\n        return true;\n      }\n\n      return this.instance.appointmentTakesAllDay(appointmentData);\n    }\n  }, {\n    key: \"_getAppointmentMaxWidth\",\n    value: function value() {\n      var offset = \"desktop\" === _devices2.default.current().deviceType && !this.instance.fire(\"isAdaptive\") ? WEEK_APPOINTMENT_DEFAULT_OFFSET : WEEK_APPOINTMENT_MOBILE_OFFSET,\n          width = this.getDefaultCellWidth() - offset;\n      return width > 0 ? width : this.getAppointmentMinSize();\n    }\n  }, {\n    key: \"calculateAppointmentWidth\",\n    value: function value(appointment, position, isRecurring) {\n      if (!this.isAllDay(appointment)) {\n        return 0;\n      }\n\n      var startDate = new Date(this.startDate(appointment, false, position)),\n          endDate = this.endDate(appointment, position, isRecurring),\n          cellWidth = this.getDefaultCellWidth() || this.getAppointmentMinSize();\n      startDate = _date2.default.trimTime(startDate);\n      var durationInHours = (endDate.getTime() - startDate.getTime()) / toMs(\"hour\");\n      var width = Math.ceil(durationInHours / 24) * cellWidth;\n      width = this.cropAppointmentWidth(width, cellWidth);\n      return width;\n    }\n  }, {\n    key: \"calculateAppointmentHeight\",\n    value: function value(appointment, position, isRecurring) {\n      var endDate = this.endDate(appointment, position, isRecurring),\n          startDate = this.startDate(appointment, false, position),\n          allDay = this.instance.fire(\"getField\", \"allDay\", appointment);\n\n      if (this.isAllDay(appointment)) {\n        return 0;\n      }\n\n      var fullDuration = this._getAppointmentDurationInMs(startDate, endDate, allDay),\n          durationInMinutes = this._adjustDurationByDaylightDiff(fullDuration, startDate, endDate) / toMs(\"minute\");\n\n      var height = durationInMinutes * this._getMinuteHeight();\n\n      return height;\n    }\n  }, {\n    key: \"getDirection\",\n    value: function value() {\n      return \"vertical\";\n    }\n  }, {\n    key: \"_sortCondition\",\n    value: function value(a, b) {\n      var allDayCondition = a.allDay - b.allDay,\n          isAllDay = a.allDay && b.allDay,\n          condition = \"vertical\" === this.instance._groupOrientation && isAllDay ? this._columnCondition(a, b) : this._rowCondition(a, b),\n          result = allDayCondition ? allDayCondition : condition;\n      return this._fixUnstableSorting(result, a, b);\n    }\n  }, {\n    key: \"hasAllDayAppointments\",\n    value: function value() {\n      return true;\n    }\n  }, {\n    key: \"_getAllDayAppointmentGeometry\",\n    value: function value(coordinates) {\n      var config = this._calculateGeometryConfig(coordinates);\n\n      return this._customizeCoordinates(coordinates, config.height, config.appointmentCountPerCell, config.offset, true);\n    }\n  }, {\n    key: \"_calculateGeometryConfig\",\n    value: function value(coordinates) {\n      if (!this.instance._allowResizing() || !this.instance._allowAllDayResizing()) {\n        coordinates.skipResizing = true;\n      }\n\n      var config = _get(VerticalRenderingStrategy.prototype.__proto__ || Object.getPrototypeOf(VerticalRenderingStrategy.prototype), \"_calculateGeometryConfig\", this).call(this, coordinates);\n\n      if (coordinates.count <= this._getDynamicAppointmentCountPerCell().allDay) {\n        config.offset = 0;\n      }\n\n      return config;\n    }\n  }, {\n    key: \"_getAppointmentCount\",\n    value: function value(overlappingMode, coordinates) {\n      return \"auto\" !== overlappingMode && 1 === coordinates.count && !(0, _type.isNumeric)(overlappingMode) ? coordinates.count : this._getMaxAppointmentCountPerCellByType(coordinates.allDay);\n    }\n  }, {\n    key: \"_getDefaultRatio\",\n    value: function value(coordinates, appointmentCountPerCell) {\n      return coordinates.count > this.instance.option(\"_appointmentCountPerCell\") ? .65 : 1;\n    }\n  }, {\n    key: \"_getOffsets\",\n    value: function value() {\n      return {\n        unlimited: ALLDAY_APPOINTMENT_MIN_VERTICAL_OFFSET,\n        auto: ALLDAY_APPOINTMENT_MAX_VERTICAL_OFFSET\n      };\n    }\n  }, {\n    key: \"_getMaxHeight\",\n    value: function value() {\n      return this.getDefaultAllDayCellHeight() || this.getAppointmentMinSize();\n    }\n  }, {\n    key: \"_needVerticalGroupBounds\",\n    value: function value(allDay) {\n      return !allDay;\n    }\n  }, {\n    key: \"_needHorizontalGroupBounds\",\n    value: function value() {\n      return false;\n    }\n  }]);\n\n  return VerticalRenderingStrategy;\n}(_uiSchedulerAppointmentsStrategy2.default);\n\nmodule.exports = VerticalRenderingStrategy;","map":null,"metadata":{},"sourceType":"script"}